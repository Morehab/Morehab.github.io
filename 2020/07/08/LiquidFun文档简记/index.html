<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.jpg">
  <link rel="icon" type="image/png" href="/img/icon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>LiquidFun文档简记 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Morehab's Space</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/post.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.15)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-08 23:05">
      July 8, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      132
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-post-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-post-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：8 months ago
                
              </p>
            
            <article class="markdown-body">
              <h2 id="0-Pre-Everything"><a href="#0-Pre-Everything" class="headerlink" title="0. Pre-Everything"></a>0. Pre-Everything</h2><h3 id="0-0-Reference"><a href="#0-0-Reference" class="headerlink" title="0.0 Reference"></a>0.0 Reference</h3><p><a href="http://www.ladeng6666.com/blog/?cat=8" target="_blank" rel="noopener">Blog：拉小登，上面有Box2D部分概念和应用</a></p>
<p><a href="http://code.google.com/p/box2d/downloads/list" target="_blank" rel="noopener">Erin Catto’s GDC Tutorials</a></p>
<p><em>Collision Detection in Interactive 3D Environments,</em> Gino van den Bergen, 2004<br><em>Real-Time Collision Detection,</em> Christer Ericson, 2005</p>
<h2 id="1-Collision模块。"><a href="#1-Collision模块。" class="headerlink" title="1. Collision模块。"></a>1. Collision模块。</h2><h3 id="1-0-Shape"><a href="#1-0-Shape" class="headerlink" title="1.0 Shape"></a>1.0 Shape</h3><p>用于碰撞检测，在b2Fixture创建时会由b2World自动创建。</p>
<ul>
<li>第一种：通过fixture与body绑定，随body进行rigid moves。</li>
<li>第二种：通过顶点坐标的形式存在于world中，只能通过手动设置坐标进行移动。</li>
</ul>
<p>（1）分类：</p>
<pre><code class="hljs C++"><span class="hljs-keyword">enum</span> Type &#123; 
  e_circle = <span class="hljs-number">0</span>, e_edge = <span class="hljs-number">1</span>, 
  e_polygon = <span class="hljs-number">2</span>, e_chain = <span class="hljs-number">3</span>, 
  e_typeCount = <span class="hljs-number">4</span> 
&#125;</code></pre>

<p>（2）子类：b2ChainShape, b2CircleShape, …Edge…, …Polygon…。</p>
<p>（3）数据成员：m_type, m_radius。</p>
<p>（4）public成员函数：</p>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cmember_f.png" srcset="/img/loading.gif" alt="image-20200709114719125"></p>
<h3 id="1-1-Circle"><a href="#1-1-Circle" class="headerlink" title="1.1 Circle"></a>1.1 Circle</h3><pre><code class="hljs c++">b2CircleShape <span class="hljs-built_in">circle</span>;  <span class="hljs-comment">//实心</span>
<span class="hljs-built_in">circle</span>.m_p.Set(<span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>); <span class="hljs-comment">//圆心位置</span>
<span class="hljs-built_in">circle</span>.m_radius = <span class="hljs-number">0.5f</span>; <span class="hljs-comment">//半径必须大于零</span></code></pre>

<h3 id="1-2-Polygon"><a href="#1-2-Polygon" class="headerlink" title="1.2 Polygon"></a>1.2 Polygon</h3><p>Def: 实心凸（连接内部两点的线段不与边交叉）多边形，&gt;=3边。</p>
<p>通过CCW（逆时针winding）填充：</p>
<blockquote>
<p>多边形填充有两种模式：alternate和winding。</p>
<p><strong>alternate</strong>: </p>
<p>显示器的每个扫描行都是从左到右扫描，系统只填充每个扫描行遇到的多边形的奇数边和偶数边之间的部分，不填充偶数边到奇数边之间的部分。</p>
<p><strong>winding</strong>: </p>
<p>用一笔画一个多边形，分clockwise或counterclockwise。</p>
<p>画一条直线M，对于与它相交的线段：从直线M的左边到右边为clockwise，count+1；从直线M的右边到左边为counterclockwise，count-1。<br>判断一个区域E是否要被填充：从该区域画一线段M到整个多边型区域外，按照上面的方法对<strong>与该线相交的多边形的边</strong>进行count的计数，如果count非零则区域E要被填充，否则不填充。  </p>
</blockquote>
<p>从shape继承了radius，用于在多边形周围创造skin，防止tunneling。</p>
<p>这会导致形状之间有小gap，可以将visual表示做得大一点。</p>
<p><strong>成员都是public的</strong>， 初始化可传入一个vertex数组：</p>
<pre><code class="hljs C++"><span class="hljs-comment">///至多b2_maxPolygonVertices个顶点</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">b2PolygonShape</span> :</span> <span class="hljs-keyword">public</span> b2Shape
&#123;
<span class="hljs-keyword">public</span>:
	b2PolygonShape();
    
	<span class="hljs-comment">/// Implement b2Shape.</span>
	<span class="hljs-function">b2Shape* <span class="hljs-title">Clone</span><span class="hljs-params">(b2BlockAllocator* allocator)</span> <span class="hljs-keyword">const</span></span>;

	<span class="hljs-comment">/// @see b2Shape::GetChildCount</span>
	<span class="hljs-function">int32 <span class="hljs-title">GetChildCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;

	<span class="hljs-comment">/// 用顶点数组创造多边形。</span>
	<span class="hljs-comment">/// 边数count属于[3, b2_maxPolygonVertices].</span>
	<span class="hljs-comment">/// 即时传入的点能构成多边形，点也可能被重排。</span>
	<span class="hljs-comment">/// 共线的点被处理但不被移除。</span>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2* points, int32 count)</span></span>;

	<span class="hljs-comment">/// 以原点为中心，平行于坐标轴。</span>
	<span class="hljs-comment">/// hx the half-width，hy the half-height.</span>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetAsBox</span><span class="hljs-params">(float32 hx, float32 hy)</span></span>;

	<span class="hljs-comment">/// hx the half-width，hy the half-height.</span>
	<span class="hljs-comment">/// center：中心坐标</span>
	<span class="hljs-comment">/// angle：旋转角度</span>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetAsBox</span><span class="hljs-params">(float32 hx, float32 hy, <span class="hljs-keyword">const</span> b2Vec2&amp; center, float32 angle)</span></span>;

	<span class="hljs-comment">/// @see b2Shape::TestPoint</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">TestPoint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Transform&amp; transform, <span class="hljs-keyword">const</span> b2Vec2&amp; p)</span> <span class="hljs-keyword">const</span></span>;

	<span class="hljs-comment">// @see b2Shape::ComputeDistance</span>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ComputeDistance</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Transform&amp; xf, <span class="hljs-keyword">const</span> b2Vec2&amp; p, float32* distance, b2Vec2* normal, int32 childIndex)</span> <span class="hljs-keyword">const</span></span>;

	<span class="hljs-comment">/// Implement b2Shape.</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">RayCast</span><span class="hljs-params">(b2RayCastOutput* output, <span class="hljs-keyword">const</span> b2RayCastInput&amp; input,</span></span>
<span class="hljs-function"><span class="hljs-params">					<span class="hljs-keyword">const</span> b2Transform&amp; transform, int32 childIndex)</span> <span class="hljs-keyword">const</span></span>;

	<span class="hljs-comment">/// @see b2Shape::ComputeAABB</span>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ComputeAABB</span><span class="hljs-params">(b2AABB* aabb, <span class="hljs-keyword">const</span> b2Transform&amp; transform, int32 childIndex)</span> <span class="hljs-keyword">const</span></span>;

	<span class="hljs-comment">/// @see b2Shape::ComputeMass</span>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ComputeMass</span><span class="hljs-params">(b2MassData* massData, float32 density)</span> <span class="hljs-keyword">const</span></span>;

	<span class="hljs-comment">/// Get the vertex count.</span>
	<span class="hljs-function">int32 <span class="hljs-title">GetVertexCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_count; &#125;

	<span class="hljs-comment">/// Get a vertex by index.</span>
	<span class="hljs-function"><span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-title">GetVertex</span><span class="hljs-params">(int32 index)</span> <span class="hljs-keyword">const</span></span>;

	<span class="hljs-comment">/// 验证凸性，耗时很长。</span>
	<span class="hljs-comment">/// @returns true if valid</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Validate</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;

	b2Vec2 m_centroid; <span class="hljs-comment">//初始为0</span>
	b2Vec2 m_vertices[b2_maxPolygonVertices]; 
	b2Vec2 m_normals[b2_maxPolygonVertices];
	int32 m_count; <span class="hljs-comment">//b2_polygonRadius</span>
    <span class="hljs-comment">//m_type = e_polygon;</span>
	<span class="hljs-comment">//m_radius = b2_polygonRadius;</span>
&#125;;</code></pre>

<h3 id="1-3-Edge"><a href="#1-3-Edge" class="headerlink" title="1.3 Edge"></a>1.3 Edge</h3><p>线段，用于做静态的环境。能与circle,polygon碰撞，但不能与线段碰撞。</p>
<p>（这是由于碰撞系统要求两个物体至少一个有体积，线段无体积。）</p>
<pre><code class="hljs armasm"><span class="hljs-keyword">b2Vec2 </span><span class="hljs-built_in">v1</span>(<span class="hljs-number">0</span>.<span class="hljs-number">0</span>f, <span class="hljs-number">0</span>.<span class="hljs-number">0</span>f), <span class="hljs-built_in">v2</span>(<span class="hljs-number">1</span>.<span class="hljs-number">0</span>f, <span class="hljs-number">0</span>.<span class="hljs-number">0</span>f)<span class="hljs-comment">;</span>
<span class="hljs-keyword">b2EdgeShape </span>edge<span class="hljs-comment">;</span>
<span class="hljs-symbol">edge.Set</span>(<span class="hljs-built_in">v1</span>, <span class="hljs-built_in">v2</span>)<span class="hljs-comment">;  //初始化</span></code></pre>

<p>通常游戏世界会涉及多条线段连接而成的线。当物体在其上滑动时，可能会与线段顶点发声ghost collision，造成internal collision normal。</p>
<p>于是有如下机制：使用命令</p>
<pre><code class="hljs C++">b2Vec2 v0<span class="hljs-number">-3</span>(x0<span class="hljs-number">-3</span>,y0<span class="hljs-number">-3</span>);
b2EdgeShape edge;
edge.Set(v1, v2);

   edge.m_hasVertex0 = <span class="hljs-literal">true</span>;
   edge.m_hasVertex3 = <span class="hljs-literal">true</span>;
   edge.m_vertex0 = v0;
   edge.m_vertex3 = v3;</code></pre>

<p>存入临近的ghost vertice，但这有点麻烦。</p>
<p>![image-20200708114649294](C:\Users\ybr19\Documents\100%_MOREHAB\Files\BLOGGER\source\img\blog\ghost collision.png)</p>
<p>于是又有如下机制：将边缝合为chain shapes。这可以防止ghost collision，并提供<strong>双边碰撞（two-sided collision, 我猜测指的是在两端的碰撞）。</strong></p>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5C2-sided.png" srcset="/img/loading.gif" alt="Chain shape"></p>
<pre><code class="hljs C++"><span class="hljs-comment">// This a chain shape with isolated vertices</span>
  b2Vec2 vs[<span class="hljs-number">4</span>]; <span class="hljs-comment">//Set them</span>
  b2ChainShape chain;
  chain.CreateChain(vs, <span class="hljs-number">4</span>);</code></pre>


<p>对于滚动的游戏世界，可以使用ghost vertices将chain连接在一起。</p>
<pre><code class="hljs C++"><span class="hljs-comment">//Install ghost vertices</span>
chain.SetPrevVertex(b2Vec2(<span class="hljs-number">3.0f</span>, <span class="hljs-number">1.0f</span>));
chain.SetNextVertex(b2Vec2(<span class="hljs-number">-2.0f</span>, <span class="hljs-number">0.0f</span>));</code></pre>

<p>还可以创造<strong>loop</strong>：</p>
<pre><code class="hljs C++"><span class="hljs-comment">// first and last vertices are connected</span>
b2ChainShape chain;
chain.CreateLoop(vs, <span class="hljs-number">4</span>);</code></pre>

<p>代码<strong>不支持chain shape之间出现交叉</strong>，且vertices之间过近也可能导致问题，故最好保证边长于b2_linearSlop = 5mm。</p>
<blockquote>
<p>/// A small length used as a collision and constraint tolerance. Usually it is<br>/// chosen to be numerically significant, but visually insignificant.<br>#define b2_linearSlop            0.005f</p>
</blockquote>
<p>在chain中的边都被视作child shape，可以通过指标访问。当chain shape与body连接时，每个边在broad-phase碰撞树中都会得到自己的bounding box。</p>
<pre><code class="hljs C++"><span class="hljs-comment">// Visit each child edge.</span>
<span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; chain.GetChildCount(); ++i)
&#123;
   b2EdgeShape edge;
   chain.GetChildEdge(&amp;edge, i);
   …
&#125;</code></pre>



<h3 id="1-5-Transform"><a href="#1-5-Transform" class="headerlink" title="1.5 Transform"></a>1.5 Transform</h3><p>transform类用于表示刚体的位置，在Math.h中定义。</p>
<p>数据成员：</p>
<pre><code class="hljs 1c">b2Vec2 p; <span class="hljs-comment">//translation</span>
b2Rot q; <span class="hljs-comment">//rotation</span>
<span class="hljs-comment">//Rot类含两个数据成员：旋转角的s和c。</span></code></pre>



<h3 id="1-4-几何查询"><a href="#1-4-几何查询" class="headerlink" title="1.4  几何查询"></a>1.4  几何查询</h3><h4 id="1-4-1-查询点与形状的重合"><a href="#1-4-1-查询点与形状的重合" class="headerlink" title="1.4.1  查询点与形状的重合"></a>1.4.1  查询点与形状的重合</h4><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> hit = shape-&gt;<span class="hljs-constructor">TestPoint(<span class="hljs-params">transform</span>, <span class="hljs-params">point</span>)</span>;</code></pre>

<p>edge和chain（包括loop）总会返回false。</p>
<h4 id="1-4-2-进行ray-cast"><a href="#1-4-2-进行ray-cast" class="headerlink" title="1.4.2  进行ray cast"></a>1.4.2  进行ray cast</h4><blockquote>
<p>ray cast（光线投射）：</p>
<p>用于3D数据场的可视化，是体绘制中的一种处理方式：</p>
<p>向三维数据场投射出光线，然后沿着光线方向积分，数值化方法为由前往后或由后向前合成。</p>
<p>（不是很懂）</p>
</blockquote>
<p>在这里指用一束光线打到shape上，得到第一个交点和对应的向量。若光线从形状内部触发，则标记为未击中。</p>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cray_cast.png" srcset="/img/loading.gif" alt="image-20200709140659310"></p>
<h4 id="1-4-3-两个图形的重合"><a href="#1-4-3-两个图形的重合" class="headerlink" title="1.4.3 两个图形的重合"></a>1.4.3 两个图形的重合</h4><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> b2<span class="hljs-constructor">TestOverlap(<span class="hljs-params">const</span> <span class="hljs-params">b2Shape</span> <span class="hljs-operator">*</span><span class="hljs-params">sA</span>, <span class="hljs-params">int32</span> <span class="hljs-params">indexA</span>, <span class="hljs-params">const</span> <span class="hljs-params">b2Shape</span> <span class="hljs-operator">*</span><span class="hljs-params">sB</span>, <span class="hljs-params">int32</span> <span class="hljs-params">indexB</span>, <span class="hljs-params">const</span> <span class="hljs-params">b2Transform</span> &amp;<span class="hljs-params">xfa</span>, <span class="hljs-params">const</span> <span class="hljs-params">b2Transform</span> &amp;<span class="hljs-params">xfb</span>)</span>;
<span class="hljs-comment">//index指对于chain shapes的child index。</span></code></pre>

<h4 id="1-4-4-Contact-Manifold-接触流形"><a href="#1-4-4-Contact-Manifold-接触流形" class="headerlink" title="1.4.4 Contact Manifold(接触流形)"></a>1.4.4 Contact Manifold(接触流形)</h4><p>LiquidFun有用于计算重合shape的接触点的函数。</p>
<blockquote>
<p>normal vector: 法向量。</p>
</blockquote>
<p>圆对圆/圆对多边形：一个点+一个法向量。</p>
<p>多边形对多边形：两个点+一个法向量，被统一在一个流形结构里。</p>
<blockquote>
<p>b2Manifold类包含1*法向量 + &lt;=2个接触点，均以local坐标系保存。每个点都存下了法向和切向（摩擦）的力。</p>
<p>b2Manifold是用于内部使用的类。用户最好使用b2WorldManifold来生成normal和points在world中的坐标，需要提供b2Manifold, shape transform 和 radius。</p>
<pre><code class="hljs c++">b2WorldManifold worldManifold;
worldManifold.Initialize(&amp;manifold, transformA, shapeA.m_radius, transformB, shapeB.m_radius);
<span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; manifold.pointCount; ++i)
&#123;
   b2Vec2 <span class="hljs-built_in">point</span> = worldManifold.points[i];
   …
&#125;</code></pre>
</blockquote>
<p>在模拟中manifold会发生变化，点可能增加或减少，可以通过b2GetPointStates检测。</p>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cpointstate.png" srcset="/img/loading.gif" alt="image-20200709153724244"></p>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cgetstate.png" srcset="/img/loading.gif" alt="image-20200709153811976"></p>
<h4 id="1-4-5-距离"><a href="#1-4-5-距离" class="headerlink" title="1.4.5 距离"></a>1.4.5 距离</h4><p>b2Distance函数用于计算两个形状之间的距离，该函数需要将shape转化为shape proxy，还会进行一定的缓存以准备重复调用。</p>
<pre><code class="hljs C++"><span class="hljs-comment">/// Compute the closest points between two shapes. Supports any combination of:</span>
<span class="hljs-comment">/// b2CircleShape, b2PolygonShape, b2EdgeShape. The simplex cache is input/output.</span>
<span class="hljs-comment">/// On the first call set b2SimplexCache.count to zero.</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b2Distance</span><span class="hljs-params">(b2DistanceOutput* output,</span></span>
<span class="hljs-function"><span class="hljs-params">				b2SimplexCache* cache, </span></span>
<span class="hljs-function"><span class="hljs-params">				<span class="hljs-keyword">const</span> b2DistanceInput* input)</span></span>;</code></pre>

<p>其中，input的具体信息如下：</p>
<pre><code class="hljs C++"><span class="hljs-comment">/// Input for b2Distance.</span>
<span class="hljs-comment">/// You have to option to use the shape radii</span>
<span class="hljs-comment">/// in the computation. </span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">b2DistanceInput</span></span>
<span class="hljs-class">&#123;</span>
	b2DistanceProxy proxyA;
	b2DistanceProxy proxyB;
	b2Transform transformA;
	b2Transform transformB;
	<span class="hljs-keyword">bool</span> useRadii;
&#125;;</code></pre>

<p>output的具体信息如下：</p>
<pre><code class="hljs C++"><span class="hljs-comment">/// Output for b2Distance.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">b2DistanceOutput</span></span>
<span class="hljs-class">&#123;</span>
	b2Vec2 pointA;		<span class="hljs-comment">///&lt; closest point on shapeA</span>
	b2Vec2 pointB;		<span class="hljs-comment">///&lt; closest point on shapeB</span>
	float32 distance;
	int32 iterations;	<span class="hljs-comment">///&lt; number of GJK iterations used</span>
&#125;;</code></pre>

<p>SimplexCache的信息如下（不是很明白具体要传啥）：</p>
<pre><code class="hljs C++"><span class="hljs-comment">/// Used to warm start b2Distance.</span>
<span class="hljs-comment">/// Set count to zero on first call.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">b2SimplexCache</span></span>
<span class="hljs-class">&#123;</span>
	float32 metric;		<span class="hljs-comment">///&lt; length or area</span>
	uint16 count;
	uint8 indexA[<span class="hljs-number">3</span>];	<span class="hljs-comment">///&lt; vertices on shape A</span>
	uint8 indexB[<span class="hljs-number">3</span>];	<span class="hljs-comment">///&lt; vertices on shape B</span>
&#125;;</code></pre>

<h4 id="1-4-6-Time-of-Impact"><a href="#1-4-6-Time-of-Impact" class="headerlink" title="1.4.6 Time of Impact"></a>1.4.6 Time of Impact</h4><p>用于决定两个moving shapes的碰撞时间，防止tunneling。</p>
<p>该函数会考虑旋转和平移，但如果旋转角度过大，则函数可能遗漏碰撞。但函数仍然会报告不重合的时间，且会考虑所有的平移碰撞。</p>
<p><strong>后面还有一大段讨论这个函数的限制等，没太明白，暂且跳过。</strong></p>
<h3 id="1-5-动态树"><a href="#1-5-动态树" class="headerlink" title="1.5 动态树"></a>1.5 动态树</h3><p>用于有效地管理大量shapes（但实际上它并不掌握shape的信息，而是在AABB上操作）。</p>
<p>该树就是AABB的层级树，每个内部节点有两个子节点，叶子是单用户的AABB。该树会使用旋转保持平衡，即便输入是退化的。</p>
<p>树的结构使得它能有效地执行ray cast和region query。一般我们不会直接使用该树。</p>
<p>同样，使用动态树进行pair management，可以对碰撞进行broad-phase检测。broad-phase一般也不会直接使用。</p>
<h2 id="2-Dynamics模块"><a href="#2-Dynamics模块" class="headerlink" title="2. Dynamics模块"></a>2. Dynamics模块</h2><p>包含fixture, rigid body, contact, joint, world, listener等多个类，之间依赖复杂。</p>
<h3 id="2-1-Bodies"><a href="#2-1-Bodies" class="headerlink" title="2.1 Bodies"></a>2.1 Bodies</h3><ul>
<li><p>Bodies有位置和速度；</p>
</li>
<li><p>可以在其上施加力-foce、力矩-torque、冲量-impulse；</p>
</li>
<li><p>可以是static, kinematic, dynamic。</p>
</li>
</ul>
<blockquote>
<p>Dynamic: 具有全套属性（有限质量、阻力），受重力和作用力的影响，可以和其他每个刚体碰撞，性能成本高、最具互动性。</p>
<p>Kinematic: 仅在明确的用户控制下移动（手动移动/速度），只能与Dynamic碰撞，不受重力和作用力的影响，成本低。碰撞下同样不动（无限质量：mass = inverse mass = 0）。</p>
<p>Static: 不动（具有无限质量）（除非用户手动移动），只能与Dynamic碰撞。</p>
</blockquote>
<ul>
<li><strong>Bodies carry fixtures.</strong> 在LiquidFun中一定是刚体（一个Body上的两个fixture不会发生相对运动，不会碰撞）。</li>
<li>body从fixture处获得质量属性（可以override）。</li>
<li>一般会对创建的body保存其指针，以便于查询和析构。</li>
</ul>
<h4 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h4><p>通过 b2BodyDef（可循环使用） 定义一个body。</p>
<p>body有两个点比较重要：</p>
<ul>
<li>原点：fixture和joint都是以原点为参照附着的。</li>
<li>质心：很多内部计算都要使用质心。</li>
</ul>
<blockquote>
<p>frame of reference: 信仰和准则，参照系。</p>
</blockquote>
<p>Shapes are added to a body after construction.</p>
<pre><code class="hljs C++">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">b2BodyDef</span></span>
<span class="hljs-class">&#123;</span>

	<span class="hljs-comment">///enum b2BodyType &#123;</span>
	<span class="hljs-comment">///b2_staticBody = 0, b2_kinematicBody, b2_dynamicBody, b2_bulletBody,&#125;;</span>
    <span class="hljs-comment">/// 最好在创造时就确定，因为之后改变type花费巨大</span>
	<span class="hljs-comment">/// Note: if a dynamic body would have zero mass, the mass is set to one.</span>
	b2BodyType type;

	<span class="hljs-comment">/// The world position of body's 原点. </span>
    <span class="hljs-comment">///不要把body放在world的原点然后再移动！这会导致时间成本提高</span>
	b2Vec2 <span class="hljs-built_in">position</span>;

	<span class="hljs-comment">/// The world angle of the body in radians.</span>
	float32 angle;

	<span class="hljs-comment">/// The 线速度 of the body's origin in world co-ordinates.</span>
	b2Vec2 linearVelocity;

	<span class="hljs-comment">/// The 角速度 of the body.</span>
	float32 angularVelocity;</code></pre>

<p><strong>Damping – 阻尼</strong></p>
<ul>
<li>Damping与friction不同，friction仅在有接触时出现</li>
<li>damping系数应当&gt;0=no damping &amp;&amp; &lt;infinity=full damping</li>
<li>通常damping系数 0-0.1</li>
<li>linear damping会让body看着像飘起来<pre><code class="hljs C++"><span class="hljs-comment">///线性damping是用于降低线速度，阻尼系数可以&gt;1,但系数较大时效果对time step较为敏感</span>
float32 linearDamping;

<span class="hljs-comment">/// 角度damping是用于降低角速度，阻尼系数可以&gt;1,但系数较大时效果对time step较为敏感</span>
float32 angularDamping;</code></pre>

</li>
</ul>
<p><strong>Sleep</strong>: </p>
<p>将body送入sleep状态意味着停止模拟它，降低成本。</p>
<p>当：</p>
<ul>
<li>一个醒来的body和睡着的body碰撞时</li>
<li>body上附着的joint/contact被消灭时</li>
<li>人工唤醒时</li>
</ul>
<p>睡着的body会醒来。</p>
<pre><code class="hljs angelscript"><span class="hljs-comment">/// 允许睡觉吗？</span>
<span class="hljs-built_in">bool</span> allowSleep;

<span class="hljs-comment">/// 最初睡着/醒着？</span>
<span class="hljs-built_in">bool</span> awake;</code></pre>
<p><strong>Fixed Rotation</strong>：</p>
<p>对于人物角色，你可能希望通过设置使其不能旋转。</p>
<p>若将fixedRotation设为true，则转动惯量和其逆都将被设为0。</p>
<pre><code class="hljs angelscript"><span class="hljs-comment">/// 能转喵？</span>
<span class="hljs-built_in">bool</span> fixedRotation;</code></pre>
<p><strong>Bullets</strong></p>
<p>游戏中常常需要生成一系列以一定帧率播放的图片，这也就是所谓的离散模拟。这种模拟中，刚体可能在一个time step里进行了大量移动，这可能会导致tunneling。</p>
<p>LiquidFun使用CCD来防止tunneling，也即：</p>
<ul>
<li>将物体从旧位置移动至新位置，寻找过程中的碰撞；</li>
<li>计算碰撞的TOI；</li>
<li>将物体移动到第一次TOI，然后剩余时间悬停；</li>
</ul>
<p>一般来说在dynamic bodies之间不会使用CCD（降低成本），但你可能需要这样的操作（子弹穿过dynamic的砖）。</p>
<p>在LiquidFun中，你可以将高速运动的物体设置为bullets，这样他们就会与static, dynamic的物体都运行CCD。</p>
<p>注：static/kinematic bodies不会发生tunneling。</p>
<pre><code class="hljs angelscript"><span class="hljs-comment">/// 高速且dynamic且要防止tunneling吗？</span>
<span class="hljs-comment">/// 少更改（很耗时）。</span>
<span class="hljs-built_in">bool</span> bullet;</code></pre>
<p><strong>Activation</strong></p>
<p>创造一个物体，但它不参与碰撞/运动。</p>
<p>与sleeping类似，但不会被碰撞唤醒，它的fixture不会参与broad-phase检测。</p>
<p>不参与碰撞、ray cast等。</p>
<p>joint可以附着在未被激活的物体上，这些joint不会参与模拟。</p>
<p>激活一个joint没有变形的物体要小心（？）。</p>
<pre><code class="hljs angelscript"><span class="hljs-comment">/// 激活了吗？</span>
<span class="hljs-built_in">bool</span> active;</code></pre>
<p><strong>用户数据</strong></p>
<p>一个空指针，用于链接用户自己的特殊设置。</p>
<p>应当对所有用户数据使用<strong>同样的一类对象</strong>。</p>
<pre><code class="hljs sql">/// <span class="hljs-keyword">Use</span> this <span class="hljs-keyword">to</span> <span class="hljs-keyword">store</span> application specific <span class="hljs-keyword">body</span> data.
<span class="hljs-built_in">void</span>* userData;</code></pre>
<p><strong>Gravity Scale</strong></p>
<p>用于单独调整某个物体受到的重力。增加重力可能影响稳定性。</p>
<pre><code class="hljs angelscript">    <span class="hljs-comment">/// Scale the gravity applied to this body.</span>
    <span class="hljs-built_in">float</span>32 gravityScale;
&#125;;</code></pre>



<h4 id="2-1-2-Body-Factory"><a href="#2-1-2-Body-Factory" class="headerlink" title="2.1.2 Body Factory"></a>2.1.2 Body Factory</h4><p>我们使用world类提供的body factory生成和析构一个物体。</p>
<pre><code class="hljs c++">b2Body* dynamicBody = myWorld-&gt;CreateBody(&amp;bodyDef);
<span class="hljs-comment">/// DO SOMETHING</span>
myWorld-&gt;DestroyBody(dynamicBody);
dynamicBody = <span class="hljs-literal">NULL</span>;</code></pre>



<h4 id="2-1-3-一些其他的注意事项"><a href="#2-1-3-一些其他的注意事项" class="headerlink" title="2.1.3 一些其他的注意事项"></a>2.1.3 一些其他的注意事项</h4><p>（1）手动移动static bodies：</p>
<ul>
<li><p>要注意不要压扁两个/多个static bodies之间的dynamic bodies。</p>
</li>
<li><p>Friction不能正常工作；</p>
</li>
<li><p>将多个shape绑定到一个静态物体上要比创造多个静态物体，每个绑定一个shape要快。</p>
</li>
<li><p>静态物体的质量和其逆都是0。</p>
</li>
</ul>
<p>（2）删除Bodies:</p>
<ul>
<li>LiquidFun allows you to avoid destroying bodies by deleting your b2World object, which does all the cleanup work for you. However, you should be mindful to nullify body pointers that you keep in your game engine. (？)</li>
<li>删除Body时其上附着的fixture和joint也会被自动删除。</li>
</ul>
<h4 id="2-1-4-使用bodies"><a href="#2-1-4-使用bodies" class="headerlink" title="2.1.4 使用bodies"></a>2.1.4 使用bodies</h4><p>（一）<strong>质量数据</strong></p>
<p>物体都具有：</p>
<ul>
<li>质量（标量）</li>
<li>质心（2维向量）</li>
<li>转动惯量（标量）</li>
</ul>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5C%E8%B4%A8%E9%87%8F%E6%95%B0%E6%8D%AE.png" srcset="/img/loading.gif" alt="image-20200710112021317"></p>
<p>静态物体的质量=转动惯量=0；当一个物体被设置为不能转动时，转动惯量也为0。</p>
<p>一般来说，物体的质量性质在其上添加fixture时自动生成，当然也可以在运行时使用以下命令改变。</p>
<p><code>void SetMassData(const b2MassData* data)；</code></p>
<p>如此暴力改变后，你可以通过如下命令将其恢复为由fixtures决定的自然质量：</p>
<p><code>void ResetMassData();</code></p>
<p>可以通过一系列<code>GetXxxx() const</code>的函数获得质量数据。</p>
<p>（二）<strong>状态数据</strong></p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetType</span><span class="hljs-params">(b2BodyType type)</span></span>;
<span class="hljs-function">b2BodyType <span class="hljs-title">GetType</span><span class="hljs-params">()</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetBullet</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> flag)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsBullet</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetSleepingAllowed</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> flag)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsSleepingAllowed</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetAwake</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> flag)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsAwake</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetActive</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> flag)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsActive</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetFixedRotation</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> flag)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsFixedRotation</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;</code></pre>

<p>（三）<strong>位置和速度</strong></p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SetTransform</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-built_in">position</span>, float32 angle)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">const</span> b2Transform&amp; <span class="hljs-title">GetTransform</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;

<span class="hljs-function"><span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-title">GetPosition</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
<span class="hljs-function">float32 <span class="hljs-title">GetAngle</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;</code></pre>

<pre><code class="hljs C++"><span class="hljs-comment">//质心位置</span>
<span class="hljs-function"><span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-title">GetWorldCenter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">//in world coordinates</span>
<span class="hljs-function"><span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-title">GetLocalCenter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">//in local coordinates</span></code></pre>

<p>获取到的线速度是针对于质心的。</p>
<h3 id="2-2-Fixtures"><a href="#2-2-Fixtures" class="headerlink" title="2.2 Fixtures"></a>2.2 Fixtures</h3><p>形状是可以独立于物体存在的。b2Fixture类就专门负责将形状连接到物体上。</p>
<p>一个物体可以有0/多个fixtures，有多个fixtures的物体被称为复合物体。</p>
<p>fixtures包含以下组件：</p>
<ul>
<li>1*shape</li>
<li>broad-phase检测的代理</li>
<li>密度，friction（摩擦），restitution（恢复系数）</li>
<li>collision filtering flags（？）</li>
<li>指向parent body的指针</li>
<li>用户数据</li>
<li>sensor flag</li>
</ul>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cfixture.png" srcset="/img/loading.gif" alt="image-20200710130809558"></p>
<h4 id="2-2-1-创建fixture"><a href="#2-2-1-创建fixture" class="headerlink" title="2.2.1  创建fixture"></a>2.2.1  创建fixture</h4><p>使用如下命令创建fixture：</p>
<p><code>b2Fixture* myFixture = myBody-&gt;CreateFixture(&amp;fixtureDef);</code></p>
<p>不需要保存fixture的指针，因为parent body被析构时会将其上附着的fixture顺带删除。</p>
<p>可以通过parent body删除其上的fixture（由此可以为能打碎的物体建模）：</p>
<p><code>myBody-&gt;DestroyFixture(myFixture)；</code></p>
<h4 id="2-2-2-密度"><a href="#2-2-2-密度" class="headerlink" title="2.2.2  密度"></a>2.2.2  密度</h4><p>fixture的密度是用于计算parent body的质量数据的。<strong>密度可以为0/正数。</strong></p>
<p><strong>最好对所有的fixtures都使用相似的密度，能提高效率。</strong></p>
<p>改变密度时，body的质量<strong>并不会自动变化，必须调用下列命令</strong>：</p>
<p><code>body-&gt;ResetMassData();</code></p>
<h4 id="2-2-3-摩擦"><a href="#2-2-3-摩擦" class="headerlink" title="2.2.3  摩擦"></a>2.2.3  摩擦</h4><ul>
<li><p>LiquidFun支持静摩擦和动摩擦，但两者系数相同。</p>
</li>
<li><p>LiquidFun使用库仑摩擦力（即摩擦力与法向力成正比）。</p>
</li>
<li><p>摩擦系数通常介于0-1之间，但可以是任何非负值。</p>
</li>
<li><p>两个物体摩擦时，采用的摩擦系数为：sqrtf( a-&gt;friction * b-&gt;friction )</p>
</li>
<li><p>上述默认的混合摩擦系数算法可以通过<code>b2Contact::SetFriction</code>改变，这是在<code>b2ContactListener callback</code>里完成的。</p>
</li>
</ul>
<h4 id="2-2-4-恢复系数"><a href="#2-2-4-恢复系数" class="headerlink" title="2.2.4  恢复系数"></a>2.2.4  恢复系数</h4><ul>
<li>用于让物体弹起来！</li>
<li>通常设置在0-1之间：0-不弹，1-刚好弹回到原位；</li>
<li>采用<code>b2Max( a-&gt;restitution, b-&gt;restitution )</code>进行混合（这样弹力球就可以在完全不弹的桌面上弹来弹去了）</li>
<li>可以使用<code>b2Contact::SetRestitution</code>改变，是在…里完成的。</li>
<li>当一个shape有多个contact时，回弹是近似模拟的。</li>
<li>碰撞速度很小时，LiquidFun会使用非弹性碰撞防止jitter。</li>
</ul>
<h4 id="2-2-5-Filtering"><a href="#2-2-5-Filtering" class="headerlink" title="2.2.5  Filtering"></a>2.2.5  Filtering</h4><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cfilter.png" srcset="/img/loading.gif" alt="image-20200710131000291"></p>
<ul>
<li>Filtering用于阻止特定fixture之间发生碰撞；</li>
<li>LiquidFun支持16个碰撞类（<strong>categories</strong>），对每个fixture你可以规定它属于哪个类，可以与哪些类碰撞。这是通过<strong>位屏蔽</strong>操作的</li>
</ul>
<blockquote>
<p>&amp;1 不变； &amp;0 变0。    |1 变1； |0 不变；</p>
<p>置位：变为1        复位：变为0</p>
<p><strong>位屏蔽</strong>：</p>
<p>屏蔽字中与要检查的位对应的位全部为1，而被屏蔽的位全部为0。</p>
<p>为了检查一个字节中的某些位，可以让这个字节和屏蔽字(bit mask)进行按位与操作(C的按位与运算符为＆)。</p>
<p>为了置位所需的位，可以让数据和屏蔽字进行按位或操作(C的按位或运算符为|)。</p>
<p>为了清除所需的位，可以让数据和对屏蔽字按位取反所得的值进行按位与操作。</p>
</blockquote>
<p>碰撞出现的法则如下：</p>
<pre><code class="hljs C++"><span class="hljs-comment">//如果A被B屏蔽后还有其他位 且 B被A屏蔽后还有其他位</span>
<span class="hljs-keyword">if</span> ((catA &amp; maskB) != <span class="hljs-number">0</span> &amp;&amp; (catB &amp; maskA) != <span class="hljs-number">0</span>)
&#123;
    <span class="hljs-comment">// fixtures can collide</span>
&#125;</code></pre>

<ul>
<li><p>LiquidFun还支持碰撞组（<strong>group</strong>）：正数index的同组物品总会碰撞，复数index的同组物品总不会碰撞。不同组之间也是通过category和mask bits来判断是否碰撞的（换而言之，group比category优先级更高）。</p>
</li>
<li><p>还有一些其他的filtering会出现：</p>
<ul>
<li>静态/kinematic物体上的fixture只能与dynamic物体碰撞；</li>
<li>同一物体上的fixture不碰撞；</li>
<li>你可以启用/禁用通过joint连接的物体之上fixture的碰撞。</li>
</ul>
</li>
<li><p>若要在fixture创造后改变collision filtering , 你可以通过<code>b2Fixture::GetFilterData</code>和<code>b2Fixture::SetFilterData</code>来获取和设置b2Filter的结构。这直到下一个time step之前都不会增/减contacts。</p>
</li>
</ul>
<h4 id="2-2-6-Sensors"><a href="#2-2-6-Sensors" class="headerlink" title="2.2.6  Sensors"></a>2.2.6  Sensors</h4><p>什么时候两个fixtures重叠但不发生碰撞呢？这是由sensors决定的。</p>
<p>sensors是一种专门用于检测碰撞、但不触发碰撞反应的fixture。</p>
<p>你可以把任一个fixture设置为sensor，可以是static/kinematic/dynamic。</p>
<p>记住，一个body可以有多个fixture，这可以任何solid fixture和sensor的混合。</p>
<p>sensor仅当至少一个body是动态的时候才会形成contact。</p>
<p>sensor不会生成接触点。</p>
<p>可以通过以下两种方式得知sensor的状态：</p>
<p><code>b2Contact::IsTouching</code></p>
<p><code>b2ContactListener::BeginContact and EndContact</code></p>
<h3 id="2-3-Joints"><a href="#2-3-Joints" class="headerlink" title="2.3. Joints"></a>2.3. Joints</h3><p>Joints是用来约束bodies在世界中的状态/约束bodies之间的关系的，在游戏世界中比较典型的有Ragdolls(布娃娃)、teeter(跷跷板)、pulley(滑轮)。Joints可以以很多方式连接，形成有趣的动画。</p>
<p>有些Joints提供limits，使得运动受限。</p>
<p>有些Joints提供motors，可以控制joint运动的速度，直到施加的力/力矩超过预先设置的限度；可以控制位置（通过调整速度使其运动）；可以模拟joint friction：将joint的速度设为0，提供一个较小、但能起决定作用的力/力矩，则motor会试图阻止joint运动，直到负载过重。</p>
<h4 id="2-3-1-Joint的定义"><a href="#2-3-1-Joint的定义" class="headerlink" title="2.3.1  Joint的定义"></a>2.3.1  Joint的定义</h4><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cjointdef.png" srcset="/img/loading.gif" alt="image-20200710154221125"></p>
<ul>
<li>Joint是通过b2JointDef这个类<strong>及其衍生</strong>（见上）定义的；</li>
<li>joint连接了两个不同的物体，其中一个可以是静态的。在static, kinematic物体之间的joint是合法的，但没有效果且会占用运行时间；</li>
<li>你可以为任一类关节指明用户数据，也可以提供flag允许相连的物体之间碰撞（默认情况下阻止）。</li>
<li>大多jointdef都需要提供几何数据。通常joint是由anchor point（锚点：在相连物体中固定的点）的局部坐标定义的（因此，即使现在的物体变化违背了joint的限制，也同样可以定义/指明joint，这在游戏reload的时候是常见的）。</li>
<li>有些jointdef还需要知道两个物体之间的默认相对夹角。</li>
<li>大多数joint都有使用当前物体变化定义joint的初始化函数（因为提供几何数据非常麻烦），但这些函数只应被用于制作原型。</li>
</ul>
<h4 id="2-3-2-Joint-Factory"><a href="#2-3-2-Joint-Factory" class="headerlink" title="2.3.2  Joint Factory"></a>2.3.2  Joint Factory</h4><p>使用world类中提供的factory来生产关节：</p>
<pre><code class="hljs C++"><span class="hljs-comment">//Example: RevoluteJoint</span>
b2RevoluteJointDef jointDef;
jointDef.bodyA/B = myBodyA/B;
jointDef.anchorPoint = myBodyA-&gt;GetCenterPosition();

b2RevoluteJoint* joint = (b2RevoluteJoint*)myWorld-&gt;CreateJoint(&amp;jointDef);

<span class="hljs-comment">//DO SOMETHING</span>

myWorld-&gt;DestroyJoint(joint);
joint = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//防止太nasty的崩溃</span></code></pre>

<p><strong>重要：但凡关节连接的一个物体被摧毁，joint也会被摧毁！</strong></p>
<h4 id="2-3-3-使用Joints"><a href="#2-3-3-使用Joints" class="headerlink" title="2.3.3. 使用Joints"></a>2.3.3. 使用Joints</h4><p>许多模拟创造了关节后，在摧毁前就不会再调用它们。当然，在关节中有许多有用的数据可以帮你让模拟变得更加生动。</p>
<p>首先，你可以获取物体、锚点、用户数据：</p>
<pre><code class="hljs C++"><span class="hljs-function">b2Body* <span class="hljs-title">GetBodyA</span><span class="hljs-params">()</span></span>;
<span class="hljs-function">b2Body* <span class="hljs-title">GetBodyB</span><span class="hljs-params">()</span></span>;

<span class="hljs-function">b2Vec2 <span class="hljs-title">GetAnchorA</span><span class="hljs-params">()</span></span>;
<span class="hljs-function">b2Vec2 <span class="hljs-title">GetAnchorB</span><span class="hljs-params">()</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">GetUserData</span><span class="hljs-params">()</span></span>;</code></pre>

<p>所有关节都有reaction力/力矩，也即在锚点处被施加向body 2的力（见Distance Joint中的图）。可以使用反应力破坏关节，或触发其它游戏事件。</p>
<p>但这两个函数挺慢的，不要随便调用：</p>
<pre><code class="hljs C++"><span class="hljs-function">b2Vec2 <span class="hljs-title">GetReactionForce</span><span class="hljs-params">()</span></span>;
<span class="hljs-function">float32 <span class="hljs-title">GetReactionTorque</span><span class="hljs-params">()</span></span>;</code></pre>

<p>接下来介绍各种奇形怪状的joint。</p>
<h5 id="2-3-3-1-Distance-Joint"><a href="#2-3-3-1-Distance-Joint" class="headerlink" title="2.3.3.1  Distance Joint"></a>2.3.3.1  Distance Joint</h5><p>最简单的joint，保持两个物体上各一点之间的距离恒定（应该在两个物体已经就位的情况下定义，指定两个锚点的世界坐标）。</p>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Creaction.png" srcset="/img/loading.gif" alt="image-20200710160614198"></p>
<pre><code class="hljs C++">b2DistanceJointDef jointDef;
jointDef.Initialize(BodyA, BodyB, worldAnchorA, worldAnchorB);
jointDef.collideConnected = <span class="hljs-literal">true</span>;</code></pre>

<p>Distance Joint也可以被做成柔性连接，就像弹簧阻尼那样。方法是调整定义中的两个常量：frequency和damping ratio。</p>
<p>frequency就像吉他弦的振动频率一样，以赫兹为单位，一般来说它是time step的频率的一半。（与Nyquist frequency有关，不查了/kkl）。</p>
<p>damping ratio是无量纲的，通常介于0-1之间，但可以更大。在此例中，damping是关键的（所有震动都应该消失）。</p>
<h5 id="2-3-3-2-Revolute-Joint-旋转关节"><a href="#2-3-3-2-Revolute-Joint-旋转关节" class="headerlink" title="2.3.3.2. Revolute Joint(旋转关节)"></a>2.3.3.2. Revolute Joint(旋转关节)</h5><p>旋转关节强迫两个物体共享一个锚点，通常被叫做hinge point（铰点）。旋转关节只有一个自由度：两个物体之间的相对旋转角度，也即joint angle。<strong>物体B绕锚点逆时针绕时角度为正，用弧度计算，初始化时角度默认为0。</strong></p>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Crevolute.png" srcset="/img/loading.gif" alt="image-20200710162449344"></p>
<p>关节的初始化函数假设两个物体已经就位，如下例：</p>
<pre><code class="hljs C++">b2RevoluteJointDef jointDef;
jointDef.Initialize(myBodyA, myBodyB, myBodyA-&gt;GetWorldCenter());</code></pre>

<p>你可以通过limit和motor来控制关节。</p>
<p>limit可以使得旋转角度落在一定区间内。一般来说，这个区间应当包括0，否则在模拟开始时关节将暴走。</p>
<p>motor可以允许你指定joint的角速度（角度对事件求导），可以为正可以为负。motor可以有无穷的力，但这不是我们所希望的，想想这个问题：</p>
<blockquote>
<p>如果无穷的力遇上了不能动的物体怎么办？（超棒的矛和超棒的盾）</p>
</blockquote>
<p>所以最好给motor提供一个力矩的上限。motor会保持以设定速度运行，除非维持这一状态所需的力矩超出了所设定的最大值，此时关节可能变慢/倒过来转。</p>
<p>你可以使用motor来模拟joint friction。把joint的速度设为0，把力矩上线设的小但别太小。负载超过这个值时关节就会开始运动。（改的例子见Joints这一节）。</p>
<p>通过一系列Get和Set函数获取/改变（每个time step都可以改）关节的角度、速度、力矩。</p>
<p>joint motor有非常有趣的特性，你可以每个time step都改变joint的速度，从而让它像钟摆一样动：</p>
<p><code>myJoint-&gt;SetMotorSpeed(cosf(0.5f * time));</code></p>
<p>也可以使用joint motor来追踪想要的角度：</p>
<pre><code class="hljs C++">float32 angleError = myJoint-&gt;GetJointAngle() - angleTarget;
float32 gain = <span class="hljs-number">0.1f</span>;
myJoint-&gt;SetMotorSpeed(-gain * angleError);
<span class="hljs-comment">//gain别设太大</span></code></pre>

<h5 id="2-3-3-3-Prismatic-Joint-平移关节"><a href="#2-3-3-3-Prismatic-Joint-平移关节" class="headerlink" title="2.3.3.3 Prismatic Joint(平移关节)"></a>2.3.3.3 Prismatic Joint(平移关节)</h5><p>平移关节允许两个物体沿着某个轴发生相对滑动，不允许发生相对转动。因此它也只有一个自由度。</p>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cprismatic.png" srcset="/img/loading.gif" alt="image-20200710165307318"></p>
<p>平移关节的定义和旋转关节很相似，只需要把角度换成平移、力矩换成力即可。由此可以得到平移关节带limit, motor的一个定义：</p>
<pre><code class="hljs C++">b2PrismaticJointDef jointDef;
<span class="hljs-function">b2Vec2 <span class="hljs-title">worldAxis</span><span class="hljs-params">(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>)</span></span>;
jointDef.Initialize(BodyA, BodyB, BodyA-&gt;GetWorldCenter(), worldAxis);

jointDef.lower/upperTranslation = <span class="hljs-number">-5.0f</span>/<span class="hljs-number">2.5f</span>;
jointDef.enableLimit = <span class="hljs-literal">true</span>;

jointDef.maxMotorForce = <span class="hljs-number">1.0f</span>;
jointDef.motorSpeed = <span class="hljs-number">0.0f</span>;
jointDef.enableMotor = <span class="hljs-literal">true</span>;</code></pre>

<p>旋转关节有一个未被指明的轴朝向屏幕外。平移关节则需要指明一个在屏幕内的轴，轴在两个物体间被固定，且跟随他们运动。</p>
<p>默认初始化时，平移为0，所以平移range应当包含0。</p>
<p>一样，有一系列Get和Set。</p>
<h5 id="2-3-3-4-Pulley-Joint-滑轮关节"><a href="#2-3-3-4-Pulley-Joint-滑轮关节" class="headerlink" title="2.3.3.4 Pulley Joint(滑轮关节)"></a>2.3.3.4 Pulley Joint(滑轮关节)</h5><p>滑轮关节可以创造一个理想化的滑轮，将两个物体与地面连接/互相连接。一个物体上升时另一个下降，滑轮绳的长度在一开始就配置好了。</p>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cpulley.png" srcset="/img/loading.gif" alt="image-20200710173334581"></p>
<p><code>length1 + length2 = constant</code></p>
<p>也可以通过加一个比率来模拟滑轮组（<strong>高中物理，出现力</strong>），这会导致一边的绳比另一边延展的快，约束力在一遍比另一边小，可以用来创造<strong>杠杆</strong>。</p>
<p><code>length1 + ratio * length2 = constant</code></p>
<p>例：ratio = 2时，length1的变化速度是length2的两倍，绳1的拉力是绳2的1/2。</p>
<p>如果一边绳子拉没了，滑轮可能会出问题。最好防止一下。</p>
<p>它的定义如下：</p>
<pre><code class="hljs C++">b2Vec2 anchor1/<span class="hljs-number">2</span> = myBody1/<span class="hljs-number">2</span>-&gt;GetWorldCentor();
b2Vec2 groundAnchor1/<span class="hljs-number">2</span>(x1/x2, y1/y2);
float32 ratio = <span class="hljs-number">1.0f</span>;

b2PulleyJointDef jointDef;
jointDef.Initialize(myBody1, myBody2, groundAnchor1, groundAnchor2, anchor1, anchor2, ratio);</code></pre>

<p>可以用<code>GetLengthA/B() const</code>获取当前的长度。</p>
<h5 id="2-3-3-5-Gear-Joint（齿轮关节）"><a href="#2-3-3-5-Gear-Joint（齿轮关节）" class="headerlink" title="2.3.3.5 Gear Joint（齿轮关节）"></a>2.3.3.5 Gear Joint（齿轮关节）</h5><p>机械游戏当然需要齿轮啦！在LiquidFun里你可以使用复合形状来制作齿轮齿的模型，这有点慢且有点麻烦。你在排齿轮齿的时候也得小心，才能使得齿轮平滑地转动。</p>
<p>用齿轮关节制作齿轮就比较简单了。</p>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cgear.png" srcset="/img/loading.gif" alt="image-20200710174517774"></p>
<p>齿轮关节只能连接旋转 and/or 平移关节。</p>
<p>你可以定义一个齿轮ratio，可以是负数。还要注意：当一个是旋转一个是平移关节的时候，需要提供一个角度到长度（或者反过来）的单位转化。</p>
<p><code>coordinate1 + ratio * coordinate2 == constant</code></p>
<p>下面是一锅厘子：（bodyA/B是两个关节提供的任一个物体，不相同即可）：</p>
<pre><code class="hljs C++">b2GearJointDef jointDef;
jointDef.bodyA/B = myBodyA/B;
jointDef.joint1/<span class="hljs-number">2</span> = myRevolute/PrismaticJoint;
jointDef.ratio = <span class="hljs-number">2.0f</span> * b2_pi / myLength;</code></pre>

<p>注意到齿轮是依赖于之前那两个关节的，因此：</p>
<p><strong>总是先删除齿轮，再删除其依赖的关节/物体。否则出事。</strong></p>
<h5 id="2-3-3-6-Mouse-Joint-鼠标关节"><a href="#2-3-3-6-Mouse-Joint-鼠标关节" class="headerlink" title="2.3.3.6  Mouse Joint(鼠标关节)"></a>2.3.3.6  Mouse Joint(鼠标关节)</h5><p>鼠标关节在testbed中被用于鼠标操控物体，它试图驱动物体上一点向光标的当前位置移动，并未对旋转做出限制。</p>
<p>mouse joint的定义中有一个目标点、力的上限、频率、阻尼ratio。</p>
<p>目标点最初与物体的锚点重合。</p>
<p>最大力是用于防止动态物体碰撞时产生触发过于激烈的反应，设置成多大都没关系。</p>
<p>频率、阻尼ratio是用于创造弹簧/阻尼的效果的，与distance joint中的情况一样。</p>
<p>用户常常希望将鼠标关节改造后用在游戏里，做到精准的位置放置和立刻的反应，但鼠标关节在这方面性能并不好。<strong>你可能需要考虑使用kinematic bodies</strong>。</p>
<h5 id="2-3-3-7-Wheel-Joint-轮子关节"><a href="#2-3-3-7-Wheel-Joint-轮子关节" class="headerlink" title="2.3.3.7  Wheel Joint(轮子关节)"></a>2.3.3.7  Wheel Joint(轮子关节)</h5><p>轮子关节使得bodyB上的一点与bodyA上的一条线联系起来，并且提供了一个悬挂弹簧绳。</p>
<p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cwheel.png" srcset="/img/loading.gif" alt="image-20200711110933763"></p>
<h5 id="2-3-3-8-Weld-Joint（焊接关节）"><a href="#2-3-3-8-Weld-Joint（焊接关节）" class="headerlink" title="2.3.3.8  Weld Joint（焊接关节）"></a>2.3.3.8  Weld Joint（焊接关节）</h5><p>weld joint限制了两个物体之间的所有相对运动。可以看testbed里面的Cantilever.h（悬臂）了解相关信息。</p>
<p>你也许会想用weld joint来定义能打破的结构，但在LiquidFun的实现下关节比较柔软，所以通过weld joints连接的chain of bodies可能会屈伸（flex）。</p>
<p>事实上，创造能打破的物体时，不如从一个物体开始，往上附着多个fixtures。在物体破坏时，你可以把fixture摧毁然后在另一个物体上重建这个fixture。具体可以看testbed里面的breakable example。</p>
<h5 id="2-3-3-9-Rope-Joint（绳子关节）"><a href="#2-3-3-9-Rope-Joint（绳子关节）" class="headerlink" title="2.3.3.9  Rope Joint（绳子关节）"></a>2.3.3.9  Rope Joint（绳子关节）</h5><p>Rope Joint限制了两个点之间的最大距离，这可以有效地防止chain of bodies在过高的负载下延伸，详见b2RopeJoint.h + RopeJoint.h。</p>
<h5 id="2-3-3-10-Friction-Joint（摩擦关节）"><a href="#2-3-3-10-Friction-Joint（摩擦关节）" class="headerlink" title="2.3.3.10  Friction Joint（摩擦关节）"></a>2.3.3.10  Friction Joint（摩擦关节）</h5><p>Friction Joint是用于自顶向下的摩擦的，提供了2维的平移摩擦和角摩擦，详见b2FrictionJoint.h + ApplyForce.h。</p>
<h3 id="2-4-Contacts"><a href="#2-4-Contacts" class="headerlink" title="2.4  Contacts"></a>2.4  Contacts</h3><p>Contacts是用于管理两个fixtures之间的碰撞的。如果fixture有子对象（例如chain shape），则对每个相关的孩子都会存在一个contact。</p>
<p>contact有多种种类，都是b2Contact类的衍生类，用于管理不同种类fixtures之间的contact，比如有应付多边形-多边形碰撞的，也有应付圆-圆碰撞的。</p>
<p>先来看几个术语。</p>
<h4 id="2-4-1-Terminology"><a href="#2-4-1-Terminology" class="headerlink" title="2.4.1. Terminology"></a>2.4.1. Terminology</h4><p><strong>Contact Point</strong>: 两个shapes接触的点。LiquidFun通过几个点来模拟contact。</p>
<p><strong>Contact Normal</strong>：一个单位向量，常规情况下从fixtureA指向fixtureB。</p>
<p><strong>Contact Separation</strong>：这是penetration的反面。当形状重合时separation是negative的，有可能未来版本会出现带positive separation的接触点，所以出现接触点的时候最好检查下符号。（<strong>啥？</strong>）</p>
<p><strong>Contact Manifold</strong>：<del>（流形，出现力）</del>在两个凸多边形之间接触时可能会有两个接触点，它们共用同一个法向量，所以被组合在一个流形（=一个近似接触区域）里。</p>
<p><strong>Normal Impulse</strong>：normal force（我猜是法向力）是在接触点处防止形状互相穿透的力。为了便利，LiquidFun使用冲量。<code>法向冲量 = 法向力 * time_step</code>。</p>
<p><strong>Tangent Impulse</strong>：切向力在接触点产生的（与摩擦有关）冲量。</p>
<p><strong>Contact Ids</strong>：</p>
<p>LiquidFun试图循环使用一个time step产生的接触力结果，作为下一个time step的初始猜测值。LiquidFun使用contact id在time step之间匹配接触点。这些id包含了几何特征的指标，以区分各个接触点。</p>
<p>contact在两个fixture的AABB重合的时候创建。有些时候collision filtering会阻止contact的创造。AABB停止重合的时候contact会被摧毁。</p>
<p>所以你可能会注意到，有些时候两个fixture不接触的时候contact也会被创造。这就是“鸡生蛋”的问题。如果contact对象不创建，我们就无法通过contact来分析碰撞，从而真正知道contact对象到底是不是需要被创建的。如果形状没接触，我们可以立刻把contact删掉，但也可以干脆等到AABB不重合了。LiquidFun决定采用后一种方式，效率更高。</p>
<h4 id="2-4-2-Contact类"><a href="#2-4-2-Contact类" class="headerlink" title="2.4.2  Contact类"></a>2.4.2  Contact类</h4><p>之前已经说过，contact类是由LiquidFun创造和消灭的，Contact对象并不由用户创造。当然，你可以获取其中信息并与其互动。</p>
<p>你可以访问raw contact manifold：</p>
<pre><code class="hljs C++"><span class="hljs-function">b2Manifold* <span class="hljs-title">GetManifold</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">const</span> b2Manifold* <span class="hljs-title">GetManifold</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;</code></pre>

<p>理论上你可以修改manifold，但不资瓷，除非需要进阶用法。</p>
<p>还有一个helper function来访问b2WorldManifold：</p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetWorldManifold</span><span class="hljs-params">(b2WorldManifold* worldManifold)</span> <span class="hljs-keyword">const</span></span>;</code></pre>

<p>它使用了物体的当前位置来计算接触点的世界坐标。</p>
<p>Sensors（不碰撞的fixture）不会创造manifold，所以你可以这样使用：（对于non-sensor也可以啦）</p>
<pre><code class="hljs C++"><span class="hljs-keyword">bool</span> touching = sensorContact-&gt;IsTouching();</code></pre>

<p>可以从contact那里获知fixture，进一步获知body的信息：</p>
<pre><code class="hljs C++">b2Fixture* fixtureA = myContact-&gt;GetFixtureA();
b2Body* bodyA = fixture-&gt;GetBody();
MyActor* actorA = (MyActor*)bodyA-&gt;GetUserData();</code></pre>

<p>你也可以禁用contact，这只在b2ContactListener::PreSolve里面有用，见下文。</p>
<h4 id="2-4-3-获取Contact"><a href="#2-4-3-获取Contact" class="headerlink" title="2.4.3  获取Contact"></a>2.4.3  获取Contact</h4><p>可以用几种方式获取contact。</p>
<p>（1）可以通过world/body的结构直接访问；</p>
<ul>
<li><p>可以遍历world里面所有的contact：</p>
<pre><code class="hljs C++"><span class="hljs-keyword">for</span> (b2Contact* c = myWorld-&gt;GetContactList(); c; c = c-&gt;GetNext())
&#123;
    <span class="hljs-comment">// process</span>
&#125;</code></pre>
</li>
<li><p>可以遍历一个body上产生的所有contact，他们都通过边连接存在一个图里：</p>
<pre><code class="hljs C++"><span class="hljs-keyword">for</span> (b2ContactEdge* ce = myBody-&gt;GetContactList(); ce; ce = ce-&gt;next)
&#123;
    b2Contact* c = ce-&gt;contact;
    <span class="hljs-comment">//process</span>
&#125;</code></pre>

</li>
</ul>
<p>（2）可以实现一个contact监视器类：见下文</p>
<blockquote>
<p>注：使用world/body遍历可能会漏掉一些在time step中间短暂出现的contact，使用监视器能得到最为准确的结果。</p>
</blockquote>
<h4 id="2-4-4-Contact监视器"><a href="#2-4-4-Contact监视器" class="headerlink" title="2.4.4  Contact监视器"></a>2.4.4  Contact监视器</h4><p>监视器支持几种不同的事件：开始，结束，pre-solve, post-solve。</p>
<pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyContactListener</span> :</span> <span class="hljs-keyword">public</span> b2ContactListener
&#123;
 <span class="hljs-keyword">public</span>:
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BeginContact</span><span class="hljs-params">(b2Contact* contact)</span> </span>&#123;&#125;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EndContact</span><span class="hljs-params">(b2Contact* contact)</span> </span>&#123;&#125;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreSolve</span><span class="hljs-params">(b2Contact* contact, <span class="hljs-keyword">const</span> b2Manifold* oldManifold)</span> </span>&#123;&#125;
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostSolve</span><span class="hljs-params">(b2Contact* contact, <span class="hljs-keyword">const</span> b2Manifold* oldManifold)</span> </span>&#123;&#125;
&#125;;</code></pre>

<blockquote>
<p>注：不要保留送到b2ContactListener的指针的引用。你应该使用深拷贝将接触点的数据拷贝到你自己的buffer里，例子见下文。</p>
</blockquote>
<p>在运行的时候，可以创造listener的一个对象，并且使用b2World::SetContactListener函数登记。确保在world对象的生命期内监视器都是可以访问的。</p>
<p>（1）<strong>开始</strong>：当两个fixture重合的时候调用，sensor和non-sensor都会调用。这类事件只会在time step内部出现。</p>
<p>（2）<strong>结束</strong>：当两个fixture停止重合的时候调用，sensor和non-sensor都会。如果一个body被摧毁的时候也会调用，所以可能在time step之外出现此类事件。</p>
<p>（3）<strong>Pre-Solve</strong>：在碰撞检测结束之后、碰撞解决之前调用。这给了用户根据当前配置禁用contact的机会。例如：你可以使用这个callback实现一个一边封闭的平台（如：只出不进），并且调用b2Contact::SetEnabled(false)。每次在处理碰撞的时候contact都会被重新启用，所以每个time-step都要禁用contact。由于碰撞检测是连续的，pre-solve事件可能会在每个time step每个contact被触发多次。</p>
<pre><code class="hljs C++"><span class="hljs-comment">//一段不太明白的代码</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreSolve</span><span class="hljs-params">(b2Contact* contact, <span class="hljs-keyword">const</span> b2Manifold* oldManifold)</span></span>
<span class="hljs-function"></span>&#123;
    b2WorldManifold worldManifold;
    contact-&gt;GetWorldManifold(&amp;worldManifold);
    
    <span class="hljs-comment">//如果平台过于平了</span>
    <span class="hljs-keyword">if</span> (worldManifold.normal.y &lt; <span class="hljs-number">-0.5f</span>)
    &#123;
        <span class="hljs-comment">//就禁止接触？</span>
        contact-&gt;SetEnabled(<span class="hljs-literal">false</span>);
    &#125;
&#125;</code></pre>

<p>pre-solve事件也可以用来决定point state还有碰撞的来袭速度：</p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreSolve</span><span class="hljs-params">(b2Contact* contact, <span class="hljs-keyword">const</span> b2Manifold* oldManifold)</span></span>
<span class="hljs-function"></span>&#123;
    b2WorldManifold worldManifold;
    contact-&gt;GetWorldManifold(&amp;worldManifold);
    b2PointState state1[<span class="hljs-number">2</span>], state2[<span class="hljs-number">2</span>];
    b2GetPointStates(state1, state2, oldManifold, contact-&gt;GetManifold);
    <span class="hljs-keyword">if</span> (state2[<span class="hljs-number">0</span>] == b2_addState)
    &#123;
        <span class="hljs-keyword">const</span> b2Body* bodyA/B = contact-&gt;GetFixtureA/B()-&gt;GetBody();
        b2Vec2 <span class="hljs-built_in">point</span> = worldManifold.points[<span class="hljs-number">0</span>];
        b2Vec2 vA/B = bodyA/B-&gt;GetLinearVelocityFromWorldPoint(<span class="hljs-built_in">point</span>);
        float32 approachVelocity = b2Dot(vB - vA, worldManifold.normal);
        <span class="hljs-keyword">if</span> (approachVelocity &gt; <span class="hljs-number">1.0f</span>)
        &#123;
            MyPlayCollisionSound();
        &#125;
    &#125;
&#125;</code></pre>

<p>（4）<strong>Post-Solve</strong>：</p>
<p>​    post-solve事件中可以收集碰撞的冲量数据。</p>
<p>​    你可能很想在游戏中基于contact的callback函数改变物理世界情况。例如，你可能想使得某个碰撞触发角色或刚体的受损。但LiquidFun不允许你在callback函数里更改物理世界的情况，因为你摧毁的物体可能正在被LiquidFun处理，这可能导致孤儿指针。</p>
<p>​    建议的处理方法是：把所有的接触数据存下来，然后在time step之后再<strong>立刻</strong>处理。这时候你可以更改物理世界，但仍然要小心不要让接触数据缓冲区里出现孤儿指针。testbed里提供了不产生孤儿指针的安全的contact point处理的例子。</p>
<p>​    下面这段代码展示了处理contact buffer的时候应当怎样处理orphaned bodies。这是一段摘要。所有的接触点都在b2ContactPoint数组m_points里存储。</p>
<pre><code class="hljs C++"><span class="hljs-comment">//接下来通过接触点数据删除一些物体</span>
<span class="hljs-comment">//一定要缓存删除的物体的数据，因为可能会在多个接触点中存在，不保存会删除空指针</span>
<span class="hljs-keyword">const</span> int32 k_maxNuke = <span class="hljs-number">6</span>;
b2Body* nuke[k_maxNuke];
int32 nukeCount = <span class="hljs-number">0</span>;

<span class="hljs-comment">//遍历contact缓冲，将接触物体比自己重的的物体删除</span>
<span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; m_pointCount; ++i)
&#123;
    ContactPoint* <span class="hljs-built_in">point</span> = m_points + i;
    b2Body* bodyA/B = <span class="hljs-built_in">point</span>-&gt;fixtureA/B-&gt;GetBody();
    float32 massA/B = bodyA/B-&gt;GetMass();
    <span class="hljs-keyword">if</span> (massA &gt; <span class="hljs-number">0.0f</span> &amp;&amp; massB &gt; <span class="hljs-number">0.0f</span>)
    &#123;
        <span class="hljs-keyword">if</span> (massB &gt; massA)
        &#123;
            nuke[nukeCount++] = bodyA;
        &#125;
        <span class="hljs-keyword">else</span>
        &#123;
            nuke[nukeCount++] = bodyB;
        &#125;
        <span class="hljs-keyword">if</span> (nukeCount == k_maxNuke)
        &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
    <span class="hljs-comment">//排序，去重</span>
    <span class="hljs-built_in">std</span>::sort(nuke, nuke + nukeCount);
    int32 i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (i &lt; nukeCount)
    &#123;
        b2Body* b = nuke[i++];
        <span class="hljs-keyword">while</span> (i &lt; nukeCount &amp;&amp; nuke[i] == b)
        &#123;
            ++i;
        &#125;
        m_world-&gt;DestroyBody(b);
    &#125;
&#125;</code></pre>

<h4 id="2-4-5-Contact-Filtering"><a href="#2-4-5-Contact-Filtering" class="headerlink" title="2.4.5  Contact Filtering"></a>2.4.5  Contact Filtering</h4><p>这是用来阻止部分物体之间的互动的。（例如，创造一个门，只有特定的角色能穿过）</p>
<p>LiquidFun允许你通过实现b2ContactFilter类来自定义contact filtering。这个类要求你实现一个ShouldCollide函数，接收两个b2Shape指针，返回是否该碰撞。</p>
<p>默认实现使用了之前定义过的b2FilterData。</p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">b2ContactFilter::ShouldCollide</span><span class="hljs-params">(b2Fixture* fixtureA, b2Fixture* fixtureB)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">const</span> b2Filter&amp; filterA/B = fixtureA/B-&gt;GetFilterData();
    <span class="hljs-keyword">if</span> (filterA.groupIndex == filterB.groupIndex &amp;&amp; filterA.groupIndex != <span class="hljs-number">0</span>)
    &#123;
        <span class="hljs-keyword">return</span> filterA.groupIndex &gt; <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-keyword">bool</span> collide = (filterA.maskbits &amp; filterB.categoryBits) != <span class="hljs-number">0</span> &amp;&amp; (filterA.categoryBits &amp; filterB.maskbits) != <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> collide;
&#125;</code></pre>

<p>你可以在运行的时候创造一个你自己的contact filter，然后使用b2World::SetContactFilter来注册。请确保在world生命期内它始终可以访问。</p>
<p><code>world-&gt;SetContactFilter(&amp;filter);</code></p>
<h3 id="2-5-World类"><a href="#2-5-World类" class="headerlink" title="2.5  World类"></a>2.5  World类</h3><p>b2World类包含了物体、关节，负责了模拟的所有部分，允许非共时的请求（AABB/ray cast/etc.）。你绝大部分的互动都是与b2World对象进行的。</p>
<h4 id="2-5-1-创造-消灭一个世界"><a href="#2-5-1-创造-消灭一个世界" class="headerlink" title="2.5.1  创造/消灭一个世界"></a>2.5.1  创造/消灭一个世界</h4><pre><code class="hljs C++"><span class="hljs-comment">//doSleep = 物体能睡觉吗？</span>
b2World* myWorld = <span class="hljs-keyword">new</span> b2World(gravity, doSleep);
<span class="hljs-comment">// do something</span>
<span class="hljs-keyword">delete</span> myWorld;</code></pre>

<h4 id="2-5-2-使用世界"><a href="#2-5-2-使用世界" class="headerlink" title="2.5.2  使用世界"></a>2.5.2  使用世界</h4><p>世界类包含了创造、摧毁物体、关节的工厂。</p>
<h4 id="2-5-3-模拟"><a href="#2-5-3-模拟" class="headerlink" title="2.5.3  模拟"></a>2.5.3  模拟</h4><p>指定time step，指定速度、位置的迭代数目。</p>
<pre><code class="hljs C++">float32 timeStep = <span class="hljs-number">1.0f</span> / <span class="hljs-number">60.f</span>;
int32 velocityIterations = <span class="hljs-number">10</span>;
int32 positionIterations = <span class="hljs-number">8</span>;
myWorld-&gt;Step(timeStep, velocityIterations, positionIterations);</code></pre>

<p>在每个time step之后你都可以检查你的物体、关节，获取信息。一般你都会从物体处获得位置信息，以渲染他们。你可以在你的游戏循环的任意位置启动一个time step，但要注意做事情的顺序。</p>
<p>例如，你应该time step之前创造物体，这样才能获取他们的碰撞数据。</p>
<p>最好使用固定的time step。time step越大，在低帧率的场景里游戏的性能表现就越好。但一般来说，time step不应当超过1/30秒。1/60秒的time step可以使得模拟质量较高。</p>
<p>迭代次数控制了constraint solver将遍历contact和joint多少次。迭代越好，模拟效果肯定更好。但不要将time step变大以增加迭代次数，60Hz + 10次迭代要比 30Hz + 20次迭代效果好得多。</p>
<p>在stepping之后，应该把施加在物体上的力清零。这是通过b2World::ClearForces这个命令完成的。这可以让你在几个sub-step内都使用相同的力场。</p>
<h4 id="2-5-4-探索世界吧！"><a href="#2-5-4-探索世界吧！" class="headerlink" title="2.5.4  探索世界吧！"></a>2.5.4  探索世界吧！</h4><p>世界是由物体、接触、关节组成的。你可以从world这里获取它们的列表并遍历。例如：</p>
<pre><code class="hljs C++"><span class="hljs-comment">//叫醒所有物体</span>
<span class="hljs-keyword">for</span> (b2Body* b = myWorld-&gt;GetBodyList(); b; b = b-&gt;GetNext())
&#123;
    b-&gt;SetAwake(<span class="hljs-literal">true</span>);
&#125;</code></pre>

<h4 id="2-5-5-AABB查询"><a href="#2-5-5-AABB查询" class="headerlink" title="2.5.5.  AABB查询"></a>2.5.5.  AABB查询</h4><p>有些时候你想要查询一个区域内的所有图形。b2World类提供了一个log(N)的使用broad-phase数据结构的函数。你可以提供一个世界坐标下的AABB，并且实现b2QueryCallback。世界会对于每个与你提供的AABB重合的AABB的fixture调用你提供的类。返回true的时候查询继续，返回false的时候查询中止。</p>
<p>例如：如下代码找到所有可能分割了你提供的AABB的fixture，然后把它们相关的物体都唤醒：</p>
<pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueryCallback</span> :</span> <span class="hljs-keyword">public</span> b2QueryCallback
&#123;
  <span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ReportFixture</span><span class="hljs-params">(b2Fixture* fixture)</span></span>
<span class="hljs-function">    </span>&#123;
        b2Body* body = fixture-&gt;GetBody();
        body-&gt;SetAwake(<span class="hljs-literal">true</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;
...
MyQueryCallback callback;
b2AABB aabb;
aabb.lowerBound.Set(<span class="hljs-number">-1.f</span>, <span class="hljs-number">-1.f</span>);
aabb.upperBound.Set(<span class="hljs-number">1.f</span>, <span class="hljs-number">1.f</span>);
myWorld-&gt;Query(&amp;callback, aabb);</code></pre>

<p>不要随意猜测、假设callback的顺序。</p>
<h4 id="2-5-6-Ray-Cast"><a href="#2-5-6-Ray-Cast" class="headerlink" title="2.5.6  Ray Cast"></a>2.5.6  Ray Cast</h4><p>你可以用ray cast进行视线检查、开枪等操作。通过实现一个callback类 + 提供开始和结束点，就可以进行一次ray cast操作。</p>
<p>world类会对每个被光线束击中的fixture调用你所提供的类。你的callback函数能调用的数据是：fixture，分割点，单位法向量，分割下来的沿光线束距离（小数）。不要随意猜测、假设callback的顺序。</p>
<p>你将返回一个小数，来控制ray cast是否继续。返回0意味着ray cast中止，返回1意味着ray cast将假装没有击中的fixture，返回之前传入的小数意味着光线将被截断在当前的分割点。这样，你就可以ray cast一个图形/所有图形/最接近的图形（通过调整返回的分数）。</p>
<p>甚至还可以返回-1，使得光线忽略这一个fixture，假装被击中的这个fixture不存在。</p>
<p>例子如下：</p>
<pre><code class="hljs C++"><span class="hljs-comment">//获取最近的形状</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRayCastCallback</span> :</span> <span class="hljs-keyword">public</span> b2RayCastCallback
&#123;
  <span class="hljs-keyword">public</span>:
    MyRayCastCallback()
    &#123;
        m_fixture = <span class="hljs-literal">NULL</span>;
    &#125;
    <span class="hljs-function">float32 <span class="hljs-title">ReportFixture</span><span class="hljs-params">(b2Fixture* fixture, <span class="hljs-keyword">const</span> b2Vec&amp; <span class="hljs-built_in">point</span>, <span class="hljs-keyword">const</span> b2Vec2&amp; normal, float32 fraction)</span></span>
<span class="hljs-function">    </span>&#123;
        m_fixture = fixture;
        m_point = <span class="hljs-built_in">point</span>;
        m_normal = normal;
        m_fraction = fraction;
        <span class="hljs-keyword">return</span> fraction;
    &#125;
    b2Fixture* m_fixture;
    b2Vec2 m_point;
    b2Vec2 m_normal;
    float32 m_fraction;
&#125;
MyRayCastCallback callback;
<span class="hljs-function">b2Vec2 <span class="hljs-title">point1</span><span class="hljs-params">(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">0.0f</span>)</span></span>;
<span class="hljs-function">b2Vec2 <span class="hljs-title">point2</span><span class="hljs-params">(<span class="hljs-number">3.0f</span>, <span class="hljs-number">1.0f</span>)</span></span>;
myWorld-&gt;RayCast(&amp;callback, point1, point2);</code></pre>

<p>由于近似的原因，ray cast可能会在你的静态环境中从多边形之间的小缝隙之间穿过去。如果这不行，请把你的多边形适当调大。</p>
<h4 id="2-5-7-力和冲量"><a href="#2-5-7-力和冲量" class="headerlink" title="2.5.7  力和冲量"></a>2.5.7  力和冲量</h4><p>你可以在物体上应用力、力矩、冲量。当你应用力/冲量的时候，要提供负载应用的地点的世界坐标。这通常会导致一个质心上的力矩。</p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ApplyForce</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; force, <span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-built_in">point</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ApplyTorque</span><span class="hljs-params">(float32 torque)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ApplyLinearImpulse</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; impulse, <span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-built_in">point</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ApplyAngularImpulse</span><span class="hljs-params">(float32 impulse)</span></span>;</code></pre>

<p>应用力/力矩/冲量都会唤醒物体，有些时候你不想这样（例如，提供一个恒定力，但希望物体睡着提供效率）。这个时候可以这样做：</p>
<pre><code class="hljs C++"><span class="hljs-keyword">if</span> (myBody-&gt;IsAwake() == <span class="hljs-literal">true</span>)
&#123;
    myBody-&gt;ApplyForce(myForce, myPoint);
&#125;</code></pre>

<p>你可以给粒子/粒子组提供力/冲量，但你并不能在任一个点提供。事实上，力/冲量将被应用在每个粒子的中心上。</p>
<p><code>myParticleGroup-&gt;ApplyLinearImpulse(impulse);</code></p>
<h4 id="2-5-8-坐标转换"><a href="#2-5-8-坐标转换" class="headerlink" title="2.5.8  坐标转换"></a>2.5.8  坐标转换</h4><p>body类为你提供了点、向量在局部、世界坐标之间的转换。不明白这两个概念的话（？<strong>是我</strong>）请读*”Essential Mathematics for Games and Interactive Applications* by Jim Van Verth &amp; Lars Bishop。这些函数在内联下很快：</p>
<pre><code class="hljs C++"><span class="hljs-function">b2Vec2 <span class="hljs-title">GetWorldPoint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; localPoint)</span></span>;
<span class="hljs-function">b2Vec2 <span class="hljs-title">GetWorldVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; localVector)</span></span>;
<span class="hljs-function">b2Vec2 <span class="hljs-title">GetLocalPoint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; worldPoint)</span></span>;
<span class="hljs-function">b2Vec2 <span class="hljs-title">GetLocalVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; worldVector)</span></span>;</code></pre>

<h4 id="2-5-9-列表"><a href="#2-5-9-列表" class="headerlink" title="2.5.9  列表"></a>2.5.9  列表</h4><p>你可以遍历一个body上的fixture。这主要是在你需要访问fixture的用户数据的时候管用：</p>
<pre><code class="hljs C++"><span class="hljs-keyword">for</span> (b2Fixture* f = body-&gt;GetFixtureList(); f; f = f-&gt;GetNext())
&#123;
    MyFixtureData* data = (MyFixtureData*)f-&gt;GetUserData();
    <span class="hljs-comment">//DO SOMETHING</span>
&#125;</code></pre>

<p>遍历一个物体的关节list的方式也类似。</p>
<p>body也提供了一个相关contact的列表。但要小心，因为列表里不一定包含了所有在上一个time step存在过的contact。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Coding/">Coding</a>
                    
                      <a class="hover-with-bg" href="/categories/Coding/LiquidFun/">LiquidFun</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Coding/">Coding</a>
                    
                      <a class="hover-with-bg" href="/tags/LiquidFun/">LiquidFun</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/09/Comment-Notes-on-the-ALBUMs/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Comment: Notes on the ALBUMs</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/03/Diary-2020-07/">
                        <span class="hidden-mobile">Diary: 2020/07</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  
    <!-- APlayer 音乐播放器 -->
    <div id="aplayer"></div>
    <script defer src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js" ></script>
<link  rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
<script type="text/javascript">
  var oldLoadAp = window.onload;
  window.onload = function () {
    oldLoadAp && oldLoadAp();

    new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      autoplay: 'true' === 'true',
      loop: 'all',
      order: 'list',
      theme: '#b7daff',
      preload: 'none',
      audio: [{"name":"Song_On_The_Beach","artist":"Arcade_Fire","url":"/songs/Arcade_Fire-Song_On_The_Beach.mp3","cover":"/img/Song_On_The_Beach.jpg"}]
    });
  }
</script>

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer>
  (function () {
    // 查询存储的记录
    function getRecord(Counter, target) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {target, time: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    }

    // 发起自增请求
    function increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    }

    // 构建自增请求体
    function buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "time": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    }

    // 校验是否为有效的 UV
    function validUV() {
      var key = 'LeanCloud_UV_Flag';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    }

    function addCount(Counter) {
      var enableIncr = 'true' === 'true' && window.location.hostname !== 'localhost';
      var getterArr = [];
      var incrArr = [];

      // 请求 PV 并自增
      var pvCtn = document.querySelector('#leancloud-site-pv-container');
      if (pvCtn || enableIncr) {
        var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
          incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-pv');
          if (ele) {
            ele.innerText = record.time + 1;
            if (pvCtn) {
              pvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#leancloud-site-uv-container');
      if (uvCtn || enableIncr) {
        var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
          var vuv = validUV();
          vuv && incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-uv');
          if (ele) {
            ele.innerText = record.time + (vuv ? 1 : 0);
            if (uvCtn) {
              uvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(uvGetter);
      }

      // 如果是文章，请求文章的浏览数，并自增
      if ('true' === 'true') {
        var viewCtn = document.querySelector('#leancloud-post-views-container');
        if (viewCtn || enableIncr) {
          var target = decodeURI('/2020/07/08/LiquidFun%E6%96%87%E6%A1%A3%E7%AE%80%E8%AE%B0/');
          var viewGetter = getRecord(Counter, target).then((record) => {
            incrArr.push(buildIncrement(record.objectId))
            if (viewCtn) {
              var ele = document.querySelector('#leancloud-post-views');
              if (ele) {
                ele.innerText = (record.time || 0) + 1;
                viewCtn.style.display = 'inline';
              }
            }
          });
          getterArr.push(viewGetter);
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && increment(Counter, incrArr);
        })
      }
    }

    var app_id = 'yzJgerhadrHUF0U5I8IPKjIS-gzGzoHsz'
    var app_key = 'qQ0YN6yVdlMnmaxqWDCvTc7X'
    var server_url = 'https://yzjgerha.lc-cn-n1-shared.com'

    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': app_id,
            'X-LC-Key': app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };

      addCount(Counter);
    }

    var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(resp => resp.json())
        .then(({api_server}) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>






  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "LiquidFun文档简记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "§"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  

  

  

  

  

  





</body>
</html>
