<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.jpg">
  <link rel="icon" type="image/png" href="/img/icon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>LiquidFun文档简记-Part II - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Morehab's Space</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/bg/post.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.15)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-14 09:06">
      July 14, 2020 am
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      62
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-post-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-post-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p class="note note-info">
                
                  本文最后更新于：8 months ago
                
              </p>
            
            <article class="markdown-body">
              <h2 id="3-Particle-Module"><a href="#3-Particle-Module" class="headerlink" title="3.  Particle Module"></a>3.  Particle Module</h2><p>Particle Module应该是LiquidFun与Box2D的主要不同部分。它使用户能够创造、操控液体或软性（可变形）物体。它允许你创造、摧毁具有许多不同行为和性质的粒子，并且提供了控制它们的多种方式。这个模块允许你以离散方式/成组方式定义粒子，以帮助你有效地操控大量粒子。</p>
<h3 id="3-1-粒子"><a href="#3-1-粒子" class="headerlink" title="3.1  粒子"></a>3.1  粒子</h3><p><strong>粒子是圆形的，且是粒子系统中最小的单位物质。</strong>在默认设置下，一个粒子的行为像液体那样。当然，你可以通过设置<code>behavioral flag</code>来给粒子/粒子组赋予不同的行为（这在下面的Particle Behaviors一节中有详细介绍）。</p>
<p>b2Particle.h包含了指明<code>behavior value</code>的enum变量b2ParticleFlag。</p>
<h3 id="3-2-粒子系统"><a href="#3-2-粒子系统" class="headerlink" title="3.2  粒子系统"></a>3.2  粒子系统</h3><p>粒子们生活的“世界”被称作粒子系统。一个粒子系统指代的是很多决定了粒子如何互相作用、如何与world作用的物理系数，如默认粒子半径、弹性(elasticity)、粘性（viscosity）。更为详细的信息可以在b2ParticleSystemDef这个结构体的定义中看到。（太长了，这里不摘录了）</p>
<p>你可以通过如下方式创造一个粒子系统：</p>
<pre><code class="hljs C++"><span class="hljs-keyword">const</span> b2ParticleSystemDef particleSystemDef;
m_particleSystems[<span class="hljs-number">0</span>] = m_world-&gt;CreateParticleSystem(&amp;particleSystemDef);</code></pre>

<p>你也可以创造不止一个粒子系统。</p>
<p>一般来说你都不需要改变particleSystemDef的默认值/创造多个粒子系统，但某些情况下你也可能发现这两个功能很管用。例如：将粒子分成多个粒子系统后可以提高模拟效率（只模拟可见系统，将其它系统放置在paused状态）。在Testbed中提供了一个两个系统分别影响一个刚体、彼此不互动的例子。</p>
<h3 id="3-3-粒子组"><a href="#3-3-粒子组" class="headerlink" title="3.3  粒子组"></a>3.3  粒子组</h3><p>你能设置的粒子组的性质其中有部分与离散粒子的性质相同：行为、位置、线速度、颜色。也有一些性质是粒子组专属的：转动角度、转动速度、力量。这在b2ParticleGroup.h里可以看到。</p>
<p><strong>离散粒子 vs. 粒子组</strong></p>
<p>除了一个例子以外，单个粒子和粒子组之间都没有显著的功能差别。这个例子就是刚体粒子：由于使粒子变刚性的内部算法的特性远古，刚体粒子必须以群体的方式定义。</p>
<p>粒子组也有如下几个好处：首先，可以自动创造/摧毁大量粒子；其次，可以方便的给它们赋予同样的性质。</p>
<h3 id="3-4-在世界中进行时间推演（粒子迭代）"><a href="#3-4-在世界中进行时间推演（粒子迭代）" class="headerlink" title="3.4  在世界中进行时间推演（粒子迭代）"></a>3.4  在世界中进行时间推演（粒子迭代）</h3><p>粒子处理器（solver）可以在一个time step中迭代多次。迭代多次将提高粒子模拟的稳定性和准确性。然而，迭代次数越多，所需的处理器周期也就越多。</p>
<p>这些周期的时间成本几乎是线性的：迭代次数翻倍将导致<code>b2ParticleSystem::Solve</code>的周期时间成本翻倍。</p>
<p>你应当使用<code>b2World::Step</code>里面的<code>particleIterations</code>参数来调整迭代次数，默认值是1。</p>
<p>你可以通过实验找到<code>particleIterations</code>的最佳值，可以通过<code>b2CalculateParticleIterations</code>或者<code>b2World::CalculateReasonableParticleIterations</code>来估计迭代次数的合理值，但这两个函数都相当简化，仅应当被视作估计的起点。</p>
<p>如果你的模拟看起来过于热情洋溢/你模拟中的粒子正在穿过contact，你应当适当增加迭代次数。</p>
<p>注意到：随着迭代次数的增加，在高度压缩的粒子上压力的作用也会愈发明显（也就是说，粒子变得越来越不可压缩了）。</p>
<blockquote>
<p>注：为了模拟的稳定性、并且防止过度的相互渗透，粒子模拟为粒子指定了强制性的<strong>最大速度</strong>：</p>
<p><code>particle_diameter / (particle_iterations * b2World::Steps&#39; dt)</code>。</p>
</blockquote>
<h3 id="3-5-创造-摧毁单个粒子"><a href="#3-5-创造-摧毁单个粒子" class="headerlink" title="3.5  创造/摧毁单个粒子"></a>3.5  创造/摧毁单个粒子</h3><p><strong>创造离散粒子</strong>：</p>
<pre><code class="hljs C++">b2ParticleDef pd;
pd.flags = b2_elasticParticle; pd.color.Set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>); pd.Position.Set(i, <span class="hljs-number">0</span>);
<span class="hljs-keyword">int</span> tempIndex = m_particleSystem-&gt;CreateParticle(pd);</code></pre>

<p>粒子的列表是自密实的。因此，CreateParticle返回的指标在一个更低指标的粒子（组）被删除时就会失效。</p>
<p><strong>摧毁粒子</strong>：</p>
<p>摧毁时请使用如下无返回值的函数：</p>
<p><code>m_particleSystem-&gt;DestroyParticle(tempIndex);</code></p>
<p><strong>粒子的生命周期</strong>：</p>
<p>粒子除了被手动删除外，还可能由于既定的生命周期过期/由于年龄过大被删除。</p>
<p>如下语句将让系统根据年龄顺序追踪粒子以进行删除：</p>
<pre><code class="hljs C++">m_particleSystem-&gt;SetParticleDestructionByAge(<span class="hljs-literal">true</span>);</code></pre>

<p>一个粒子由于年龄而死有两种原因：</p>
<p>（1）超过预设的生命周期，过期了。如下程序设置了粒子的生命周期（介于min和max之间的随机数），index制定了被赋予该生命周期的粒子数：</p>
<pre><code class="hljs C++">m_particleSystem-&gt;SetParticleLifetime(index, Random() * (k_particleLifetimeMax - k_particleLifetimeMin) + k_particleLifetimeMin);</code></pre>

<p>（2）在程序中，用户预设了同一时间能存在的粒子数的最大值，并且告诉系统根据年龄追踪粒子，则粒子会通过追杀多余粒子的方式保持粒子总数恒定，这个顺序是通过年龄顺序决定的，老粒子会先被暗杀。通过如下语句设置粒子最大数：</p>
<p><code>m_particleSytem-&gt;SetMaxParticleCount(k_maxParticleCount);</code></p>
<p>这可以在Testbed的Faucet一例中看到。</p>
<h3 id="3-6-困住的粒子"><a href="#3-6-困住的粒子" class="headerlink" title="3.6  困住的粒子"></a>3.6  困住的粒子</h3><p>粒子如果在特定地方卡住，就会成为障碍，需要被清除/换位置。如果一个粒子在用户指定数目的粒子迭代过程中始终与两个以上的平面保持接触，就会被系统判定为卡住。一旦被判定卡住后，你可以通过实现你自己的函数来判断是不是真的卡住了，并且处理卡住的粒子。</p>
<p>既然函数是用户实现的，用户在决定如何认定粒子卡住上就有了自主选择权。例如，对于一个正在穿过管道的球来说，它可能会与多边的墙发生碰撞，但用户可以通过自己定义的函数认定这个球没有卡住（只要这个球在正常运动）。另一方面，你也可以使用这样的判定依据：即使粒子在运动，但只要它卡在一个特定的空间范围内，我就认定它被卡住了。</p>
<p>如下例子中，用户建立了一个sensor fixture的全局数组，覆盖了所有可能出现卡壳粒子的区域。用户在每一步都会通过传感器检查所有系统给出的可能卡住的粒子，将任何一个处在危险区域的粒子删除：</p>
<pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyStuckParticlesInSensors</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Fixture* <span class="hljs-keyword">const</span> *sensors, int32 num)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">const</span> int32 stuck = gParticleSyste-&gt;GetStuckCandidateCount();
    <span class="hljs-keyword">if</span>(stuck &gt; <span class="hljs-number">0</span>)
    &#123;
        <span class="hljs-keyword">const</span> int32 *candidates = gParticleSystem-&gt;GetStuckCandidates();
        <span class="hljs-keyword">const</span> b2Vec2 *positions = gParticleSystem-&gt;GetPositionBuffer();
        <span class="hljs-keyword">for</span> (int32 j = <span class="hljs-number">0</span>; j &lt; num; ++j)
        &#123;
            <span class="hljs-keyword">if</span>(sensors[j]-&gt;TestPoint(<span class="hljs-built_in">position</span>))
            &#123;
                gParticleSystem-&gt;DestroyParticle(particle);
            &#125;
        &#125;
    &#125;
&#125;
<span class="hljs-comment">//连续5次迭代以上同时接触多个面的粒子进入名单</span>
gParticleSystem-&gt;SetStuckThreshold(<span class="hljs-number">5</span>);

gWorld-&gt;Step(gTimeStep, gVelocityIterations, gPositionIterations);

<span class="hljs-comment">//检查</span>
DestroyStuckParticlesInSensors(gProblemAreaSensors, gNumSensors);</code></pre>

<h3 id="3-7-创建-删除粒子组"><a href="#3-7-创建-删除粒子组" class="headerlink" title="3.7  创建/删除粒子组"></a>3.7  创建/删除粒子组</h3><p>一个粒子组的生命开始于一个有形状的容器中。创建顺序如下：</p>
<p>（1）指定一个shape；</p>
<p>（2）创造一个b2ParticleGroupDef-struct对象；</p>
<p>（3）指定粒子的行为和属性；</p>
<p>（4）使用指定函数创造粒子组。</p>
<p>如下的程序段创造了五组颜色不同、盒子形状的粒子：</p>
<pre><code class="hljs C++">b2PolygonShape shape;
shape.SetAsBox(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);

b2ParticleGroupDef pd;
pd.shape = shape;
pd.flags = b2_elasticParticle;
pd.angle = <span class="hljs-number">-0.5f</span>;
pd.angularVelocity = <span class="hljs-number">2.0f</span>;
<span class="hljs-keyword">for</span>(int32 i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)
&#123;
    pd.<span class="hljs-built_in">position</span>.Set(<span class="hljs-number">10</span> + <span class="hljs-number">20</span> * i, <span class="hljs-number">40</span>);
    pd.color.Set(i * <span class="hljs-number">255</span>/ <span class="hljs-number">5</span>, <span class="hljs-number">255</span> - i * <span class="hljs-number">255</span>/<span class="hljs-number">5</span>, <span class="hljs-number">128</span>, <span class="hljs-number">255</span>);
    m_particleSystem-&gt;CreateParticleGroup(pd);
&#125;</code></pre>

<p>为了摧毁粒子组，触发如下函数：</p>
<p><code>DestroyParticles(bool callDestructionListener);</code></p>
<p>这样的话，当组中没有粒子时，粒子组就会自动被摧毁（若<code>b2_particleGroupCanBeEmpty</code>变量在组的flags中未经设置）。</p>
<p>下面的这个粒子将粒子系统中的所有粒子摧毁：</p>
<pre><code class="hljs C++">b2ParticleGroup* group = m_particleSystem-&gt;GetParticleGroupList();
<span class="hljs-keyword">while</span>(group)
&#123;
    m_particleSystem-&gt;SetGroupFlags(m_particleSystem-&gt;GetGroupFlags() &amp; ~b2_particleGroupCanBeEmpty);
    group-&gt;DestroyParticles(<span class="hljs-literal">false</span>);
    group = group-&gt;GetNext();
&#125;
<span class="hljs-comment">///(?)不懂欸</span></code></pre>

<h3 id="3-8-粒子行为"><a href="#3-8-粒子行为" class="headerlink" title="3.8  粒子行为"></a>3.8  粒子行为</h3><h4 id="3-8-1-对粒子组而言"><a href="#3-8-1-对粒子组而言" class="headerlink" title="3.8.1  对粒子组而言"></a>3.8.1  对粒子组而言</h4><p>使用<code>b2ParticleGroupFlag</code>这个enum设置，分以下两种：</p>
<p><strong>（1）Solid</strong>：</p>
<p>固体的粒子组将阻止其它物体嵌入它的内部。如果任何物体尝试穿透它，固体粒子组将把物体推回到自己的表面。</p>
<p>固体粒子组同样有很强的斥力，在你希望一个物体在表面上发生超常有弹力的碰撞时很有用（如壁球撞到墙上）。</p>
<p><code>pd.groupFlags = b2_solidParticleGroup;</code></p>
<p><strong>(2) Rigid</strong></p>
<p>刚体粒子组的形状不会发生改变，即使当与其它物体碰撞的时候也是如此。使用刚体粒子组与直接使用刚体相比有如下几个好处：</p>
<ul>
<li><p>可以只删除组的一部分：</p>
<ul>
<li>例如，一颗子弹打过后，将在盒型粒子组里产生一个洞；</li>
</ul>
</li>
<li><p>和其它组融合：</p>
<ul>
<li>例如，先创造三个圆形的粒子组，再把它们合并拼成一个雪人儿；</li>
</ul>
</li>
</ul>
<p><code>pd.groupFlags = b2_rigidParticleGroup;</code></p>
<h4 id="3-8-2-对单个粒子而言："><a href="#3-8-2-对单个粒子而言：" class="headerlink" title="3.8.2  对单个粒子而言："></a>3.8.2  对单个粒子而言：</h4><p>使用b2ParticleFlag这个enum。注意到不同的粒子行为所需的时间成本不同。</p>
<p><strong>（1）Elastic（弹性）</strong></p>
<p>弹性粒子会变形，与刚体碰撞的时候会弹跳。</p>
<p><code>pd.flags = b2_elasticParticle;</code></p>
<p>在Testbed中的“Elastic Particles”中，绿圈圈和蓝盒子就是由弹性粒子组成的。</p>
<p><strong>（2）Color-mixing（混色）</strong></p>
<p>混色粒子会从与其碰撞的粒子中蘸取一部分颜色。假设两个碰撞粒子中只有一个是color-mixing的，那么另一个粒子会保持原色。</p>
<p>混色是这样计算的：</p>
<ul>
<li><p><code>deltaColor = colorMixingStrength * (B&#39;s color - A&#39;s color);</code></p>
</li>
<li><p><code>A&#39;s color += deltaColor</code>;</p>
<p><code>B&#39;s color -= deltaColor;</code></p>
</li>
</ul>
<p>注意到若第二步中结果出现负数，会被改换为绝对值；若结果&gt;255，会被模掉255。</p>
<p><code>pd.flags = b2_colorMixingParticle;</code></p>
<p>在Testbed的surface tension这一demo中可以看到。</p>
<p><strong>（3）Powder（粉末）</strong></p>
<p>粉末粒子会产生分散效果，就像灰尘/沙子那样。这在sparky这个demo中可以看到。</p>
<p><code>pd.flags = b2_powderParticle;</code></p>
<p><strong>（4）Spring（弹簧）</strong></p>
<p>弹簧粒子们的行为就好像它们通过弹簧<strong>成对</strong>连接那样。每个粒子都与它在创造时离得最近的粒子相连，相连之后就不会再换搭档。将两个粒子分离的外力越大，外力撤销时它们互相碰撞的力就越大。不管粒子之间离得有多远，弹簧都不会断。</p>
<p><code>pd.flags = b2_springParticle;</code></p>
<p>这在elastic particles里面的红圈圈可以看到。</p>
<p><strong>（5）Tensile（可伸长的）</strong></p>
<p>可拉长粒子是用于创造表面张力/液体物体上拉紧后弯曲这一效果的。它可以用于创造，例如，水滴上的表面张力。</p>
<p>一旦张力被打破，粒子就会像弹性粒子那样弹跳，但同样也会继续彼此吸引，因此在弹跳过程中很可能成簇。</p>
<p><code>pd.flags = b2_tensileParticle;</code></p>
<p>这可以在surface tension这一个demo中看到。</p>
<p><strong>（5）Viscous（黏性）</strong></p>
<p>黏性粒子展现了附着感/粘稠感，例如油。</p>
<p><code>pd.flags = b2_viscousParticle;</code></p>
<p>这在Liquid Timer这个demo中能看到。</p>
<p><strong>（6）Static Pressure（静态压力）</strong></p>
<blockquote>
<p>静压：物体液体相对静止时，液体对物体产生的压力。</p>
</blockquote>
<p>粒子是容易受到压缩的。例如，当粒子被倒进一个容器里，底部粒子之间的排列会更紧密。</p>
<p>静压粒子将这种区别抹去：组中的每个粒子收到的压力都相同。</p>
<p><code>pd.flags = b2_staticPressureParticle;</code></p>
<p><strong>（7）Wall（墙）</strong></p>
<p>墙粒子是静态的，永远不动，即使发生碰撞也如此。</p>
<p><code>pd.flags = b2_WallParticle;</code></p>
<p><strong>（8）Barrier（障碍）</strong></p>
<p>固体/刚体粒子并不是内在地防止了tunneling：高速运动的粒子是可能穿过它们的。障碍粒子与其它粒子配合使用，可以使得粒子组tunneling-free。这在以下情景有用：确保液体粒子不会从墙粒子组成的容器中漏出去。</p>
<p>障碍粒子仅仅能阻止它们栖居的粒子组发生穿透，并不能防止粒子跑到两组粒子中间（即使组的位置让它们看起来像是相邻的）。</p>
<p>你可以把障碍粒子与elastic/spring/wall粒子一起用。</p>
<pre><code class="hljs C++">pd.flags = b2_WallParticle | b_barrierParticle;
pd.groupFlags = b2_solidParticleGroup;</code></pre>

<p><strong>（9）Zombie（僵尸）</strong></p>
<p>僵尸粒子在你想要一步摧毁多个粒子的时候比较管用。所有被你设置成僵尸的粒子都会在solver的同一次迭代中同时被摧毁。这将提高性能（所需的时间与删除单个粒子的时间相同）。</p>
<p><code>group-&gt;GetFlagsBuffer()[i] |= b2_zombieParticle;</code></p>
<p><strong>注意到，使用 | 可以将多个行为特征赋予给一个粒子（组）。</strong></p>
<p><code>pd.groupFlags = b2_solidParticleGroup | b2_rigidParticleGoup;</code></p>
<p>若要使得组既具备组专属的特征、又有粒子的特征，使用两个语句：</p>
<pre><code class="hljs C++">pd.flags = b2_elasticParticle;
pd.groupFlags = b2_solidParticleGroup;</code></pre>

<h3 id="3-9-粒子属性"><a href="#3-9-粒子属性" class="headerlink" title="3.9  粒子属性"></a>3.9  粒子属性</h3><p><strong>（1）Color-颜色</strong></p>
<p><code>pd.color.Set(r, g, b, a);</code></p>
<p>分别为red, green, blue, opacity，值都在0-255之间。</p>
<p><strong>（2）Size-大小</strong></p>
<p>使用小粒子时要记住两点：</p>
<ul>
<li><p>对于粒子组来说，粒子的大小可能会影响性能。这是因为粒子大小与组成组的粒子个数成反比，而粒子越多效率越低。</p>
<p><code>m_particleSystem-&gt;SetRadius(r);</code></p>
<p>r为&gt;0.0f的float32值，默认值为1.0f。</p>
</li>
<li><p>小粒子也可能在爆炸等场景里会出现不可预测的行为（违反动量守恒定律）。通过减低gravity scale降低这些粒子的速度可能会让它们稳定下来。</p>
<p><code>m_particleSystem-&gt;SetGravityScale(g);</code></p>
<p>g是一个&gt;0.0f的float32值，默认为1.0f。</p>
</li>
</ul>
<p>还要注意的是，调整solver每步进行的粒子迭代数也可能会影响重力在粒子上的作用。迭代次数越大，对重力的抵抗就会越大。增加迭代次数的一个重要理由就是防止提及缩小（由重力导致的压缩）。</p>
<p><strong>（3）Position（位置）</strong></p>
<p><code>pd.position.Set(x,y);</code></p>
<p>x, y是粒子组平移的世界坐标。</p>
<p><strong>（4）Velocity（速度）</strong></p>
<p>对离散粒子来说，使用以下语句：</p>
<p><code>pd.velocity.Set(x,y);</code></p>
<p>x, y分别为沿x, y轴的速度。</p>
<p>对粒子组来说，使用如下语句：</p>
<pre><code class="hljs C++">pd.linearVelocity.Set(x,y);
pd.angularVelocity = aV;</code></pre>

<p>x, y分别为沿x, y轴的速度，aV为组的旋转速度（aV rad/s）。</p>
<p><strong>（5）Angles（角度）（专属于粒子组）</strong></p>
<p><strong>仅仅对rigid粒子组有用。</strong>这指明了粒子组倾斜的角度，用弧度表示，默认值为0。</p>
<p><code>pd.angle = a;</code></p>
<p><strong>（6）Strength（力量）（专属于粒子组）</strong></p>
<p>力量描述了粒子组的凝聚力，s为介于0.0（完全不凝聚）与1.0（非常凝聚）之间的值，默认为1.0。</p>
<p><code>pd.strength = s;</code></p>
<h3 id="3-10-使用OpenGL进行渲染"><a href="#3-10-使用OpenGL进行渲染" class="headerlink" title="3.10  使用OpenGL进行渲染"></a>3.10  使用OpenGL进行渲染</h3><p>粒子模块提供了通过OpenGL进行方便渲染的方法。</p>
<p>每种粒子性质都住在一个连续的记忆缓冲区里。如下表格提供了一个存储的的视觉展示。</p>
<p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714093359007.png" srcset="/img/loading.gif" alt="image-20200714093359007"></p>
<p>OpenGL可以在渲染的时候直接使用这些缓冲区。在这个例子中，OpenGL 1.1会使用glVertexPointer和glColorPointer从存储中得到这些值。OpenGL 2.0会使用glVertexAttribPointer。</p>
<p>OpenGL可以渲染单独粒子/粒子组。</p>
<h3 id="3-11-样本应用"><a href="#3-11-样本应用" class="headerlink" title="3.11  样本应用"></a>3.11  样本应用</h3><p>LiquidFun提供的样本中有两个应用展示了这个库的能力。</p>
<p>Testbed提供了大量的demo，展示了不同类型的粒子行为。有些demo是只能看的，有些demo是可以互动的。</p>
<p>EyeCandy只能在Android上运行，且提供了两份：它提供了一个简单的在Android上使用LiquidFun的例子，并且试图展示她在移动硬件上优秀的液体着色器。</p>
<p>运行程序时，你可以通过倾斜屏幕溅出液体，也可以通过点击屏幕切换不同的着色器。</p>
<h2 id="4-Loose-Ends"><a href="#4-Loose-Ends" class="headerlink" title="4.  Loose Ends"></a>4.  Loose Ends</h2><h3 id="4-1-用户数据"><a href="#4-1-用户数据" class="headerlink" title="4.1  用户数据"></a>4.1  用户数据</h3><p>b2Fixture, b2Body, b2Joint这几个类都允许你通过一个空指针连接你的用户数据，这在你检查LiquidFun的数据结构、决定它们怎么与你游戏引擎中的对象连接是很有用的。</p>
<p>例如，通常你都会把你的主角的指针与它身上的物体连接。这会形成循环引用（有actor能找到body，有body能找到actor）。</p>
<pre><code class="hljs C++">GameActor* actor = GameCreateActor();
b2BodyDef bodyDef;
bodyDef.userData = actor;
actor-&gt;body = box2Dworld-&gt;CreateBody(&amp;bodyDef);</code></pre>

<p>以下是几个你需要用户数据的例子：</p>
<p>（1）通过碰撞数据对主角造成一定的伤害；</p>
<p>（2）如果用户到达一个沿坐标轴的盒子里时播放一个编排好的事件；</p>
<p>（3）当LiquidFun告知你需要摧毁一个joint的时候获得一个游戏结构。</p>
<p>注意到用户数据是自选的，放啥都行，但应该始终保持一致。例如，如果你想在一个物体上存储一个actor的指针，就应该在所有物体上都存放一个actor的指针。</p>
<p>默认情况下，用户数据指针都是空的。</p>
<p>对于fixture来说，你可以考虑使用用户数据结构，来存放你所需要的游戏信息，例如材料、效果的链接、声音的链接。</p>
<pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FixtureUserData</span></span>
<span class="hljs-class">&#123;</span>
    <span class="hljs-keyword">int</span> materialIndex;
    ...
&#125;
FixtureUserData myData = <span class="hljs-keyword">new</span> FixtureUserData;
myData-&gt;materialIndex = <span class="hljs-number">2</span>;
b2FixtureDef fixtureDef;
fixtureDef.userData = myData;  <span class="hljs-comment">///</span>
b2Fixture* fixture = body-&gt;CreateFixture(&amp;fixtureDef);
...
<span class="hljs-keyword">delete</span> fixture-&gt;GetUserData();
fixture-&gt;SetUserData(<span class="hljs-literal">NULL</span>);
body-&gt;DestroyFixture(fixture);</code></pre>

<h3 id="4-2-未被指明的摧毁（implicit-destruction）"><a href="#4-2-未被指明的摧毁（implicit-destruction）" class="headerlink" title="4.2  未被指明的摧毁（implicit destruction）"></a>4.2  未被指明的摧毁（implicit destruction）</h3><p>LiquidFun不使用引用计数，所以当你摧毁一个物体的时候它就真的没了。使用一个被摧毁物体的指针产生的结果各种各样，最大的可能性就是你的程序会崩。为了帮助解决这个问题，debug build memory manager fills使用FDFDFDFD来摧毁实体。</p>
<p>如果你摧毁了一个LiquidFun的实体，那么你就必须负责把所有它的引用也给删除。如果你对一个物体有多次引用，你最好考虑实现一个处理类（handle class）来处理这些指针。</p>
<p>当你使用LiquidFun你会创造、摧毁许多物体、形状、关节，大部分这些操作都是由LiquidFun自动完成的。如果你摧毁一个物体，那么相关的形状、关节都会被摧毁，这就叫做<strong>隐姓摧毁</strong>。这时任何一个和以上关节/contact连接的物体就会被唤醒，这个过程通常是有利的，但你要注意：</p>
<blockquote>
<p>摧毁body时相关的fixture, joint都被自动删除。你必须要把与这些fixture, shape, joint相关的指针都给归零。（否则试图使用/摧毁这些指针将会出事）</p>
</blockquote>
<p>LiquidFun为你提供了一个监视器类叫做b2DestructionListener，你可以实现后用在你的world对象上，这时world对象就会在由joint被隐性摧毁时通知你。</p>
<p>注意到joint/fixture被显性摧毁的时候也不会有通知，你也需要作相应的后续清理。如果可以的话，你也可以调用你自己的b2DestructionListener类中的清理代码。</p>
<p>隐性摧毁通常是便捷的，但你一定要注意。尤其是，关节通常在一段与相关物体管理无关的代码中被创造，例如，testbed创造了一个mousejoint用于与鼠标操作互动。</p>
<p>LiquidFun提供了一个callback机制，来在隐形摧毁的时候通知你，这在之后有描述。</p>
<pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDestructionListener</span> :</span> <span class="hljs-keyword">public</span> b2DestructionListener
&#123;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SayGoodbye</span><span class="hljs-params">(b2Joint* joint)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-comment">//remove all references to joint</span>
    &#125;
&#125;</code></pre>

<p>你可以之后用world对象登记你的destruction listener，这应该在world的初始化中做：</p>
<p><code>myWorld-&gt;SetListener(myDestructionListener);</code></p>
<h3 id="4-3-像素以及坐标系"><a href="#4-3-像素以及坐标系" class="headerlink" title="4.3  像素以及坐标系"></a>4.3  像素以及坐标系</h3><p>再次回顾：LiquidFun使用MKS单位和弧度制。由于游戏是使用像素展示的，你可能会觉得用米有点麻烦。在Testbed中，作者将所有的游戏工作都在米中进行，只是使用OpenGL的视口变换（viewport transformation）将世界转换到屏幕大小。</p>
<pre><code class="hljs C++"><span class="hljs-keyword">float</span> lowerX = <span class="hljs-number">-25.0f</span>, upperX = <span class="hljs-number">25.0f</span>, lowerY = <span class="hljs-number">-5.0f</span>, upperY = <span class="hljs-number">25.0f</span>;
gluOrtho2D(lowerX, upperX, lowerY, upperY);</code></pre>

<p>如果你的游戏非得在像素世界中运行，那么你可以在从LiquidFun获得/传输数据的时候转换单位。这将提高物理模拟的稳定性。</p>
<p>你应该找到一个合适的换算标准，这最好根据你的主角的大小决定。例如，你的角色是75像素高，那么你就可以使用50像素/米。</p>
<pre><code class="hljs C++">xMeters = <span class="hljs-number">0.02f</span> * xPixels;

xPixels = <span class="hljs-number">50.0f</span> * xMeters;</code></pre>

<p>最好呢，是在游戏代码中就使用MKS，只是在渲染的时候再转换成像素。这会简化你的游戏逻辑，并且减少错误，因为渲染的部分可以被孤立在一小部分代码里面完成。</p>
<p>如果你使用转换单位的方式，你最好全局地改变它，确保不出错。你也可以通过调整提高稳定性。</p>
<h2 id="5-Debug-Drawing"><a href="#5-Debug-Drawing" class="headerlink" title="5.  Debug Drawing"></a>5.  Debug Drawing</h2><p>你可以实现b2DebugDraw这个类以得到物理世界的详细描绘。可用的实体有以下这些：</p>
<p>（1）形状轮廓；</p>
<p>（2）关节连接；</p>
<p>（3）AABBs；</p>
<p>（4）质心；</p>
<p>这是推荐的画物理实体的方法，而不是直接获取数据。理由是：这些重要的数据通常都存储在内部，且对改变易感。</p>
<p>testbed画了一些物理实体，使用的是debug draw这个功能还有contact listener。这展示了怎么使用debug drawing，以及怎么画接触点。</p>
<h2 id="6-Limitations"><a href="#6-Limitations" class="headerlink" title="6.  Limitations"></a>6.  Limitations</h2><p>LiquidFun使用了许多近似，来有效地模拟刚体物理。这会导致一些局限：</p>
<p>（1）将重的物体放在轻的物体上并不稳定，稳定性在比例超过10：1时会下降。</p>
<p>（2）对于用关节连接的chains of bodies，如果轻的物体在支撑重的物体，也会不稳定。例如，一个吊锤挂在一个chain的轻物体上就不是很稳定，超过10：1时就会这样。</p>
<p>（3）形状和形状碰撞之间通常有个0.5cm的差别。</p>
<p>（4）连续碰撞不能处理关节，所以高速运动的物体上关节可能会延展；</p>
<p>（5）LiquidFun使用symplectic Euler integration scheme（辛欧拉时间积分公式？）</p>
<p>（6）LiquidFun使用一个迭代solver来提高实时性能。你将没法得到非常精确的刚体碰撞/像素，提高迭代次数可以提高精度。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Coding/">Coding</a>
                    
                      <a class="hover-with-bg" href="/categories/Coding/LiquidFun/">LiquidFun</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Coding/">Coding</a>
                    
                      <a class="hover-with-bg" href="/tags/LiquidFun/">LiquidFun</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/07/15/LiquidFun%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LiquidFun源码学习笔记</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/07/09/Record-%E7%BA%A2%E7%A3%A11994-%E6%91%87%E6%BB%9A%E4%B8%AD%E5%9B%BD%E4%B9%90%E5%8A%BF%E5%8A%9B/">
                        <span class="hidden-mobile">Record: 红磡1994 摇滚中国乐势力</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  
    <!-- APlayer 音乐播放器 -->
    <div id="aplayer"></div>
    <script defer src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js" ></script>
<link  rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
<script type="text/javascript">
  var oldLoadAp = window.onload;
  window.onload = function () {
    oldLoadAp && oldLoadAp();

    new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      autoplay: 'true' === 'true',
      loop: 'all',
      order: 'list',
      theme: '#b7daff',
      preload: 'none',
      audio: [{"name":"Song_On_The_Beach","artist":"Arcade_Fire","url":"/songs/Arcade_Fire-Song_On_The_Beach.mp3","cover":"/img/Song_On_The_Beach.jpg"}]
    });
  }
</script>

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer>
  (function () {
    // 查询存储的记录
    function getRecord(Counter, target) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {target, time: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    }

    // 发起自增请求
    function increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    }

    // 构建自增请求体
    function buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "time": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    }

    // 校验是否为有效的 UV
    function validUV() {
      var key = 'LeanCloud_UV_Flag';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    }

    function addCount(Counter) {
      var enableIncr = 'true' === 'true' && window.location.hostname !== 'localhost';
      var getterArr = [];
      var incrArr = [];

      // 请求 PV 并自增
      var pvCtn = document.querySelector('#leancloud-site-pv-container');
      if (pvCtn || enableIncr) {
        var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
          incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-pv');
          if (ele) {
            ele.innerText = record.time + 1;
            if (pvCtn) {
              pvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#leancloud-site-uv-container');
      if (uvCtn || enableIncr) {
        var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
          var vuv = validUV();
          vuv && incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-uv');
          if (ele) {
            ele.innerText = record.time + (vuv ? 1 : 0);
            if (uvCtn) {
              uvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(uvGetter);
      }

      // 如果是文章，请求文章的浏览数，并自增
      if ('true' === 'true') {
        var viewCtn = document.querySelector('#leancloud-post-views-container');
        if (viewCtn || enableIncr) {
          var target = decodeURI('/2020/07/14/LiquidFun%E6%96%87%E6%A1%A3%E7%AE%80%E8%AE%B0-Part-II/');
          var viewGetter = getRecord(Counter, target).then((record) => {
            incrArr.push(buildIncrement(record.objectId))
            if (viewCtn) {
              var ele = document.querySelector('#leancloud-post-views');
              if (ele) {
                ele.innerText = (record.time || 0) + 1;
                viewCtn.style.display = 'inline';
              }
            }
          });
          getterArr.push(viewGetter);
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && increment(Counter, incrArr);
        })
      }
    }

    var app_id = 'yzJgerhadrHUF0U5I8IPKjIS-gzGzoHsz'
    var app_key = 'qQ0YN6yVdlMnmaxqWDCvTc7X'
    var server_url = 'https://yzjgerha.lc-cn-n1-shared.com'

    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': app_id,
            'X-LC-Key': app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };

      addCount(Counter);
    }

    var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(resp => resp.json())
        .then(({api_server}) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>






  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "LiquidFun文档简记-Part II&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "§"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  

  

  

  

  

  





</body>
</html>
