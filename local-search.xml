<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>酱爆老俞</title>
    <link href="/2020/09/16/%E9%85%B1%E7%88%86%E8%80%81%E4%BF%9E/"/>
    <url>/2020/09/16/%E9%85%B1%E7%88%86%E8%80%81%E4%BF%9E/</url>
    
    <content type="html"><![CDATA[<p>老俞今年年方六九，是一名光荣的人民教师，抬起头在黑板上写字时后脑勺上的头皮会叠出美丽的大波浪。</p><p>他非常喜欢教书，尤其喜欢在讲台上做有氧运动——来回抚摸他的汗渍渍的头顶。在每个光头都会变成咸鸭蛋的夏天，老俞还保留着仅剩的一点毛发尊严，搓揉头皮时还能感到蔫软的粗糙。但他秃顶也秃得没有特色，和每个步入黄昏的中年男教师一样令人同情而没有特色。</p><p>甚至他每天听到的那些针对他的头顶的窃笑声都那样的寡淡、那样的没有特色，老俞也如同每一个汗渍渍的中年男教师那样给出没有特色而疲软的愧笑作为回应。老俞的生活就是这样过来的，在此之前他也曾经年轻过，曾经坐在讲台下放荡地点评着每个中年男老师的头皮，但那般心境已然破碎在时间里了。</p><p>每天老俞都从家出发，来到食堂点上一份糖醋里脊，吃完后晃着自己鼓胀的肚皮踱到教室。他如同每个上了年纪的老师那样，总是在PPT卡住的时候乱点一气，每10分钟就要讲一件自己的光辉往事，时不时就要搓揉自己的头皮。偶尔，他看到年轻人们眼中那些或调笑或真诚的火焰，会不由得一惊，然后声音愈发像宦官一样尖细。</p><p>老俞偶尔也会叹气，把所有咒骂浓缩成憋屈的烟灰弹在脚底。他想，他是在怀念青春，但他其实没有恣意的年月可以怀念。他想起的只不过是一种幻象，是将美好青春的愿景投射在自己年轻岁月上得到的虚假的回忆。但即便是假想，老俞也不允许自己沉湎于其中；老俞是一个务实的人，正是务实让他有机会在二十多岁时就在学校里站稳了作为教师的脚跟，然后如愿在这个岗位上混吃混喝，直至消磨掉自己头皮上的毛囊。</p><p>一支烟的时间过后，老俞便会忘掉这些伤春悲秋。他会和同样油腻的中年男教师们一同出发，去食堂享受公费报销的糖醋里脊。</p><blockquote><p>灵感来源：上学期始终未曾谋面的大物老师，今日借室友照片有幸一睹真容。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Fiction</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fiction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diary: 2020/09</title>
    <link href="/2020/09/01/Diary-2020-09/"/>
    <url>/2020/09/01/Diary-2020-09/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Do you remember the 21st night of September?<br>你还记得9月21日的晚上么？<br>Love was changing the minds of pretenders<br>爱在那晚揭下我们伪装的面纱，<br>While chasing the clouds away<br>拨云驱雾，<br>Our hearts were ringing<br>心在欢呼，<br>In the key that our souls were singing.<br>那正是灵魂歌唱的声音。<br>As we danced in the night,<br>黑夜中的我们尽情欢舞，</p><p>Remember how the stars stole the night away<br>还记得璀璨的星光是如何照亮黑夜的么？<br>Aaahh Ba de ya - say do you remember<br>这一切你还记得吗？<br>Ba de ya - dancing in September<br>九月的欢舞，<br>Ba de ya - never was a cloudy day<br>没有阴霾的日子里，<br>My thoughts are with you<br>我的思念追随着你。<br>Holding hands with your heart to see you<br>手牵手心连心，凝视着你，<br>Only blue talk and love,<br>只有说不完的话和无尽的爱,<br>Remember how we knew love was here to stay<br>还记得我们怎么感受到爱情已经来临的吗？<br>Now December found the love that we shared in September.<br>十二月的今天想起我们九月里共谱的爱曲，<br>Only blue talk and love,<br>只有说不完的话和无尽的爱，<br>Remember the true love we share today yeah<br>铭记今天我们之间的真爱</p><p align="right">——Earth, Wind & Fire 《September》</p></blockquote><h2 id="2020-9-1"><a href="#2020-9-1" class="headerlink" title="2020.9.1"></a>2020.9.1</h2><p>我就知道！要让我持续每天打卡做一件事果然是不可能的（于是上个月只剩下2篇日记）。</p><p>艺术家人格分离到微博了，以后博客还是拿来写日记+记录一些Coding相关的东西。</p><p>不想写小作业大作业，想看电影（sigh，别人都开始找素材包了，我怎么一点都没有紧迫感呢）。主要是因为qt啥也不会，要写作业要自己看好多东西，有点懒。</p><p>只能promise自己，今晚看完电影立刻开始写小作业（）。</p><h2 id="2020-9-14"><a href="#2020-9-14" class="headerlink" title="2020.9.14"></a>2020.9.14</h2><p>9月，9月，不朽的9月，忙碌的9月。</p><p>小学期，挣扎，忙碌，闲暇，颓废；搬宿舍，孤独，责难，困倦；开学，开学，开学，开始奔命，开始打哈欠，开始手忙脚乱。</p><p>这学期想要学会真诚，去展示artistic的一面，去交一些朋友，加个社团&amp;参加一些比赛。</p><p>话不多，但还是要说。</p><h2 id="2020-9-27"><a href="#2020-9-27" class="headerlink" title="2020.9.27"></a>2020.9.27</h2><p>9月，9月。9月切开我的喉管和前额叶，在溃烂的血肉组织中翻找出一团跳动的灰烬。</p><p>我在白天和夜晚无休无止地沉睡，闭上眼睛深呼吸，看到我的自行车撞上行人或是车碾过我，看到我的四肢变成很多截躺在地上，看到血从我所有白色愚蠢的伤口流出来，磁带重播后又是新的循环。</p><p>我也已经放弃给这种现状找一个名词。是或不是又怎样呢，药物也不过是短暂的希望。</p><p>此刻我只想蜷成一团。没有任何想做的事。我也想跳进河里，像垃圾一样漂着。</p><h2 id="2020-9-29"><a href="#2020-9-29" class="headerlink" title="2020.9.29"></a>2020.9.29</h2><p>睡眠回归，话语回归，狂躁回归。日常听/看自己写的东西被恶心到想吐，也算是人生一大成就了。</p><p>啊哈，可是糟糕的念头仍旧没有消失。在每个和室友聊天大笑的瞬间，和同学寒暄的瞬间，我都听到黑色的手指搅动我脑浆的声音。我于是只好用比这些念头更糟糕的文字和声音来驱散它们，可是这并没有让任何事情变好。</p><p>好羡慕那些可以明确表达悲伤情绪并主动索取帮助的人啊。但我只会笑。笑得懦弱、顺从、附和。就连以上这些苦水文字也让我恶心得要死——我就是这么、这么、这么厌恶自己的。</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Daily Learning: 使用宏和shell script</title>
    <link href="/2020/09/01/Daily-Learning-%E4%BD%BF%E7%94%A8%E5%AE%8F%E5%92%8Cshell-script/"/>
    <url>/2020/09/01/Daily-Learning-%E4%BD%BF%E7%94%A8%E5%AE%8F%E5%92%8Cshell-script/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Pre-everything：</p><p>我已经在图书馆听歌、冲浪将近一个半小时了，实在是懒得自学QT。而唯一剩下的一个小作业老师又没有讲到，我又不想看大作业（sigh），宿舍要等到5点才结束装修，所以就写下这个昨天就想写的小note好了。</p><p>就算这些废话和这篇博客毫无关系，我也还是要写在开头。</p></blockquote><p>小作业的题目如下：</p><blockquote><p>调整三个for循环的顺序，生成<strong>所有可能的遍历方式</strong>，同时测试在<strong>不同规模</strong>下循环体的运行时间并加以分析：</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; N; ++k)            c[i][j][k] = a[i][j][k] + b[i][j][k];</code></pre><p>（主要就是探究一下内存的cache机制）</p></blockquote><p>总的来说，并不是一个很难完成的task。跟随群里dalao的带领，我们主要试图通过宏和shell script解决两个问题：</p><p>（1）如何避免代码重复？（也即，如何避免<strong>6个3重循环</strong>？）</p><p>（2）如何改变参数后多次运行，以达到测试的目的？</p><h2 id="Step-1-仿函数宏——避免代码重复"><a href="#Step-1-仿函数宏——避免代码重复" class="headerlink" title="Step 1: 仿函数宏——避免代码重复"></a>Step 1: 仿函数宏——避免代码重复</h2><p>群里有同学提到了使用##, #完成所需的任务。</p><p>我一开始的思路是使用一个[6][3]的二维数组来完成这一任务：</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> f(x) (var##x)</span><span class="hljs-keyword">int</span> permute[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> f(permute[i][<span class="hljs-number">0</span>]); ; )           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> f(permute[i][<span class="hljs-number">1</span>]); ; )               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> f(permute[i][<span class="hljs-number">2</span>]); ; )                  <span class="hljs-comment">// do something</span>&#125;</code></pre><p>然而非常悲壮地，它报错了。原因从一个化简的下面程序即可看出来：</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> f(x) (var##x)</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> var1 = <span class="hljs-number">1</span>;<span class="hljs-built_in">cout</span> &lt;&lt; f(a) &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><blockquote><p>[Error] <strong>‘vara’</strong> was not declared in this scope.</p></blockquote><p>嗯…一般的仿函数宏不是都会把变量的值带进去吗？为什么这里是把变量的名字<code>a</code>带进去了呢？</p><p><strong>这是因为#/##是宏中比较特别的两个字符，一般来说不会进行替换。</strong></p><p>下面是一段我没有看懂也不想仔细看的替换规则：</p><blockquote><p><strong>规则1：实参替换。</strong><br>本条规则描述带参数的宏的替换过程。</p><p>对于宏定义中的形参,在替换列表中,如果不是作为#或##的操作数,那么将对应实参完全<br>展开(相当于对实参进行求值),然后将替换列表中的形参替换掉.如果是#或##的操作数，</p><p>那么不进行替换。</p><p><strong>规则2：多次扫描。</strong><br>在所有的形参替换为实参后,对结果进行再次扫描,如果发现还有可替换的宏,则进行替换，<br>否则中止。</p><p><strong>规则3：递归替换抑制。</strong><br>如果在替换列表中发现当前正在展开的宏的名字，那么这里不进行替换.更进一步,在嵌套<br>的替换过程中发现已经替换过的宏的名字,则不进行替换。</p><p><strong>规则4：递归预处理抑制。</strong><br>如果替换后的结果形成预处理指令，则不执行这条预处理指令。</p></blockquote><p>就我粗浅的理解，<strong>想要通过变量名访问、让变量的值被传进参数里面这条路在这个规则下应该是行不通了。</strong></p><p>正当我又试了几种其它方法都行不通、打算放弃之际，突然灵光一现——想到了一个小点子！（实际上是一种折衷方案，并没有完全解决之前的问题）直接使用变量去定义<strong>包含for循环的宏</strong>：</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR_LOOP(i) for (int var##i = 0; var##i &lt; n; ++var##i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FOR(i) FOR_LOOP(i)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TIMECOUNT(i, j, k) &#123; startClock = clock();\  <span class="hljs-comment">//\表示换行但仍在宏内</span></span>  FOR(i) &#123; FOR(j) &#123; FOR(k) &#123; a[var0][var1][var2] = b[var0][var1][var2] + c[var0][var1][var2]; &#125; &#125; &#125;\  endClock = clock();\  timeCount = (<span class="hljs-keyword">double</span>)(endClock - startClock) / CLOCKS_PER_SEC;\  outFile &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; setprecision(<span class="hljs-number">6</span>) &lt;&lt; timeCount;\&#125;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">100</span>; <span class="hljs-comment">// a bunch of other definitions and initializations</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  TIMECOUNT(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>); TIMECOUNT(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">//ijk &amp; ikj</span>  TIMECOUNT(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>); TIMECOUNT(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">//jik &amp; jki</span>  TIMECOUNT(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>); TIMECOUNT(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">//kij &amp; kji</span>&#125;</code></pre><p>这样的代码相对来说还是比较好看的！</p><p>当然，<strong>这并没有解决之前的问题</strong>。如果这是一个5重循环，下面就会有120条TIMECOUNT语句，仍旧是相对比较丑陋的。</p><p>我们先跳过这一问题，进入到改变数据规模n进行测试的环节（下一环节其实提供了一个解决该问题的备选方案）。</p><h2 id="Step-2：使用shell-script进行测试"><a href="#Step-2：使用shell-script进行测试" class="headerlink" title="Step 2：使用shell script进行测试"></a>Step 2：使用shell script进行测试</h2><p>接下来问题又来了，这个文件中的数据规模<code>n</code>是一个常数。我们在.cpp文件中好像没有办法方便地循环改变它（至少我没有想到办法）。</p><p>然后我想到了上学期OOP课程做课程report学过一点的shell script。如果把常数变成一个宏，定义在<code>CONST.h</code>里：</p><pre><code class="hljs C++"><span class="hljs-comment">// CONST.h</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> n 100</span></code></pre><p>那么我们只需要在shell script里面重写这个文件，然后重新编译运行这个文件就好了：</p><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span>n=0<span class="hljs-comment"># write the head of table</span><span class="hljs-built_in">echo</span> <span class="hljs-string">"n ijk ikj jik jki kij kji"</span> &gt; table.txt<span class="hljs-comment"># &gt; 意味着写入文件头部，如果文件不存在则创建文件</span><span class="hljs-comment"># for循环</span><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> &#123;32..300&#125;<span class="hljs-keyword">do</span><span class="hljs-comment"># write the new const n to file CONST.h</span>sed -i <span class="hljs-string">"/#define n/c#define n <span class="hljs-variable">$n</span>"</span> CONST.h<span class="hljs-comment"># sed -i（插入） "/字符串1/c字符串2" 文件名</span><span class="hljs-comment"># 则会搜索与字符串1匹配的行，把整行内容替换为字符串2</span><span class="hljs-comment"># compile and run with the new const n</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$n</span>make./main<span class="hljs-keyword">done</span></code></pre><p>我们希望main.cpp中把内容写到文件的尾部：</p><pre><code class="hljs C++">outFile.<span class="hljs-built_in">open</span>(<span class="hljs-string">"table.txt"</span>, ios::app);</code></pre><p>到此就完工啦。</p><p>事实上，仔细一想，使用shell script也可以解决之前的问题：可以从另一个写好数组内容的文件中读取数据，然后利用这些数据写出main.cpp中应该有的120条的TIMECOUNT语句。（<strong>属于曲线救国</strong>，本质上还是没有解决这个问题）</p><p>还有一个遗留问题：这样每次都要重新编译链接，比较耗时。网上查了一下可以使用<strong>配置文件</strong>，但我也并不清楚要怎么弄，就留给下次再研究啦。</p>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
      <category>Daily Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP复习笔记-Part I</title>
    <link href="/2020/08/23/OOP%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/08/23/OOP%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-0-Pre-everything"><a href="#Chapter-0-Pre-everything" class="headerlink" title="Chapter 0: Pre-everything"></a>Chapter 0: Pre-everything</h1><p><strong>课程大纲</strong>：对象，类，封装，继承，组合，多态，设计模式，模板与STL。</p><p><strong>主要Reference</strong>: Thinking in C++，second edition，<a href="www.cplusplus.com">cplusplus.com</a></p><p><strong>History</strong>： BCPL -&gt; B -&gt; NB -&gt; C -&gt; C with classes(Bjarne Stroustrup) -&gt; C++(Bjarne Stroustrup)</p><p><strong>使用的编译器</strong>：g++ 5.4.0, Ubuntu 16.04 LTS</p><p>复习中遇到的一些有用函数:</p><table><thead><tr><th>声明/用法</th><th>函数所在库</th><th>函数作用</th></tr></thead><tbody><tr><td><code>int atoi(const char *str)</code></td><td>&lt;stdlib.h&gt;</td><td>把字符串转换为一个int 型,转换无效时返回0。</td></tr><tr><td><code>cout &lt;&lt; right &lt;&lt; &quot;&quot;</code></td><td><iomanip></td><td>这里的right/left用于设置右对齐/左对齐，默认为右对齐，<strong>全局有效</strong>，设置后要调回来。</td></tr><tr><td><code>cout &lt;&lt; setw(20) &lt;&lt;</code></td><td><iomanip></td><td>字段宽度设置，<strong>只对紧接着的输出有效</strong>，当后面紧跟着的输出字段长度小于n的时候，在该字段前面用空格补齐；当输出字段长度大于n时，全部整体输出。</td></tr><tr><td><code>cout&lt;&lt;setfill(&#39;*&#39;)</code></td><td><iomanip></td><td>在上面补齐时，更改默认填充字符。<strong>全局有效</strong>。</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong>文件输入输出</strong></p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span>fstream in_file;in_file.<span class="hljs-built_in">open</span>(<span class="hljs-string">"ContactEmail.txt"</span>,<span class="hljs-built_in">std</span>::ios::in);  <span class="hljs-comment">//std::ios::out</span><span class="hljs-keyword">if</span> (!in_file) &#123;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Error while trying to open the file.\n"</span>;  in_file.<span class="hljs-built_in">close</span>();  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;in_file.<span class="hljs-built_in">close</span>();</code></pre><p><strong>随机</strong>：</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span>srand(time(<span class="hljs-literal">NULL</span>));<span class="hljs-keyword">int</span> a = rand();</code></pre><p><strong>计时</strong>：</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h/ctime&gt;</span></span><span class="hljs-keyword">clock_t</span> start = clock();<span class="hljs-keyword">clock_t</span> <span class="hljs-built_in">end</span> = clock();<span class="hljs-keyword">double</span> time = (<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">end</span> - start) / CLOCKS_PER_SEC;</code></pre><h2 id="0-1-C-11-14-17新特性"><a href="#0-1-C-11-14-17新特性" class="headerlink" title="0.1  C++11/14/17新特性"></a>0.1  C++11/14/17新特性</h2><h3 id="0-1-1-特殊的for-range-based-for-loops"><a href="#0-1-1-特殊的for-range-based-for-loops" class="headerlink" title="0.1.1  特殊的for: range-based for loops"></a>0.1.1  特殊的for: range-based for loops</h3><pre><code class="hljs C++"><span class="hljs-built_in">vector</span> <span class="hljs-keyword">int</span> a[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ia : a) <span class="hljs-comment">// 相当于 for(int i = 0, ia = a[i]; i &lt; a.size(); i++, ia = a[i])</span></code></pre><p>这需要a是个容器（vector, string等），即a.begin(), a.end()合法。</p><p>注意 <strong>ia是元素</strong>而非迭代器，且是值传递的。</p><p>若需要修改a中元素，则应该为<code>for (auto&amp; ia : a)</code></p><h1 id="Chapter-1-环境"><a href="#Chapter-1-环境" class="headerlink" title="Chapter 1: 环境"></a>Chapter 1: 环境</h1><h2 id="1-1-命令行参数"><a href="#1-1-命令行参数" class="headerlink" title="1.1  命令行参数"></a>1.1  命令行参数</h2><p>三种主入口函数的有效声明：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></code></pre><p>假设输入为：</p><pre><code class="hljs text">.&#x2F;adder.out 2 3 4 5</code></pre><p>则接收到的参数为：</p><pre><code class="hljs C++">argc = <span class="hljs-number">5</span>;argv = &#123;<span class="hljs-string">"./adder.out"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>&#125;;</code></pre><p><strong>Note 0</strong>: 输入由<strong>空格分隔</strong>，双引号内可以有空格。</p><p><strong>Note 1</strong>: Linux的默认工作目录为terminal中所在的工作目录，而非可执行文件所在的目录。</p><h2 id="1-2-编译和多文件工程"><a href="#1-2-编译和多文件工程" class="headerlink" title="1.2  编译和多文件工程"></a>1.2  编译和多文件工程</h2><p><strong>Translators</strong>: 将源代码（<strong>source code</strong>)翻译为机器指令（<strong>machine instructions</strong>)，分为以下两类：</p><ul><li><strong>Interpreter</strong>：边解释边执行，运行期间需要的内存较大，即时反应，效率较低，e.g.：Basic, Perl。</li><li><strong>Compiler</strong>：先将源代码全部翻译为机器码，再运行，内存内只存储机器码。需要内存小，效率高。e.g.：C &amp; C++。</li></ul><p>一般来说，集成开发环境（IDE）内都会有解释器。</p><h3 id="1-2-1-g-编译常用选项"><a href="#1-2-1-g-编译常用选项" class="headerlink" title="1.2.1  g++编译常用选项"></a>1.2.1  g++编译常用选项</h3><p><strong>-c</strong>： 只编译不链接，只生成目标文件（.o)。</p><p><strong>-o</strong>：指定生成的可执行文件的名称，如<code>g++ -o a.exe file.cpp</code>，生成的就会是<code>a.exe</code>，否则默认生成<code>a.out</code>。</p><p><strong>-g</strong>：添加GDB调试选项。</p><h3 id="1-2-2-头文件"><a href="#1-2-2-头文件" class="headerlink" title="1.2.2  头文件"></a>1.2.2  头文件</h3><p>（1）头文件：用于存放函数、变量、类、模板的声明，后缀为.h, .hpp, .hxx。<strong>只声明不定义，否则可能报”Multiple Definitions”的错误。</strong></p><p>（2）<strong>extern</strong>：用于声明函数/变量。</p><p><code>extern int x;</code>    </p><p><code>extern void sum(int argc, char* argv[]);  //函数情况可以省略</code></p><p>（3）<strong>预编译命令（Preprocessor directive）</strong>：</p><p><strong>#include</strong>：</p><p>&lt;&gt;通常用于寻找系统头文件，寻找的位置为“PATH”所指的 + 编译选项中的（g++ -Idir/to/header）</p><p>“”先在当前目录寻找，再去&lt;&gt;找的路径下面找。</p><p><strong>Note 1</strong>：在函数被定义、使用的地方都包括头文件。</p><p>（4）<strong>Inclusion Guard</strong>：</p><p>Guard Macro通常用于防止多次包含头文件的编译错误。<strong>在写头文件时一定要写<code>#ifndef</code>那些。</strong></p><p>宏是由<strong>preprocessor（预编译器）</strong>处理的。</p><h3 id="1-2-3-编译链接"><a href="#1-2-3-编译链接" class="headerlink" title="1.2.3  编译链接"></a>1.2.3  编译链接</h3><p><strong>解释</strong>：将.cpp编译为.o，将.o链接为可执行文件。(TO BE DONE: 头文件在其中哪一步？)</p><p><strong>Note</strong>：.o也可以被包含后变成.lib/.a/.so。</p><p>（1）直接编译链接：<code>g++ main.cpp sum.cpp product.cpp -o a.out</code></p><p>（2）分段编译：仍要链接，分步编译。</p><p><strong>Makefile</strong> :</p><pre><code class="hljs makefile"><span class="hljs-comment"># Dependency Rule: 如果冒号后的文件比冒号前的文件新，执行下方的命令</span><span class="hljs-comment"># 如果一个.cpp中有.h，依赖文件中应该有这个.h</span><span class="hljs-comment"># 一定要用缩进！不能使用空格。</span><span class="hljs-section">a.out: main.o sum.o multiply.o</span>g++ main.o sum.o multiply.o -o a.out<span class="hljs-section">main.o: main.cpp function.h</span>g++ -c main.cpp -o main.o<span class="hljs-section">sum.o: sum.cpp function.h</span>g++ -c sum.cpp -o sum.o<span class="hljs-section">multiply.o: multiply.cpp function.h</span>g++ -c multiply.cpp -o multiply.o<span class="hljs-comment"># 清除所有.o和.out</span><span class="hljs-meta"><span class="hljs-meta-keyword">.PHONY</span>: clean</span><span class="hljs-section">clean:</span>-rm a.out main.o sum.o multiply.o</code></pre><p>默认target为<code>all</code>，可以使用<code>make target_name</code>只生成一个文件。</p><h3 id="1-2-4-Linux命令"><a href="#1-2-4-Linux命令" class="headerlink" title="1.2.4  Linux命令"></a>1.2.4  Linux命令</h3><pre><code class="hljs shell">login # logging inpasswd # change passwordlogout / exit # logging outsudo shutdown -h 3 #sudo : run the command as 管理员，shutdown in 3minssudo shutdown -h nowsudo shutdown -r now #rebootsudo reboot #reboottouch file-name # create an empty filemkdir dir_name # create an directorygedit/vi file_name # edit one file with the editorls # list contents of the directoryls --help # for more optionsls -al <span class="hljs-meta">#</span><span class="bash">-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为<span class="hljs-string">"."</span>的视为隐藏档，不会列出)</span><span class="hljs-meta">#</span><span class="bash">-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</span><span class="hljs-meta">#</span><span class="bash">-r 将文件以相反次序显示(原定依英文字母次序)</span><span class="hljs-meta">#</span><span class="bash">-t 将文件依建立时间之先后次序列出</span><span class="hljs-meta">#</span><span class="bash">-A 同 -a ，但不列出 <span class="hljs-string">"."</span> (目前目录) 及 <span class="hljs-string">".."</span> (父目录)</span><span class="hljs-meta">#</span><span class="bash">-F 在列出的文件名称后加一符号；例如可执行档则加 <span class="hljs-string">"*"</span>, 目录则加 <span class="hljs-string">"/"</span></span><span class="hljs-meta">#</span><span class="bash">-R 若目录下有文件，则以下之文件亦皆依序列出<span class="hljs-comment">#a:all files including the hidden ones, </span></span><span class="hljs-meta">#</span><span class="bash"> 路径</span><span class="hljs-meta">#</span><span class="bash"> ~ : home directory</span><span class="hljs-meta">#</span><span class="bash"> ~username: another user<span class="hljs-string">'s home directory</span></span><span class="hljs-meta">#</span><span class="bash"> .: current dir</span><span class="hljs-meta">#</span><span class="bash"> ..: parent dir</span><span class="hljs-meta">#</span><span class="bash"> ../.. : parent of parent dir</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">pwd</span>: 显示当前绝对路径</span><span class="hljs-meta">#</span><span class="bash"> 复制文件</span><span class="hljs-meta">#</span><span class="bash"> cp src-file dest-file : copy src to dest</span><span class="hljs-meta">#</span><span class="bash"> cp src-file dest-dir : copy src to dest dir</span><span class="hljs-meta">#</span><span class="bash"> cp -r src_dir dest-dir: copy src_dir to dest_dir</span><span class="hljs-meta">#</span><span class="bash"> 删除文件</span><span class="hljs-meta">#</span><span class="bash"> rm file</span><span class="hljs-meta">#</span><span class="bash"> rm -r dir</span><span class="hljs-meta">#</span><span class="bash"> 压缩文件</span><span class="hljs-meta">#</span><span class="bash"> tar zcvf dir.tar.gz dir: pack directory dir</span><span class="hljs-meta">#</span><span class="bash"> tar zxvf dir.tar.gz: unpack</span><span class="hljs-meta">#</span><span class="bash"> 改变权限</span><span class="hljs-meta">#</span><span class="bash"> chmod mode file1 file2 ...</span><span class="hljs-meta">#</span><span class="bash"> chmod -R mode dir : change all files <span class="hljs-keyword">in</span> dir</span><span class="hljs-meta">#</span><span class="bash"> chmod go-rwx foo.c</span><span class="hljs-meta">#</span><span class="bash"> u: userg: group o: other+: add permission</span><span class="hljs-meta">#</span><span class="bash"> -: remove permission r: <span class="hljs-built_in">read</span>w:writex:execute</span></code></pre><h1 id="Chapter-2-类和对象"><a href="#Chapter-2-类和对象" class="headerlink" title="Chapter 2: 类和对象"></a>Chapter 2: 类和对象</h1><p>抽象、封装、继承、多态。</p><h2 id="2-1-权限控制"><a href="#2-1-权限控制" class="headerlink" title="2.1 权限控制"></a>2.1 权限控制</h2><p>外部只能访问public对象和函数。<strong>class的默认权限为private，struct的默认权限为public。</strong></p><h2 id="2-2-inline函数"><a href="#2-2-inline函数" class="headerlink" title="2.2  inline函数"></a>2.2  inline函数</h2><p>小于10行的函数可定义为inline提高效率，<strong>在头文件中声明</strong>，不应当包含循环/递归，<strong>可以是成员函数</strong>。</p><p><strong>Note</strong>：函数体在类内部定义的函数<strong>默认为inline</strong>。</p><h2 id="2-3-this指针"><a href="#2-3-this指针" class="headerlink" title="2.3  this指针"></a>2.3  this指针</h2><p>指向当前对象的地址，在<strong>重载运算符</strong>时较有用，”return *this”。</p><h2 id="2-4-Ctor-amp-Dtor"><a href="#2-4-Ctor-amp-Dtor" class="headerlink" title="2.4  Ctor &amp; Dtor"></a>2.4  Ctor &amp; Dtor</h2><p>在对象被创建和销毁时自动由compiler调用，<strong>一般都是public</strong>。</p><pre><code class="hljs C++">ClassA a; <span class="hljs-comment">//在stack上</span>ClassA *pA = <span class="hljs-keyword">new</span> ClassA; <span class="hljs-comment">//在heap上</span></code></pre><h3 id="2-4-1-Ctor"><a href="#2-4-1-Ctor" class="headerlink" title="2.4.1  Ctor"></a>2.4.1  Ctor</h3><ul><li><p>没有返回类型，与类同名，可以有参数。</p></li><li><p>缺省构造函数（default ctor）：没有参数的ctor。</p></li><li><p>默认构造函数（default default ctor）：no ctor defined才会由编译器自动生成一个，函数体空。</p><p>可以这样使用：<code>Tree() = default;</code></p></li><li><p>使用{}。</p></li><li><p>关于in-class initializer:</p></li></ul><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">public</span>:   <span class="hljs-keyword">int</span> i &#123;<span class="hljs-number">5</span>&#125;;  <span class="hljs-comment">// in-class initializer</span>    <span class="hljs-comment">//事实上会变成A () :i&#123;5&#125; &#123;&#125; ，但可能放在最前面，就被覆盖掉了</span>   A() : i &#123;<span class="hljs-number">7</span>&#125; &#123; &#125;   A(<span class="hljs-keyword">int</span> h) : i(h) &#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  A a;  <span class="hljs-built_in">cout</span> &lt;&lt; a.i &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">//输出7，in-class被初始化列表的覆盖</span>  A b&#123;<span class="hljs-number">9</span>&#125;;  <span class="hljs-built_in">cout</span> &lt;&lt; b.i &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">//输出9，被强行指定的覆盖</span>&#125;</code></pre><ul><li><p>成员初始化列表效率高，<strong>变量初始化顺序需要与声明顺序相同（不报错的情况下，初始化顺序由声明顺序决定）</strong>。</p></li><li><p><strong>单参ctor</strong>可用于所谓implicit conversion，如下：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span>&#123;</span>  <span class="hljs-keyword">int</span> height_;<span class="hljs-keyword">public</span>:  <span class="hljs-comment">/*explicit*/</span> Tree(<span class="hljs-keyword">int</span> h): height_&#123;h&#125; &#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(Tree t)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    foo(<span class="hljs-number">5</span>);  <span class="hljs-comment">//在不使用explicit关键字的情况下可以通过编译。</span>&#125;</code></pre></li><li><p><strong>Delegating Ctor</strong>：在初始化列表中使用另一个ctor。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span>&#123;</span>    <span class="hljs-keyword">int</span> height_, size_;<span class="hljs-keyword">public</span>:    Tree(<span class="hljs-keyword">int</span> h): height_&#123;h&#125; &#123;&#125;    Tree() : Tree &#123;<span class="hljs-number">0</span>&#125; &#123; size_ = <span class="hljs-number">0</span> &#125;;  <span class="hljs-comment">//委托</span>&#125;</code></pre></li></ul><h3 id="2-4-2-Dtor"><a href="#2-4-2-Dtor" class="headerlink" title="2.4.2  Dtor"></a>2.4.2  Dtor</h3><p>在（1）变量离开作用域 （2）使用delete关键字 时会被调用。</p><p>现代C++中应当用unique_ptr&lt;&gt;和shared_ptr&lt;&gt;替代new &amp; delete。</p><p><strong>最好不要显式调用：如<code>pA-&gt;~ClassA();</code></strong>。</p><ul><li>没有返回值，没有参数，<strong>只有一个</strong>，不能重载。是public的。</li><li>在有指针变量/引用变量/socket/printer时一定要有dtor。</li><li>Default dtor: empty， <code>~Tree() = default;</code></li></ul><p><strong>Note</strong>：函数内的静态变量将在第一次调用函数时被construct，main()执行完后被destruct。</p><h2 id="2-5-堆和栈"><a href="#2-5-堆和栈" class="headerlink" title="2.5  堆和栈"></a>2.5  堆和栈</h2><p><strong>栈（stack）</strong>：</p><p>（0）例：<code>int i; double val; ClassA a;</code></p><p>（1）容量有限；</p><p>（2）存储函数的局部变量</p><p>（3）会溢出。</p><p><strong>堆（heap）</strong>：</p><p>（0）例：<code>int num = 100000; int *arr = new int[num];</code></p><p>（1）大小比栈大，一般不会溢出（大数组定义在这儿）。</p><h1 id="Chapter-3-进阶内容"><a href="#Chapter-3-进阶内容" class="headerlink" title="Chapter 3: 进阶内容"></a>Chapter 3: 进阶内容</h1><h2 id="3-1-宏"><a href="#3-1-宏" class="headerlink" title="3.1  宏"></a>3.1  宏</h2><p>基于预编译命令。</p><ul><li><p>定义值：<code>#define PI 3.14159</code>。<strong>用<code>#undef PI</code>来取消一个值的定义。</strong></p></li><li><p>guard头文件：<code>#ifdef</code>。</p></li><li><p>定义函数：<code>#define MAX( A, B) ((A) &gt;= (B) ? (A) : (B))</code>  <strong>暴力替换，所以最好加括号！</strong></p></li><li><p>在编程中使用：</p><ul><li>_<em>func_</em> : function name in const char array</li><li>_<em>FILE_</em> : file name in stirng literal</li><li>_<em>LINE_</em>: current line number in interger literal</li><li>_<em>TIME_</em>: time of the compilation in string literal</li><li>_<em>DATE_</em>: date of the compilation in string literal</li></ul></li><li><p>DEBUG：</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;  // important</span></span>assert(value &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">//不满足的话会直接终止程序并输出错误</span></code></pre><p>可以用以下方式取消DEBUG，<code>#define NDEBUG</code>, <code>g++ -D NDEBUG xxx.cpp</code>。</p></li></ul><p><strong>Note</strong> : 最好不要用宏。宏是由preprocessor处理的，没有进行类型检查，如果不在符号表里记录可能无法debug，函数macro非常易错。<strong>倾向于使用compiler</strong>，故使用<strong>enum/const/inline</strong>。</p><h2 id="3-2-const"><a href="#3-2-const" class="headerlink" title="3.2  const"></a>3.2  const</h2><ul><li><p>const将默认<strong>internal linkage</strong>，也即只在被定义的源文件内可见，所以可以在header file内定义。</p></li><li><p><strong>定义和声明同时</strong>。不使用const_cast就不能再改变。</p></li><li><p><strong>使用extern进行显式声明，且不定义</strong>，要写const。<code>extern const int bufsize;</code></p></li><li><p>若size为const的，则<code>int arr[size];</code>正确。</p><p>但如下情况下不行：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bunch</span> &#123;</span>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;    <span class="hljs-keyword">int</span> arr[<span class="hljs-built_in">size</span>];<span class="hljs-keyword">public</span>:    Bunch(<span class="hljs-keyword">int</span> i) : <span class="hljs-built_in">size</span>&#123;i&#125; &#123;&#125;&#125;</code></pre><p>因为是先分配空间才执行的初始化。<strong>除非改成static const</strong>。</p></li><li><p>普遍用法：<code>void f1(const int&amp; i);</code>   （没有&amp;的话没有意义）</p></li><li><p>（1）const -&gt; non_const : <code>const_cast&lt;type&gt;(obj)</code>,   常量指针/引用变为非常量的指针/引用，指向原来的对象（如obj为const int<em>型，则type处应当为int</em>）</p><p>（2）non_const -&gt; const : as_const</p><pre><code class="hljs C++"><span class="hljs-comment">//const and back again</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Class::Function</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 用常成员函数变一个非-常成员函数出来</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const_cast</span>&lt;ReturnType&gt;(<span class="hljs-built_in">std</span>::as_const(*<span class="hljs-keyword">this</span>).Function(a));&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Class::Function</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> <span class="hljs-keyword">const</span> </span>&#123;    <span class="hljs-keyword">return</span> xxx;&#125;</code></pre> <pre><code class="hljs C++"><span class="hljs-comment">//unsafe usage</span><span class="hljs-comment">//不应当用于修改constant的值</span><span class="hljs-comment">//可用于：一个不会修改constant值的函数需要一个constant的非-常指针</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> constant = <span class="hljs-number">21</span>;<span class="hljs-keyword">int</span>* modifier = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span>*&gt;(&amp;constant);<span class="hljs-comment">// *modifier = 22;</span><span class="hljs-comment">// 如上语句在某些编译器下将不会修改constant的值，这是未定义的行为</span></code></pre></li><li><p>常指针和常值指针：</p><p>（1）top-level(常指针)：指针不变，对象可变。</p><pre><code class="hljs C++">ClassA a;ClassA* <span class="hljs-keyword">const</span> pA = &amp;a;</code></pre><p>（2）low-level(常值指针)：指针变，指向一个常对象。</p><pre><code class="hljs C++"><span class="hljs-keyword">const</span> ClassA b,c;<span class="hljs-keyword">const</span> ClassA *pB = &amp;b;pB = &amp;c;</code></pre></li></ul><p><strong>OOP相关的：</strong></p><p><strong>Note</strong>：const只能修饰成员函数而非一般的函数。</p><ul><li><p>常成员函数：不能修改任何成员变量，不能调用任何非-常函数。</p><p><code>void show() const;</code></p></li><li><p>常变量：<strong>只能在初始化列表里初始化</strong>，</p></li><li><p>常对象：不能修改任何成员变量（任何成员变量不能作为左值），只能调用其常成员函数。</p></li></ul><h2 id="3-3-enum"><a href="#3-3-enum" class="headerlink" title="3.3  enum"></a>3.3  enum</h2><ul><li><p>enum中的值在编译期间都可用，故也可以用来定义数组大小。</p><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bunch</span> &#123;</span><span class="hljs-keyword">enum</span> &#123; <span class="hljs-built_in">size</span> = <span class="hljs-number">1000</span>, next &#125;;  <span class="hljs-comment">//注意 ; 在 &#125; 之后，默认开始为0</span>    <span class="hljs-keyword">int</span> arr[next];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(Bunch) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) &lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre></li><li><p>只能表示整数。</p></li></ul><h2 id="3-4-函数重载"><a href="#3-4-函数重载" class="headerlink" title="3.4  函数重载"></a>3.4  函数重载</h2><p><strong>Note 1</strong>:  关于引用</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>;<span class="hljs-function"><span class="hljs-keyword">long</span>&amp; <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-keyword">long</span>&amp; a, <span class="hljs-keyword">long</span>&amp; b)</span></span>;larger(<span class="hljs-number">15</span>, <span class="hljs-number">25</span>);  <span class="hljs-comment">//这将调用double版本的函数，因为15,25作为临时变量无法绑定到引用</span><span class="hljs-comment">//但改成const long&amp;后就可以接受临时值了：</span><span class="hljs-function"><span class="hljs-keyword">long</span>&amp; <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span>&amp; b)</span></span>;</code></pre><p>*<em>Note 2 : *</em> const和非const参数只会在low-level指针和引用上有所区分：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b)</span> </span>&#123;&#125;  <span class="hljs-comment">//不能通过编译</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a,<span class="hljs-keyword">int</span>* b)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* b)</span> </span>&#123;&#125;  <span class="hljs-comment">//可以,low-level const</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a,<span class="hljs-keyword">int</span>* b)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* <span class="hljs-keyword">const</span> a, <span class="hljs-keyword">int</span>* <span class="hljs-keyword">const</span> b)</span> </span>&#123;&#125;  <span class="hljs-comment">//不能通过编译,top-level const</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; a,<span class="hljs-keyword">int</span>&amp; b)</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;b)</span> </span>&#123;&#125;  <span class="hljs-comment">//引用，可以</span></code></pre><p>*<em>Note 3:  *</em><code>static_cast</code>：</p><pre><code class="hljs C++"><span class="hljs-keyword">static_cast</span>&lt;type-id&gt;( expression )    <span class="hljs-comment">//将expression转换为type-id,没有运行类型检查来保证转换的安全性</span>    <span class="hljs-keyword">int</span> i = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">166.71</span>);Base* p = <span class="hljs-keyword">static_cast</span>&lt;Base*&gt;(&amp;derived_obj);  <span class="hljs-comment">//派生类指针转化为基类指针</span></code></pre><p><strong>Note 4:</strong> 缺省参数只在声明里给，定义不给（除非你没有声明，那就在定义里给，反正只给一次）。</p><h2 id="3-5-const-expression"><a href="#3-5-const-expression" class="headerlink" title="3.5  const expression"></a>3.5  const expression</h2><p>（1）<strong>def</strong>: 在编译时就计算好的表达式。表达式<strong>一定会要求编译器在编译时算出常值</strong>。</p><p>（2）<strong>constexpr function</strong>：</p><ul><li><strong>提示</strong>编译器在编译时就从函数中算出常值，编译器不一定会这么做；</li><li>可以作为ctor的关键字，从ctor中得到常对象。</li><li>默认inline，应当在头文件里定义。</li></ul><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">arrsize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-keyword">return</span> i * i;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i&#123;<span class="hljs-number">10</span>&#125;;  <span class="hljs-comment">//事实上这里是int也行</span><span class="hljs-keyword">int</span> arr1[arrsize(i)];  <span class="hljs-comment">//OK</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>;  <span class="hljs-comment">//任意去掉一个int就不行了</span><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> c = a + b;<span class="hljs-keyword">int</span> arr2[c];  <span class="hljs-comment">//OK</span>&#125;</code></pre><h2 id="3-6-inline"><a href="#3-6-inline" class="headerlink" title="3.6  inline"></a>3.6  inline</h2><p>安全、效率高、有类型检查、可以调试。</p><p>将代码复制过去了，所以没有函数调用的成本。适用于&lt;10行、无循环递归、大量调用的简单函数。</p><p>仅仅是向编译器发送inline请求，不一定执行。</p><p><strong>请定义在头文件内。</strong></p><p><strong>可以是普通函数，也可以是成员函数。函数体在类内默认inline。</strong></p><h2 id="3-7-namespace"><a href="#3-7-namespace" class="headerlink" title="3.7  namespace"></a>3.7  namespace</h2><p>目标：为了防止全局函数、全局变量、类的冲突。</p><p>（1）类、结构体、enum、union相当于自动创建命名空间。</p><p>（2）用例：可以嵌套，using有效直到达到文件结尾。</p><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> u&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>&#125;;&#125;  <span class="hljs-comment">//有没有分号都行，可以嵌套，</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    U::f();    <span class="hljs-keyword">using</span> U::A;  <span class="hljs-comment">//using namespace U;</span>    A a;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>（3）可以在不同/同一头文件中定义同一名字的命名空间。</p><p>于是可以将同一命名空间、不同模块的功能划分到不同文件中实现。</p><pre><code class="hljs C++"><span class="hljs-comment">//file : test1.h</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">namespace</span> U &#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print1</span><span class="hljs-params">()</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"print1"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  &#125;&#125;<span class="hljs-keyword">namespace</span> U &#123;  <span class="hljs-comment">//OK</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print2</span><span class="hljs-params">()</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"print2"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//file : test2.h</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">namespace</span> U &#123;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print3</span><span class="hljs-params">()</span></span><span class="hljs-function">  </span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"print3"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  &#125;&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//file : main.cpp</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"test1.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"test2.h"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> U;  <span class="hljs-comment">//将合并所有的U</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  print1();  print2();  print3();&#125;</code></pre><h2 id="3-8-static"><a href="#3-8-static" class="headerlink" title="3.8  static"></a>3.8  static</h2><h3 id="3-8-1-static-data-变量"><a href="#3-8-1-static-data-变量" class="headerlink" title="3.8.1  static data(变量)"></a>3.8.1  static data(变量)</h3><p><strong>生命期与（一段特定）程序一样长。</strong>在一个特殊的静态存储区，不在堆上也不在stack上。</p><p>使用<strong>internal linkage（static/const/inline）</strong>，static变量/函数都只在当前编译单元可见。在头文件/源文件定义都行。</p><ul><li>函数内的静态变量在初次调用函数的时候初始化。</li><li>全局静态变量在main()函数调用之前初始化。</li></ul><p><strong>使用extern关键字可以不包含头文件就使用一个变量/函数，但前提是这个变量/函数并不是internal linkage的（也即不是static/const/inline的），否则编译不能通过。</strong></p><h3 id="3-8-2-static成员变量-函数"><a href="#3-8-2-static成员变量-函数" class="headerlink" title="3.8.2  static成员变量/函数"></a>3.8.2  static成员变量/函数</h3><ul><li>所有该类对象共享，可以通过对象/类名访问。</li><li><strong>即使在没有对象存在时也存在</strong>。</li><li><strong>static关键字只出现在头文件里。</strong></li><li>static成员函数<strong>只能访问static成员变量和static成员函数。</strong></li></ul><h3 id="3-8-3-Singleton模式：static的应用"><a href="#3-8-3-Singleton模式：static的应用" class="headerlink" title="3.8.3  Singleton模式：static的应用"></a>3.8.3  Singleton模式：static的应用</h3><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Egg</span> &#123;</span><span class="hljs-keyword">private</span>:  <span class="hljs-keyword">static</span> Egg e; <span class="hljs-comment">//一个private的对象</span>  Egg() &#123;&#125;  <span class="hljs-comment">//ctor声明为private</span>  Egg(<span class="hljs-keyword">const</span> Egg&amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-keyword">public</span>:  <span class="hljs-function"><span class="hljs-keyword">static</span> Egg* <span class="hljs-title">instance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;e; &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Egg e;  <span class="hljs-comment">//doesn't work!</span>    Egg e = *Egg:instance(); <span class="hljs-comment">//但这个还可以，还需要禁用copy ctor &amp; 赋值</span>&#125;</code></pre><h2 id="3-9-引用"><a href="#3-9-引用" class="headerlink" title="3.9  引用"></a>3.9  引用</h2><ul><li><p>一定要<strong>同时定义和初始化</strong>，不能改成其它东西的引用。</p><pre><code class="hljs C++"><span class="hljs-keyword">int</span> &amp;refVal = val;</code></pre></li><li><p>在形参和返回值中常用。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">average</span><span class="hljs-params">(<span class="hljs-keyword">double</span> (&amp;<span class="hljs-built_in">array</span>)[<span class="hljs-number">10</span>])</span></span>;<span class="hljs-function"><span class="hljs-built_in">string</span>&amp; <span class="hljs-title">larger</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s1, <span class="hljs-built_in">string</span>&amp; s2)</span></span>;</code></pre><p>不要返回局部变量的引用！</p></li></ul><h2 id="3-10-拷贝构造"><a href="#3-10-拷贝构造" class="headerlink" title="3.10  拷贝构造"></a>3.10  拷贝构造</h2><p><strong>Note 1:</strong> 不加引用会挂，会引起循环定义（值传递本来就要拷贝）</p><pre><code class="hljs C++">X(<span class="hljs-keyword">const</span> X obj) &#123;&#125;  <span class="hljs-comment">//WRONG!</span>X(<span class="hljs-keyword">const</span> X&amp; obj) &#123;&#125;  <span class="hljs-comment">//RIGHT!</span></code></pre><p>新对象定义时必调用其中之一：ctor/copy ctor/move ctor。</p><p><strong>Note 2:</strong> 用户不定义时会合成一个<strong>bitcopy</strong>。有指针时会出错。</p><p><strong>Note 3</strong>: 可以通过声明为private来防止调用。或者使用delete关键字。例如，<strong>ofstream对象就禁止了拷贝构造。</strong></p><pre><code class="hljs C++">A&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-keyword">const</span> A&amp;) = <span class="hljs-keyword">delete</span>;A a, b;a = b; <span class="hljs-comment">// 编译不通过！</span></code></pre><h2 id="3-11-移动构造"><a href="#3-11-移动构造" class="headerlink" title="3.11  移动构造"></a>3.11  移动构造</h2><h3 id="3-11-1-关于左值和右值"><a href="#3-11-1-关于左值和右值" class="headerlink" title="3.11.1  关于左值和右值"></a>3.11.1  关于左值和右值</h3><blockquote><p><strong>左值</strong>：可读可写，变量通常都是。例：一个返回引用的函数的返回值。</p><p><strong>右值</strong>：只可读，例如字面量和临时对象</p><pre><code class="hljs C++"><span class="hljs-number">10</span>, <span class="hljs-string">"Hello world"</span>  <span class="hljs-comment">//字面量</span>    <span class="hljs-keyword">int</span> *p, i; <span class="hljs-comment">//&amp;p 和 i++ 是临时对象</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>  <span class="hljs-comment">//f()是临时对象</span></span></code></pre><p>以下用法都是错的：</p><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a, b;<span class="hljs-keyword">int</span> *x = <span class="hljs-literal">nullptr</span>;x = &amp;(b + a);  <span class="hljs-comment">//WRONG!</span>x = &amp;<span class="hljs-number">123</span>; <span class="hljs-comment">//WRONG!</span></code></pre></blockquote><ul><li>非常引用只能与左值绑定</li><li>常引用可以与左值/右值绑定。</li></ul><h3 id="3-11-2-右值引用（-amp-amp-）"><a href="#3-11-2-右值引用（-amp-amp-）" class="headerlink" title="3.11.2  右值引用（&amp;&amp;）"></a>3.11.2  右值引用（&amp;&amp;）</h3><p>仅与右值绑定。</p><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>;<span class="hljs-keyword">int</span> &amp;&amp;c = (a + b);<span class="hljs-built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><h3 id="3-11-3-移动构造"><a href="#3-11-3-移动构造" class="headerlink" title="3.11.3  移动构造"></a>3.11.3  移动构造</h3><p>有copy ctor或者dtor定义的时候就不会自动合成move ctor了。</p><p>不会自动摧毁原对象，除非你在move ctor里面定义了。</p><pre><code class="hljs C++">X(X&amp;&amp; obj);  <span class="hljs-comment">//obj应该不是const的</span>X a;X b = <span class="hljs-built_in">move</span>(a);  <span class="hljs-comment">//move将告诉编译器，a应当被视为右值</span></code></pre><h2 id="3-12-结构体的嵌套定义"><a href="#3-12-结构体的嵌套定义" class="headerlink" title="3.12  结构体的嵌套定义"></a>3.12  结构体的嵌套定义</h2><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type_1</span> &#123;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type_2</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type_3</span> &#123;</span><span class="hljs-keyword">int</span> data_3[<span class="hljs-number">10</span>];<span class="hljs-keyword">char</span> flag;&#125; data_2;<span class="hljs-keyword">float</span> score;&#125; data_1;<span class="hljs-keyword">bool</span> is_ok_or_not;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP复习笔记-Part II</title>
    <link href="/2020/08/23/OOP%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-Part-II/"/>
    <url>/2020/08/23/OOP%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-Part-II/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-4-组合、继承和模板"><a href="#Chapter-4-组合、继承和模板" class="headerlink" title="Chapter 4: 组合、继承和模板"></a>Chapter 4: 组合、继承和模板</h1><h2 id="4-1-组合"><a href="#4-1-组合" class="headerlink" title="4.1  组合"></a>4.1  组合</h2><p>语义角度：</p><p><strong>Aggregation</strong>: 子对象可以在没有父对象存在时存在。（车和轮子）</p><p><strong>composition</strong>: otherwise。（书和书页）</p><h3 id="4-1-1-初始化"><a href="#4-1-1-初始化" class="headerlink" title="4.1.1  初始化"></a>4.1.1  初始化</h3><p><strong>Note</strong>：</p><p>（1）const, 引用和成员对象都是在初始化列表里面初始化的。</p><p>（2）构造顺序与<strong>定义顺序</strong>相同，析构顺序倒过来。</p><h2 id="4-2-继承"><a href="#4-2-继承" class="headerlink" title="4.2  继承"></a>4.2  继承</h2><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200827155854867.png" srcset="/img/loading.gif" alt="image-20200827155854867"></p><h3 id="4-2-1-初始化"><a href="#4-2-1-初始化" class="headerlink" title="4.2.1  初始化"></a>4.2.1  初始化</h3><p>顺序：基类ctor -&gt; 派生类ctor，析构反过来。</p><p>可以通过using关键字继承基类的构造函数。（<em>Beginning C++17, P528</em>）</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200827160939643.png" srcset="/img/loading.gif" alt="image-20200827160939643"></p><p><strong>Note</strong>：ctor, dtor, “=”都默认不继承，不定义的话会自动合成。</p><h3 id="4-2-3-final-amp-override"><a href="#4-2-3-final-amp-override" class="headerlink" title="4.2.3  final &amp; override"></a>4.2.3  final &amp; override</h3><p><strong>final</strong>：禁用一个类的继承/一个成员函数的复写。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">final</span> &#123;</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span> </span>&#123;&#125;  &#125;;</code></pre><p><strong>override</strong>：确保是要override基类里面的虚函数。</p><h3 id="4-2-4-权限"><a href="#4-2-4-权限" class="headerlink" title="4.2.4  权限"></a>4.2.4  权限</h3><p>（1）private继承时通过using把基类中的public成员重新设置为public。</p><pre><code class="hljs C++"><span class="hljs-keyword">public</span>:<span class="hljs-keyword">using</span> Pet::eat;</code></pre><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200827162052342.png" srcset="/img/loading.gif" alt="image-20200827162052342"></p><p>（2）默认继承方式是private。</p><h3 id="4-2-5-重名问题"><a href="#4-2-5-重名问题" class="headerlink" title="4.2.5  重名问题"></a>4.2.5  重名问题</h3><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getDensity</span><span class="hljs-params">()</span></span>;  &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&#123;</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getDensity</span><span class="hljs-params">()</span></span>;  &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:</span> <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    C obj;    obj.getDensity(); <span class="hljs-comment">//WRONG!</span>        obj.A::getDensity(); <span class="hljs-comment">//RIGHT!</span>    <span class="hljs-keyword">static_cast</span>&lt;A&amp;&gt;(obj).getDensity();&#125;</code></pre><h3 id="4-2-6-虚基类"><a href="#4-2-6-虚基类" class="headerlink" title="4.2.6  虚基类"></a>4.2.6  虚基类</h3><p>为了解决以下问题：</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200827162832667.png" srcset="/img/loading.gif" alt="image-20200827162832667"></p><p>（CerealPack将有两份Common的拷贝）使用<strong>virtual</strong>即可避免。</p><h3 id="4-2-7-Name-Hiding"><a href="#4-2-7-Name-Hiding" class="headerlink" title="4.2.7  Name Hiding"></a>4.2.7  Name Hiding</h3><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Cat cat;    cat.sleep();  <span class="hljs-comment">//ERROR!sleep()(const/non-const) is hidden</span>&#125;</code></pre><p>解决方法：转发/using。</p><pre><code class="hljs C++"><span class="hljs-keyword">using</span> Pet::sleep;  <span class="hljs-comment">//多个重名的被同时publicize，想隐藏一部分可以再声明为private</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> Pet::sleep();&#125;</code></pre><h3 id="4-2-8-Upcasting"><a href="#4-2-8-Upcasting" class="headerlink" title="4.2.8  Upcasting"></a>4.2.8  Upcasting</h3><p>将派生类的引用/指针转换为基类的引用/指针。<strong>只在public继承的条件下有效。</strong></p><h3 id="4-2-9-Copy-Ctor-amp-Move-Ctor"><a href="#4-2-9-Copy-Ctor-amp-Move-Ctor" class="headerlink" title="4.2.9  Copy Ctor &amp; Move Ctor"></a>4.2.9  Copy Ctor &amp; Move Ctor</h3><p>在继承和复合中会自动生成，调用子对象和基类的copy ctor。</p><p>利用<strong>upcasting</strong>，可以这样写：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> :</span> <span class="hljs-keyword">public</span> B&#123;  A a;  C(<span class="hljs-keyword">const</span> C&amp; c) : B&#123;c&#125;, a&#123;c.a&#125; &#123;&#125;  C(C &amp;&amp;c) : B&#123;<span class="hljs-built_in">move</span>(c)&#125;, a&#123;<span class="hljs-built_in">move</span>(c.a)&#125;&#125;;</code></pre><p>执行顺序：先继承后复合。</p><h3 id="4-2-10-对象切片"><a href="#4-2-10-对象切片" class="headerlink" title="4.2.10  对象切片"></a>4.2.10  对象切片</h3><p>如果直接将派生类对象cast为基类对象（不是指针不是引用），派生类对象被切片，数据丢失。</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200827170140789.png" srcset="/img/loading.gif" alt="image-20200827170140789"></p><h3 id="4-2-11-多态"><a href="#4-2-11-多态" class="headerlink" title="4.2.11  多态"></a>4.2.11  多态</h3><p><strong>Note 1</strong> : <strong>virtual</strong>关键字只需要在声明时出现。</p><p><strong>Note 2</strong>：基类virtual派生类全virtual。</p><p><strong>Note 3</strong>：如果基类虚函数有缺省参数，而且你通过指针/引用调用该函数，得到的缺省值是基类中的。</p><h3 id="4-2-12-关键字typeid"><a href="#4-2-12-关键字typeid" class="headerlink" title="4.2.12  关键字typeid"></a>4.2.12  关键字typeid</h3><p><strong>头文件</strong>：<typeinfo>，与编译器相关。得到对象/类型的<strong>动态类型</strong>。</p><pre><code class="hljs C++"><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(<span class="hljs-keyword">double</span>).name() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">//"double"</span>Derived obj; Base&amp; ref = obj;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(ref).name() &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">//"Derived"</span></code></pre><h3 id="4-2-13-static-cast-again-amp-dynamic-cast"><a href="#4-2-13-static-cast-again-amp-dynamic-cast" class="headerlink" title="4.2.13  static_cast(again) &amp; dynamic_cast"></a>4.2.13  static_cast(again) &amp; dynamic_cast</h3><p>static_cast：</p><ul><li>是静态检查的，也就是说是在编译过程中检查。</li><li>也可以将基类转回派生类，但不安全！</li><li>C-style cast: (int)a 不安全！</li></ul><p>dynamic_cast：</p><ul><li>只能用在多态类型上（有至少一个虚函数）。</li><li>比static_cast安全（在运行时才进行转换，对指针转换不成功返回nullptr，对引用转换不成功停止程序、抛出异常）</li><li>可以进行crosscast：</li></ul><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200827172154206.png" srcset="/img/loading.gif" alt="image-20200827172154206"></p><h3 id="4-2-14-VTABLE-amp-VPTR"><a href="#4-2-14-VTABLE-amp-VPTR" class="headerlink" title="4.2.14  VTABLE &amp; VPTR"></a>4.2.14  VTABLE &amp; VPTR</h3><p>VTABLE：在编译期建立；</p><p>VPTR：在运行期建立。</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200827172439702.png" srcset="/img/loading.gif" alt="image-20200827172439702"></p><h3 id="4-2-14-抽象类"><a href="#4-2-14-抽象类" class="headerlink" title="4.2.14  抽象类"></a>4.2.14  抽象类</h3><p>有纯虚函数，不能定义对象。（所以不会发生切片）全部override了才能定义对象。</p><p>纯虚函数可以有界面（就算有界面也得override了）：</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200827172830303.png" srcset="/img/loading.gif" alt="image-20200827172830303"></p><h3 id="4-2-15-Virtual与ctor-dtor的关系"><a href="#4-2-15-Virtual与ctor-dtor的关系" class="headerlink" title="4.2.15  Virtual与ctor, dtor的关系"></a>4.2.15  Virtual与ctor, dtor的关系</h3><ul><li>ctor/dtor中调用虚函数，多态故障，会调用当前类的成员函数。（在其它成员函数中调用可行）</li><li>ctor不可以是virtual的（因为VPTR都还没有）</li></ul><ul><li>dtor可以是纯虚的，但需要定义函数体。</li><li>dtor一般都是虚的。（有别的虚函数就应当是虚的）</li></ul><p><strong>NOTE</strong>：多态需要额外开销。</p><h1 id="Chapter-5：设计模式"><a href="#Chapter-5：设计模式" class="headerlink" title="Chapter 5：设计模式"></a>Chapter 5：设计模式</h1><h2 id="5-0-OOP-Principle"><a href="#5-0-OOP-Principle" class="headerlink" title="5.0  OOP Principle"></a>5.0  OOP Principle</h2><ul><li>针对接口编程。</li><li>open-closed principle：对扩展开放，对修改封闭（增量开发原则）</li><li>single responsibility：分割任务，交给不同的对象。</li></ul><h2 id="5-1-Singleton-creational"><a href="#5-1-Singleton-creational" class="headerlink" title="5.1  Singleton(creational)"></a>5.1  Singleton(creational)</h2><p><strong>Dynamic Singleton</strong>：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">Instance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (instance_ == <span class="hljs-literal">nullptr</span>) &#123;            instance_ = <span class="hljs-keyword">new</span> Singleton();        &#125;        <span class="hljs-keyword">return</span> instance_;    &#125;<span class="hljs-keyword">private</span>:    Singleton() &#123;&#125;    Singleton(<span class="hljs-keyword">const</span> Singleton&amp;);    Singleton&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-keyword">const</span> Singleton&amp;);    ~Singleton();  <span class="hljs-comment">//禁止通过这里释放</span>    <span class="hljs-keyword">static</span> Singleton* instance_;&#125;</code></pre><h2 id="5-2-Adapter-structural"><a href="#5-2-Adapter-structural" class="headerlink" title="5.2  Adapter(structural)"></a>5.2  Adapter(structural)</h2><p>使用已有的类完成新类的书写。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        m_data.push_back(i);    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; m_data;&#125;;</code></pre><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828090159188.png" srcset="/img/loading.gif" alt="image-20200828090159188"></p><p><strong>class adapter</strong>：</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828090435000.png" srcset="/img/loading.gif" alt="image-20200828090435000"></p><p>private继承而非复合。</p><h2 id="5-3-Simple-Factory"><a href="#5-3-Simple-Factory" class="headerlink" title="5.3  Simple Factory"></a>5.3  Simple Factory</h2><p>把会改变的和不会改变的分开。</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828090859293.png" srcset="/img/loading.gif" alt="image-20200828090859293"></p><p>（1）一个产品类，有很多派生类。</p><p>（2）一个工厂类，制造这些产品。</p><p>（3）一个商店类，与实例化解耦。</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828091530112.png" srcset="/img/loading.gif" alt="image-20200828091530112"></p><p><strong>不满足open-closed principle</strong>。</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828091726959.png" srcset="/img/loading.gif" alt="image-20200828091726959"></p><h2 id="5-4-Factory-Method-creational"><a href="#5-4-Factory-Method-creational" class="headerlink" title="5.4  Factory Method(creational)"></a>5.4  Factory Method(creational)</h2><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828091925467.png" srcset="/img/loading.gif" alt="image-20200828091925467"></p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828092150998.png" srcset="/img/loading.gif" alt="image-20200828092150998"></p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828092221222.png" srcset="/img/loading.gif" alt="image-20200828092221222"></p><p>可以使用参数化：原有代码使用simple factory，新种类使用factory method。</p><h2 id="5-5-Absstract-Factory-creational"><a href="#5-5-Absstract-Factory-creational" class="headerlink" title="5.5  Absstract Factory(creational)"></a>5.5  Absstract Factory(creational)</h2><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828093018191.png" srcset="/img/loading.gif" alt="image-20200828093018191"></p><h2 id="5-6-Observer-creational"><a href="#5-6-Observer-creational" class="headerlink" title="5.6  Observer(creational)"></a>5.6  Observer(creational)</h2><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828093437987.png" srcset="/img/loading.gif" alt="image-20200828093437987"></p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828094035073.png" srcset="/img/loading.gif" alt="image-20200828094035073"></p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828094207286.png" srcset="/img/loading.gif" alt="image-20200828094207286"></p><h2 id="5-7-Strategy-behavioral"><a href="#5-7-Strategy-behavioral" class="headerlink" title="5.7  Strategy(behavioral)"></a>5.7  Strategy(behavioral)</h2><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828100704597.png" srcset="/img/loading.gif" alt="image-20200828100704597"></p><h2 id="5-8-Template-Method-behavioral"><a href="#5-8-Template-Method-behavioral" class="headerlink" title="5.8  Template Method(behavioral)"></a>5.8  Template Method(behavioral)</h2><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828103425435.png" srcset="/img/loading.gif" alt="image-20200828103425435"></p><p>以上两种方式的结合：</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828103730633.png" srcset="/img/loading.gif" alt="image-20200828103730633"></p><h2 id="5-9-Proxy（structural）"><a href="#5-9-Proxy（structural）" class="headerlink" title="5.9  Proxy（structural）"></a>5.9  Proxy（structural）</h2><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828104223431.png" srcset="/img/loading.gif" alt="image-20200828104223431"></p><h2 id="5-10-Command-State-behavioral"><a href="#5-10-Command-State-behavioral" class="headerlink" title="5.10  Command State(behavioral)"></a>5.10  Command State(behavioral)</h2><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828105105822.png" srcset="/img/loading.gif" alt="image-20200828105105822"></p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828105208408.png" srcset="/img/loading.gif" alt="image-20200828105208408"></p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828105314634.png" srcset="/img/loading.gif" alt="image-20200828105314634"></p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828105404982.png" srcset="/img/loading.gif" alt="image-20200828105404982"></p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828110043226.png" srcset="/img/loading.gif" alt="image-20200828110043226"></p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828110239072.png" srcset="/img/loading.gif" alt="image-20200828110239072"></p><p>State Pattern与其类似。</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828110336489.png" srcset="/img/loading.gif" alt="image-20200828110336489"></p><h1 id="Chapter-6：其它"><a href="#Chapter-6：其它" class="headerlink" title="Chapter 6：其它"></a>Chapter 6：其它</h1><h2 id="6-1-运算符重载"><a href="#6-1-运算符重载" class="headerlink" title="6.1  运算符重载"></a>6.1  运算符重载</h2><p><strong>方法一</strong>：成员函数</p><p><code>x @ y;</code>  相当于 <code>x.operator @ (y);</code></p><p><code>@ x;</code>  相当于  <code>x.operator @();</code>，也即<code>const TYPE&amp; operator ++()</code>。</p><p><code>x @;</code>  相当于 <code>x.operator @(0);</code> ，也即<code>const TYPE&amp; operator ++(int)</code>。</p><p><strong>方法二</strong>：友元函数</p><p>限制：用法不能变，不能定义新的运算符，不能改变运算符优先级，不能改变运算元个数，有些运算符不能重载（&lt;.&gt;, &lt;.*&gt;, &lt;::&gt;, &lt;?&gt;）</p><p><strong>friend</strong>关键字是为了访问类内的私有成员，如果不需要的话不一定需要加。</p><pre><code class="hljs C++"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">const</span> Integer&amp; <span class="hljs-keyword">operator</span>++(Integer&amp; a);<span class="hljs-keyword">friend</span> <span class="hljs-keyword">const</span> Integer <span class="hljs-keyword">operator</span>++(Integer&amp; a, <span class="hljs-keyword">int</span>);</code></pre><p>当左操作数不是自定义类型时，只能作为<strong>友元函数</strong>重载。</p><h2 id="6-2-流运算符"><a href="#6-2-流运算符" class="headerlink" title="6.2  流运算符"></a>6.2  流运算符</h2><pre><code class="hljs C++"><span class="hljs-built_in">cin</span> is istream, <span class="hljs-built_in">cout</span> is ostream<span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream &amp;output, <span class="hljs-keyword">const</span> Point&amp; <span class="hljs-built_in">point</span>) &#123;    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> output &lt;&lt;</span>    <span class="hljs-keyword">return</span> output;&#125;</code></pre><h2 id="6-2-“-”"><a href="#6-2-“-”" class="headerlink" title="6.2  “=”"></a>6.2  “=”</h2><p>有指针时自己定义。</p><pre><code class="hljs C++">TYPE&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-keyword">const</span> TYPE&amp; src)&#123;    <span class="hljs-keyword">if</span> (&amp;src != <span class="hljs-keyword">this</span>)&#123;  <span class="hljs-comment">//avoid self assignment</span>        <span class="hljs-comment">//assignment</span>    &#125;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;</code></pre><p>注意：</p><p>（1）返回引用；</p><p>（2）全部赋值，而不是传递指针。</p><h2 id="6-3-Move-Assignment"><a href="#6-3-Move-Assignment" class="headerlink" title="6.3  Move Assignment"></a>6.3  Move Assignment</h2><p>相当于 bitcopy + 原来的置空。</p><h2 id="6-4-函数调用运算符“（）”"><a href="#6-4-函数调用运算符“（）”" class="headerlink" title="6.4  函数调用运算符“（）”"></a>6.4  函数调用运算符“（）”</h2><p><strong>函数对象</strong>：一个特殊类的对象，这个特殊类带有重载过的函数调用运算符（<strong>一定以成员函数的方式重载</strong>）。在STL中常常使用。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FuncObj_Type</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">Return_Type <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(ParameterList)</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span>&#123;</span>    <span class="hljs-keyword">int</span> data;<span class="hljs-keyword">public</span>:    F(<span class="hljs-keyword">int</span> val) : data&#123;val&#125; &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">return</span> (x &gt; data);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    F f&#123;<span class="hljs-number">30</span>&#125;;    <span class="hljs-keyword">bool</span> res = f(<span class="hljs-number">43</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>在STL排序中</strong>：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">myfunction</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> (i&gt;j);&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myclass</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> (i&gt;j); &#125;&#125; myobject;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> myints[] = &#123;<span class="hljs-number">32</span>,<span class="hljs-number">71</span>,<span class="hljs-number">12</span>,<span class="hljs-number">45</span>,<span class="hljs-number">26</span>,<span class="hljs-number">80</span>,<span class="hljs-number">53</span>,<span class="hljs-number">33</span>&#125;;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myvector</span> <span class="hljs-params">(myints, myints+<span class="hljs-number">8</span>)</span></span>;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;        <span class="hljs-comment">//使用 &lt; 排序</span>    sort (myvector.<span class="hljs-built_in">begin</span>(), myvector.<span class="hljs-built_in">end</span>()+<span class="hljs-number">4</span>);        <span class="hljs-comment">//使用 comp</span>    sort (myvector.<span class="hljs-built_in">begin</span>(), myvector.<span class="hljs-built_in">end</span>(), myfunction);        <span class="hljs-comment">//使用函数对象</span>    sort (myvector.<span class="hljs-built_in">begin</span>(), myvector.<span class="hljs-built_in">end</span>(), myobject);    sort (myvector.<span class="hljs-built_in">begin</span>(), myvector.<span class="hljs-built_in">end</span>(), greater&lt;<span class="hljs-keyword">int</span>&gt;() );&#125;</code></pre><p><strong>在map类中</strong>：</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828115315942.png" srcset="/img/loading.gif" alt="image-20200828115315942"></p><p>可以定义一个比较类后，用比较类定义一个自动排序的map：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PntCmp</span>&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(cosnt Point&amp; pnt1, <span class="hljs-keyword">const</span> Point&amp; pnt2)</span> </span>&#123;&#125;&#125;<span class="hljs-keyword">typedef</span> <span class="hljs-built_in">map</span>&lt;Point, <span class="hljs-built_in">string</span>, PntComp&gt; PntSMap;</code></pre><p>注意：当map.find()未找到时，空元素会被添加进去。</p><p>注意：重载比较运算符时最好重载3个：&lt; , &gt;, ==。</p><p><strong>可以将函数对象作为参数，传到函数中。函数对象可以包含一些有用的成员函数。</strong></p><h2 id="6-5-模板"><a href="#6-5-模板" class="headerlink" title="6.5  模板"></a>6.5  模板</h2><p><strong>应当在头文件中定义。</strong></p><pre><code class="hljs C++"><span class="hljs-comment">// 函数模板：编译期间实例化</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-title">class</span> <span class="hljs-title">T2</span>, ...&gt;  //<span class="hljs-title">class</span> / <span class="hljs-title">typename</span>,</span><span class="hljs-class">    //类型标识符（<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>）不能重复，</span><span class="hljs-class">    //且每个类型标识符都应当在函数参数列表中出现</span><span class="hljs-class"><span class="hljs-title">ReturnType</span> <span class="hljs-title">FunctionName</span>(<span class="hljs-title">ParameterList</span>) &#123;</span>    <span class="hljs-comment">// Function Body</span>&#125;<span class="hljs-comment">// 特化：specialization</span><span class="hljs-keyword">template</span> &lt;&gt;<span class="hljs-keyword">void</span> sort&lt;<span class="hljs-keyword">char</span>*&gt;(<span class="hljs-keyword">char</span>** L, <span class="hljs-keyword">int</span> length) &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    sort&lt;<span class="hljs-keyword">int</span>&gt;(arr, <span class="hljs-number">8</span>);    sort(arr, <span class="hljs-number">8</span>);  <span class="hljs-comment">//implicit</span>&#125;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">// 类模板</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> = <span class="hljs-title">int</span>, <span class="hljs-title">int</span> <span class="hljs-title">max</span> = 10&gt;   //<span class="hljs-title">int</span>/<span class="hljs-title">uint</span>/<span class="hljs-title">long</span>等可以转换为<span class="hljs-title">int</span>的作为参数</span><span class="hljs-class">     //在编译期间被实例化为常数，可以有缺省值</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Stack</span>&#123;</span>    T arr[];&#125;<span class="hljs-comment">// 类模板可以继承 普通类 / 实例化的模板类</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Sortable_list</span> :</span> <span class="hljs-keyword">public</span> Stack&lt;T&gt; &#123;    &#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Stack&lt;<span class="hljs-keyword">int</span>&gt; intStack;&#125;</code></pre><p><strong>NOTE</strong>：</p><p>（1）因为模板实例化会复制代码，所以对于不需要类参数的代码部分应当做成基类。</p><p>（2）泛型编程（<em>generic programming</em>）：与数据类型无关的编程。</p><p>（3）元编程（<em>meta programming</em>）：编译期间计算。</p><p>（4）可以在函数对象中使用模板：</p><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">IsPass</span> &#123;</span>    T _p;<span class="hljs-keyword">public</span>:    IsPass(T p) : _p&#123;p&#125; &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(T&amp; s)</span> </span>&#123; <span class="hljs-keyword">return</span> s &gt;= _p; &#125;&#125;</code></pre><p><strong>谓词</strong>：函数对象/指针/lambda表达式，返回true/false。</p><h2 id="6-6-迭代器模式"><a href="#6-6-迭代器模式" class="headerlink" title="6.6  迭代器模式"></a>6.6  迭代器模式</h2><blockquote><p> 模板    ：解耦 算法 和 数据类型；</p></blockquote><blockquote><p> 迭代器：解耦 算法 和 数据结构类型；</p></blockquote><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828131704156.png" srcset="/img/loading.gif" alt="image-20200828131704156"></p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828131718351.png" srcset="/img/loading.gif" alt="image-20200828131718351"></p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828132055991.png" srcset="/img/loading.gif" alt="image-20200828132055991"></p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828132627152.png" srcset="/img/loading.gif" alt="image-20200828132627152"></p><h2 id="6-7-一些有用的STL"><a href="#6-7-一些有用的STL" class="headerlink" title="6.7  一些有用的STL"></a>6.7  一些有用的STL</h2><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200828133622250.png" srcset="/img/loading.gif" alt="image-20200828133622250"></p>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
      <tag>Notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diary: 2020/08</title>
    <link href="/2020/08/23/Diary-2020-08/"/>
    <url>/2020/08/23/Diary-2020-08/</url>
    
    <content type="html"><![CDATA[<h2 id="2020-8-23"><a href="#2020-8-23" class="headerlink" title="2020.8.23"></a>2020.8.23</h2><p>昨天到校啦。</p><p>这学期决定尽量每天都写日记，所以还是开了这篇博客，尽管8月已经快要结束。我呢，记事实在是非常不行（这也是要写日记的原因），所以8月的前二十多天对我来说已经完全凭空消失。大概记得的主要事件是疯狂肝大作业，去南京，移植大作业，去抚仙湖，吃好多好吃的，还有去音乐会。但也懒得再回忆其中细节了，我并不享受旧事重议。</p><p>昨天赶到北京，地理位置上是北漂，天气条件却完全相反，在昆明好久没见蚊子的我在宿舍一下午加一晚上就被咬了好多包，怎一个惨字了得。在宿舍边收衣柜边吃零食，边洗衣服边吃水果，一下午加一晚上就宅着度过了。</p><p>第二天早上躺床不动，直到下午两点才爬起来。但我居然认为这其中有积极的意味：上学期的经验告诉我，比起每件事伊始时戴上热情的假面积极应对，在开始时就让自己暴露出最原始的态度和缺陷，反而更有利于建立良好的解决和应对机制。所以开学第一课：在学校也并不一定会比在家积极，关键还是处在the presence of others中，所以少待宿舍啦。</p><p>两件琐事：脉动新口味好喝，至今还没去过食堂满心期待。</p><p><strong>最近的主要任务：继续收拾宿舍，复习OOP准备考试，认真对待小学期不拖ddl，总结一下LiquidFun项目学到的东西，&amp;早睡早起约人打球发展平衡的生活。</strong></p><p>重要的小感想：</p><p>我在过去的十数年（即将演变为数十年）间从未因为离别产生任一程度的感伤，这种特定的情感始终隐藏在我认知的迷雾后。过去的我更加好强，脑海里唯一占主导地位的价值观便是要去征服、探索、挑战然后成功，所以每次离别的终点意味都被我自动消解，我只能从中看到新征程的开端，也因此只为了每次离别感到热血沸腾。在今年，终于在今年，很难说是哪一个时刻我才真正开始认同我其它那些柔软易感的部分，然后终于自动对所有成功学鸡汤免疫（才18，这个转变好像太早了点儿）。这一次离开家时我也终于感到了一点点不舍，因为爸爸妈妈都很棒，昆明很好待，走了就吃不到爷爷奶奶做的饭了。</p><p>所以，郑重地感谢自己，在2020年终于学会了同时拥有过去和未来。17-18岁这一年灰暗血腥得不像话，才促使“快乐生活”变成我18岁以来思考的最重要的课题，于是18-19岁这一年真的学会了很多。不敢说以后怎样，但至少此刻我已经起死回生（是的，我丝毫不觉得这个成语夸张）。</p><p>另一个小感想：</p><p>开学以来感到最幸福的瞬间如下：在晚上九点出门去猫超买饮料时，看到紫操上跑步的散步的谈恋爱的人来人往。一方面我是为我重新获得了生活的自由性（尤其在饮食上）感到了幸福；另一方面，紫操上形色各异的人群重新让我感到了生活的流动和世界的广阔，我在刹那间仿佛身处暗礁林立、风浪涌动的海域，其中漩涡的跌宕和危险让我感到酒醉般地着迷。</p><blockquote><p>“斯特里克兰德太太是一个招人喜爱的女人，她很爱她的丈夫。我想象着这一对夫妻的生活，不受任何灾殃祸变的干扰，诚实、体面，两个孩子更是规矩可爱……这一定是时间无数对夫妻的故事。这种生活模式给人以安详亲切之感。它使人想到一条平静的小河，蜿蜒流过绿茸茸的牧场，与郁郁的树荫交相掩映，直到最后泄入烟波浩渺的大海中。但是大海总是那么平静，总是沉默无言、不动声色，你会突然感到一种莫名的不安。也许这只是一种我自己的怪想法，我总觉得大多数人这样度过一生好像欠缺一点什么。我承认这种生活的社会价值，我也看到了它的井然有序的幸福，但是我的血液里却有一种强烈的愿望，渴望一种更狂放不羁的旅途。这种安详宁静的快乐好像有一种叫我惊惧不安的东西。<strong>我的心渴望一种更加惊险的生活。只要在我的生活中能有变迁——变迁和无法预见的刺激，我是准备踏上怪石嶙峋的山崖，奔赴暗礁满布的海滩的。</strong>”</p><p align="right">——毛姆：《月亮与六便士》</p></blockquote><h2 id="2020-8-24"><a href="#2020-8-24" class="headerlink" title="2020.8.24"></a>2020.8.24</h2><p>啊，在图书馆最尴尬的两件事：</p><p>（1）耳机没插好外放出声音。（2）肚子饿到咕咕叫。</p><p>今天稍微有点社交焦虑（可能是因为好久没有处在人群这么密集的环境下了），面对迎面而来的人群、耳边还能听清他们说的话时尤为严重。所以就认真看了看云，嗯，今天的云像咖啡拉花。可能是因为长期没人在学校，校园内的昆虫明显比以前多，走去食堂路上看见好几只西瓜虫和一只蜗牛。</p><p>下次出门还是要戴好耳机。还有，12：00从食堂出来的时候就看见排了好长的队，等所有学生都返校后还能吃上饭吗？同理，图书馆感觉也不能支撑开学后的人流量啊…</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LiquidFun源码学习笔记</title>
    <link href="/2020/07/15/LiquidFun%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/07/15/LiquidFun%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>7/15： 越学越觉得迷糊……我到底知道些什么？</p></blockquote><h2 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h2><ul><li>一个</li></ul><h2 id="LiquidFun"><a href="#LiquidFun" class="headerlink" title="LiquidFun"></a>LiquidFun</h2><ul><li>若报错：在未调用glutInit时就使用glutReshapeFunc，可以尝试修改属性–&gt; C/C++ –&gt; 预处理器。</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li><code>(void)(argc);</code> ：有些编译器会在一个变量从头到尾没被使用时发出warning。此语句用于避免此类警告信息（并且说明这个变量不会使用）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
      <category>LiquidFun</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
      <tag>LiquidFun</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LiquidFun文档简记-Part II</title>
    <link href="/2020/07/14/LiquidFun%E6%96%87%E6%A1%A3%E7%AE%80%E8%AE%B0-Part-II/"/>
    <url>/2020/07/14/LiquidFun%E6%96%87%E6%A1%A3%E7%AE%80%E8%AE%B0-Part-II/</url>
    
    <content type="html"><![CDATA[<h2 id="3-Particle-Module"><a href="#3-Particle-Module" class="headerlink" title="3.  Particle Module"></a>3.  Particle Module</h2><p>Particle Module应该是LiquidFun与Box2D的主要不同部分。它使用户能够创造、操控液体或软性（可变形）物体。它允许你创造、摧毁具有许多不同行为和性质的粒子，并且提供了控制它们的多种方式。这个模块允许你以离散方式/成组方式定义粒子，以帮助你有效地操控大量粒子。</p><h3 id="3-1-粒子"><a href="#3-1-粒子" class="headerlink" title="3.1  粒子"></a>3.1  粒子</h3><p><strong>粒子是圆形的，且是粒子系统中最小的单位物质。</strong>在默认设置下，一个粒子的行为像液体那样。当然，你可以通过设置<code>behavioral flag</code>来给粒子/粒子组赋予不同的行为（这在下面的Particle Behaviors一节中有详细介绍）。</p><p>b2Particle.h包含了指明<code>behavior value</code>的enum变量b2ParticleFlag。</p><h3 id="3-2-粒子系统"><a href="#3-2-粒子系统" class="headerlink" title="3.2  粒子系统"></a>3.2  粒子系统</h3><p>粒子们生活的“世界”被称作粒子系统。一个粒子系统指代的是很多决定了粒子如何互相作用、如何与world作用的物理系数，如默认粒子半径、弹性(elasticity)、粘性（viscosity）。更为详细的信息可以在b2ParticleSystemDef这个结构体的定义中看到。（太长了，这里不摘录了）</p><p>你可以通过如下方式创造一个粒子系统：</p><pre><code class="hljs C++"><span class="hljs-keyword">const</span> b2ParticleSystemDef particleSystemDef;m_particleSystems[<span class="hljs-number">0</span>] = m_world-&gt;CreateParticleSystem(&amp;particleSystemDef);</code></pre><p>你也可以创造不止一个粒子系统。</p><p>一般来说你都不需要改变particleSystemDef的默认值/创造多个粒子系统，但某些情况下你也可能发现这两个功能很管用。例如：将粒子分成多个粒子系统后可以提高模拟效率（只模拟可见系统，将其它系统放置在paused状态）。在Testbed中提供了一个两个系统分别影响一个刚体、彼此不互动的例子。</p><h3 id="3-3-粒子组"><a href="#3-3-粒子组" class="headerlink" title="3.3  粒子组"></a>3.3  粒子组</h3><p>你能设置的粒子组的性质其中有部分与离散粒子的性质相同：行为、位置、线速度、颜色。也有一些性质是粒子组专属的：转动角度、转动速度、力量。这在b2ParticleGroup.h里可以看到。</p><p><strong>离散粒子 vs. 粒子组</strong></p><p>除了一个例子以外，单个粒子和粒子组之间都没有显著的功能差别。这个例子就是刚体粒子：由于使粒子变刚性的内部算法的特性远古，刚体粒子必须以群体的方式定义。</p><p>粒子组也有如下几个好处：首先，可以自动创造/摧毁大量粒子；其次，可以方便的给它们赋予同样的性质。</p><h3 id="3-4-在世界中进行时间推演（粒子迭代）"><a href="#3-4-在世界中进行时间推演（粒子迭代）" class="headerlink" title="3.4  在世界中进行时间推演（粒子迭代）"></a>3.4  在世界中进行时间推演（粒子迭代）</h3><p>粒子处理器（solver）可以在一个time step中迭代多次。迭代多次将提高粒子模拟的稳定性和准确性。然而，迭代次数越多，所需的处理器周期也就越多。</p><p>这些周期的时间成本几乎是线性的：迭代次数翻倍将导致<code>b2ParticleSystem::Solve</code>的周期时间成本翻倍。</p><p>你应当使用<code>b2World::Step</code>里面的<code>particleIterations</code>参数来调整迭代次数，默认值是1。</p><p>你可以通过实验找到<code>particleIterations</code>的最佳值，可以通过<code>b2CalculateParticleIterations</code>或者<code>b2World::CalculateReasonableParticleIterations</code>来估计迭代次数的合理值，但这两个函数都相当简化，仅应当被视作估计的起点。</p><p>如果你的模拟看起来过于热情洋溢/你模拟中的粒子正在穿过contact，你应当适当增加迭代次数。</p><p>注意到：随着迭代次数的增加，在高度压缩的粒子上压力的作用也会愈发明显（也就是说，粒子变得越来越不可压缩了）。</p><blockquote><p>注：为了模拟的稳定性、并且防止过度的相互渗透，粒子模拟为粒子指定了强制性的<strong>最大速度</strong>：</p><p><code>particle_diameter / (particle_iterations * b2World::Steps&#39; dt)</code>。</p></blockquote><h3 id="3-5-创造-摧毁单个粒子"><a href="#3-5-创造-摧毁单个粒子" class="headerlink" title="3.5  创造/摧毁单个粒子"></a>3.5  创造/摧毁单个粒子</h3><p><strong>创造离散粒子</strong>：</p><pre><code class="hljs C++">b2ParticleDef pd;pd.flags = b2_elasticParticle; pd.color.Set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>); pd.Position.Set(i, <span class="hljs-number">0</span>);<span class="hljs-keyword">int</span> tempIndex = m_particleSystem-&gt;CreateParticle(pd);</code></pre><p>粒子的列表是自密实的。因此，CreateParticle返回的指标在一个更低指标的粒子（组）被删除时就会失效。</p><p><strong>摧毁粒子</strong>：</p><p>摧毁时请使用如下无返回值的函数：</p><p><code>m_particleSystem-&gt;DestroyParticle(tempIndex);</code></p><p><strong>粒子的生命周期</strong>：</p><p>粒子除了被手动删除外，还可能由于既定的生命周期过期/由于年龄过大被删除。</p><p>如下语句将让系统根据年龄顺序追踪粒子以进行删除：</p><pre><code class="hljs C++">m_particleSystem-&gt;SetParticleDestructionByAge(<span class="hljs-literal">true</span>);</code></pre><p>一个粒子由于年龄而死有两种原因：</p><p>（1）超过预设的生命周期，过期了。如下程序设置了粒子的生命周期（介于min和max之间的随机数），index制定了被赋予该生命周期的粒子数：</p><pre><code class="hljs C++">m_particleSystem-&gt;SetParticleLifetime(index, Random() * (k_particleLifetimeMax - k_particleLifetimeMin) + k_particleLifetimeMin);</code></pre><p>（2）在程序中，用户预设了同一时间能存在的粒子数的最大值，并且告诉系统根据年龄追踪粒子，则粒子会通过追杀多余粒子的方式保持粒子总数恒定，这个顺序是通过年龄顺序决定的，老粒子会先被暗杀。通过如下语句设置粒子最大数：</p><p><code>m_particleSytem-&gt;SetMaxParticleCount(k_maxParticleCount);</code></p><p>这可以在Testbed的Faucet一例中看到。</p><h3 id="3-6-困住的粒子"><a href="#3-6-困住的粒子" class="headerlink" title="3.6  困住的粒子"></a>3.6  困住的粒子</h3><p>粒子如果在特定地方卡住，就会成为障碍，需要被清除/换位置。如果一个粒子在用户指定数目的粒子迭代过程中始终与两个以上的平面保持接触，就会被系统判定为卡住。一旦被判定卡住后，你可以通过实现你自己的函数来判断是不是真的卡住了，并且处理卡住的粒子。</p><p>既然函数是用户实现的，用户在决定如何认定粒子卡住上就有了自主选择权。例如，对于一个正在穿过管道的球来说，它可能会与多边的墙发生碰撞，但用户可以通过自己定义的函数认定这个球没有卡住（只要这个球在正常运动）。另一方面，你也可以使用这样的判定依据：即使粒子在运动，但只要它卡在一个特定的空间范围内，我就认定它被卡住了。</p><p>如下例子中，用户建立了一个sensor fixture的全局数组，覆盖了所有可能出现卡壳粒子的区域。用户在每一步都会通过传感器检查所有系统给出的可能卡住的粒子，将任何一个处在危险区域的粒子删除：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyStuckParticlesInSensors</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Fixture* <span class="hljs-keyword">const</span> *sensors, int32 num)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">const</span> int32 stuck = gParticleSyste-&gt;GetStuckCandidateCount();    <span class="hljs-keyword">if</span>(stuck &gt; <span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">const</span> int32 *candidates = gParticleSystem-&gt;GetStuckCandidates();        <span class="hljs-keyword">const</span> b2Vec2 *positions = gParticleSystem-&gt;GetPositionBuffer();        <span class="hljs-keyword">for</span> (int32 j = <span class="hljs-number">0</span>; j &lt; num; ++j)        &#123;            <span class="hljs-keyword">if</span>(sensors[j]-&gt;TestPoint(<span class="hljs-built_in">position</span>))            &#123;                gParticleSystem-&gt;DestroyParticle(particle);            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">//连续5次迭代以上同时接触多个面的粒子进入名单</span>gParticleSystem-&gt;SetStuckThreshold(<span class="hljs-number">5</span>);gWorld-&gt;Step(gTimeStep, gVelocityIterations, gPositionIterations);<span class="hljs-comment">//检查</span>DestroyStuckParticlesInSensors(gProblemAreaSensors, gNumSensors);</code></pre><h3 id="3-7-创建-删除粒子组"><a href="#3-7-创建-删除粒子组" class="headerlink" title="3.7  创建/删除粒子组"></a>3.7  创建/删除粒子组</h3><p>一个粒子组的生命开始于一个有形状的容器中。创建顺序如下：</p><p>（1）指定一个shape；</p><p>（2）创造一个b2ParticleGroupDef-struct对象；</p><p>（3）指定粒子的行为和属性；</p><p>（4）使用指定函数创造粒子组。</p><p>如下的程序段创造了五组颜色不同、盒子形状的粒子：</p><pre><code class="hljs C++">b2PolygonShape shape;shape.SetAsBox(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);b2ParticleGroupDef pd;pd.shape = shape;pd.flags = b2_elasticParticle;pd.angle = <span class="hljs-number">-0.5f</span>;pd.angularVelocity = <span class="hljs-number">2.0f</span>;<span class="hljs-keyword">for</span>(int32 i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;    pd.<span class="hljs-built_in">position</span>.Set(<span class="hljs-number">10</span> + <span class="hljs-number">20</span> * i, <span class="hljs-number">40</span>);    pd.color.Set(i * <span class="hljs-number">255</span>/ <span class="hljs-number">5</span>, <span class="hljs-number">255</span> - i * <span class="hljs-number">255</span>/<span class="hljs-number">5</span>, <span class="hljs-number">128</span>, <span class="hljs-number">255</span>);    m_particleSystem-&gt;CreateParticleGroup(pd);&#125;</code></pre><p>为了摧毁粒子组，触发如下函数：</p><p><code>DestroyParticles(bool callDestructionListener);</code></p><p>这样的话，当组中没有粒子时，粒子组就会自动被摧毁（若<code>b2_particleGroupCanBeEmpty</code>变量在组的flags中未经设置）。</p><p>下面的这个粒子将粒子系统中的所有粒子摧毁：</p><pre><code class="hljs C++">b2ParticleGroup* group = m_particleSystem-&gt;GetParticleGroupList();<span class="hljs-keyword">while</span>(group)&#123;    m_particleSystem-&gt;SetGroupFlags(m_particleSystem-&gt;GetGroupFlags() &amp; ~b2_particleGroupCanBeEmpty);    group-&gt;DestroyParticles(<span class="hljs-literal">false</span>);    group = group-&gt;GetNext();&#125;<span class="hljs-comment">///(?)不懂欸</span></code></pre><h3 id="3-8-粒子行为"><a href="#3-8-粒子行为" class="headerlink" title="3.8  粒子行为"></a>3.8  粒子行为</h3><h4 id="3-8-1-对粒子组而言"><a href="#3-8-1-对粒子组而言" class="headerlink" title="3.8.1  对粒子组而言"></a>3.8.1  对粒子组而言</h4><p>使用<code>b2ParticleGroupFlag</code>这个enum设置，分以下两种：</p><p><strong>（1）Solid</strong>：</p><p>固体的粒子组将阻止其它物体嵌入它的内部。如果任何物体尝试穿透它，固体粒子组将把物体推回到自己的表面。</p><p>固体粒子组同样有很强的斥力，在你希望一个物体在表面上发生超常有弹力的碰撞时很有用（如壁球撞到墙上）。</p><p><code>pd.groupFlags = b2_solidParticleGroup;</code></p><p><strong>(2) Rigid</strong></p><p>刚体粒子组的形状不会发生改变，即使当与其它物体碰撞的时候也是如此。使用刚体粒子组与直接使用刚体相比有如下几个好处：</p><ul><li><p>可以只删除组的一部分：</p><ul><li>例如，一颗子弹打过后，将在盒型粒子组里产生一个洞；</li></ul></li><li><p>和其它组融合：</p><ul><li>例如，先创造三个圆形的粒子组，再把它们合并拼成一个雪人儿；</li></ul></li></ul><p><code>pd.groupFlags = b2_rigidParticleGroup;</code></p><h4 id="3-8-2-对单个粒子而言："><a href="#3-8-2-对单个粒子而言：" class="headerlink" title="3.8.2  对单个粒子而言："></a>3.8.2  对单个粒子而言：</h4><p>使用b2ParticleFlag这个enum。注意到不同的粒子行为所需的时间成本不同。</p><p><strong>（1）Elastic（弹性）</strong></p><p>弹性粒子会变形，与刚体碰撞的时候会弹跳。</p><p><code>pd.flags = b2_elasticParticle;</code></p><p>在Testbed中的“Elastic Particles”中，绿圈圈和蓝盒子就是由弹性粒子组成的。</p><p><strong>（2）Color-mixing（混色）</strong></p><p>混色粒子会从与其碰撞的粒子中蘸取一部分颜色。假设两个碰撞粒子中只有一个是color-mixing的，那么另一个粒子会保持原色。</p><p>混色是这样计算的：</p><ul><li><p><code>deltaColor = colorMixingStrength * (B&#39;s color - A&#39;s color);</code></p></li><li><p><code>A&#39;s color += deltaColor</code>;</p><p><code>B&#39;s color -= deltaColor;</code></p></li></ul><p>注意到若第二步中结果出现负数，会被改换为绝对值；若结果&gt;255，会被模掉255。</p><p><code>pd.flags = b2_colorMixingParticle;</code></p><p>在Testbed的surface tension这一demo中可以看到。</p><p><strong>（3）Powder（粉末）</strong></p><p>粉末粒子会产生分散效果，就像灰尘/沙子那样。这在sparky这个demo中可以看到。</p><p><code>pd.flags = b2_powderParticle;</code></p><p><strong>（4）Spring（弹簧）</strong></p><p>弹簧粒子们的行为就好像它们通过弹簧<strong>成对</strong>连接那样。每个粒子都与它在创造时离得最近的粒子相连，相连之后就不会再换搭档。将两个粒子分离的外力越大，外力撤销时它们互相碰撞的力就越大。不管粒子之间离得有多远，弹簧都不会断。</p><p><code>pd.flags = b2_springParticle;</code></p><p>这在elastic particles里面的红圈圈可以看到。</p><p><strong>（5）Tensile（可伸长的）</strong></p><p>可拉长粒子是用于创造表面张力/液体物体上拉紧后弯曲这一效果的。它可以用于创造，例如，水滴上的表面张力。</p><p>一旦张力被打破，粒子就会像弹性粒子那样弹跳，但同样也会继续彼此吸引，因此在弹跳过程中很可能成簇。</p><p><code>pd.flags = b2_tensileParticle;</code></p><p>这可以在surface tension这一个demo中看到。</p><p><strong>（5）Viscous（黏性）</strong></p><p>黏性粒子展现了附着感/粘稠感，例如油。</p><p><code>pd.flags = b2_viscousParticle;</code></p><p>这在Liquid Timer这个demo中能看到。</p><p><strong>（6）Static Pressure（静态压力）</strong></p><blockquote><p>静压：物体液体相对静止时，液体对物体产生的压力。</p></blockquote><p>粒子是容易受到压缩的。例如，当粒子被倒进一个容器里，底部粒子之间的排列会更紧密。</p><p>静压粒子将这种区别抹去：组中的每个粒子收到的压力都相同。</p><p><code>pd.flags = b2_staticPressureParticle;</code></p><p><strong>（7）Wall（墙）</strong></p><p>墙粒子是静态的，永远不动，即使发生碰撞也如此。</p><p><code>pd.flags = b2_WallParticle;</code></p><p><strong>（8）Barrier（障碍）</strong></p><p>固体/刚体粒子并不是内在地防止了tunneling：高速运动的粒子是可能穿过它们的。障碍粒子与其它粒子配合使用，可以使得粒子组tunneling-free。这在以下情景有用：确保液体粒子不会从墙粒子组成的容器中漏出去。</p><p>障碍粒子仅仅能阻止它们栖居的粒子组发生穿透，并不能防止粒子跑到两组粒子中间（即使组的位置让它们看起来像是相邻的）。</p><p>你可以把障碍粒子与elastic/spring/wall粒子一起用。</p><pre><code class="hljs C++">pd.flags = b2_WallParticle | b_barrierParticle;pd.groupFlags = b2_solidParticleGroup;</code></pre><p><strong>（9）Zombie（僵尸）</strong></p><p>僵尸粒子在你想要一步摧毁多个粒子的时候比较管用。所有被你设置成僵尸的粒子都会在solver的同一次迭代中同时被摧毁。这将提高性能（所需的时间与删除单个粒子的时间相同）。</p><p><code>group-&gt;GetFlagsBuffer()[i] |= b2_zombieParticle;</code></p><p><strong>注意到，使用 | 可以将多个行为特征赋予给一个粒子（组）。</strong></p><p><code>pd.groupFlags = b2_solidParticleGroup | b2_rigidParticleGoup;</code></p><p>若要使得组既具备组专属的特征、又有粒子的特征，使用两个语句：</p><pre><code class="hljs C++">pd.flags = b2_elasticParticle;pd.groupFlags = b2_solidParticleGroup;</code></pre><h3 id="3-9-粒子属性"><a href="#3-9-粒子属性" class="headerlink" title="3.9  粒子属性"></a>3.9  粒子属性</h3><p><strong>（1）Color-颜色</strong></p><p><code>pd.color.Set(r, g, b, a);</code></p><p>分别为red, green, blue, opacity，值都在0-255之间。</p><p><strong>（2）Size-大小</strong></p><p>使用小粒子时要记住两点：</p><ul><li><p>对于粒子组来说，粒子的大小可能会影响性能。这是因为粒子大小与组成组的粒子个数成反比，而粒子越多效率越低。</p><p><code>m_particleSystem-&gt;SetRadius(r);</code></p><p>r为&gt;0.0f的float32值，默认值为1.0f。</p></li><li><p>小粒子也可能在爆炸等场景里会出现不可预测的行为（违反动量守恒定律）。通过减低gravity scale降低这些粒子的速度可能会让它们稳定下来。</p><p><code>m_particleSystem-&gt;SetGravityScale(g);</code></p><p>g是一个&gt;0.0f的float32值，默认为1.0f。</p></li></ul><p>还要注意的是，调整solver每步进行的粒子迭代数也可能会影响重力在粒子上的作用。迭代次数越大，对重力的抵抗就会越大。增加迭代次数的一个重要理由就是防止提及缩小（由重力导致的压缩）。</p><p><strong>（3）Position（位置）</strong></p><p><code>pd.position.Set(x,y);</code></p><p>x, y是粒子组平移的世界坐标。</p><p><strong>（4）Velocity（速度）</strong></p><p>对离散粒子来说，使用以下语句：</p><p><code>pd.velocity.Set(x,y);</code></p><p>x, y分别为沿x, y轴的速度。</p><p>对粒子组来说，使用如下语句：</p><pre><code class="hljs C++">pd.linearVelocity.Set(x,y);pd.angularVelocity = aV;</code></pre><p>x, y分别为沿x, y轴的速度，aV为组的旋转速度（aV rad/s）。</p><p><strong>（5）Angles（角度）（专属于粒子组）</strong></p><p><strong>仅仅对rigid粒子组有用。</strong>这指明了粒子组倾斜的角度，用弧度表示，默认值为0。</p><p><code>pd.angle = a;</code></p><p><strong>（6）Strength（力量）（专属于粒子组）</strong></p><p>力量描述了粒子组的凝聚力，s为介于0.0（完全不凝聚）与1.0（非常凝聚）之间的值，默认为1.0。</p><p><code>pd.strength = s;</code></p><h3 id="3-10-使用OpenGL进行渲染"><a href="#3-10-使用OpenGL进行渲染" class="headerlink" title="3.10  使用OpenGL进行渲染"></a>3.10  使用OpenGL进行渲染</h3><p>粒子模块提供了通过OpenGL进行方便渲染的方法。</p><p>每种粒子性质都住在一个连续的记忆缓冲区里。如下表格提供了一个存储的的视觉展示。</p><p><img src="C:%5CUsers%5Cybr19%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200714093359007.png" srcset="/img/loading.gif" alt="image-20200714093359007"></p><p>OpenGL可以在渲染的时候直接使用这些缓冲区。在这个例子中，OpenGL 1.1会使用glVertexPointer和glColorPointer从存储中得到这些值。OpenGL 2.0会使用glVertexAttribPointer。</p><p>OpenGL可以渲染单独粒子/粒子组。</p><h3 id="3-11-样本应用"><a href="#3-11-样本应用" class="headerlink" title="3.11  样本应用"></a>3.11  样本应用</h3><p>LiquidFun提供的样本中有两个应用展示了这个库的能力。</p><p>Testbed提供了大量的demo，展示了不同类型的粒子行为。有些demo是只能看的，有些demo是可以互动的。</p><p>EyeCandy只能在Android上运行，且提供了两份：它提供了一个简单的在Android上使用LiquidFun的例子，并且试图展示她在移动硬件上优秀的液体着色器。</p><p>运行程序时，你可以通过倾斜屏幕溅出液体，也可以通过点击屏幕切换不同的着色器。</p><h2 id="4-Loose-Ends"><a href="#4-Loose-Ends" class="headerlink" title="4.  Loose Ends"></a>4.  Loose Ends</h2><h3 id="4-1-用户数据"><a href="#4-1-用户数据" class="headerlink" title="4.1  用户数据"></a>4.1  用户数据</h3><p>b2Fixture, b2Body, b2Joint这几个类都允许你通过一个空指针连接你的用户数据，这在你检查LiquidFun的数据结构、决定它们怎么与你游戏引擎中的对象连接是很有用的。</p><p>例如，通常你都会把你的主角的指针与它身上的物体连接。这会形成循环引用（有actor能找到body，有body能找到actor）。</p><pre><code class="hljs C++">GameActor* actor = GameCreateActor();b2BodyDef bodyDef;bodyDef.userData = actor;actor-&gt;body = box2Dworld-&gt;CreateBody(&amp;bodyDef);</code></pre><p>以下是几个你需要用户数据的例子：</p><p>（1）通过碰撞数据对主角造成一定的伤害；</p><p>（2）如果用户到达一个沿坐标轴的盒子里时播放一个编排好的事件；</p><p>（3）当LiquidFun告知你需要摧毁一个joint的时候获得一个游戏结构。</p><p>注意到用户数据是自选的，放啥都行，但应该始终保持一致。例如，如果你想在一个物体上存储一个actor的指针，就应该在所有物体上都存放一个actor的指针。</p><p>默认情况下，用户数据指针都是空的。</p><p>对于fixture来说，你可以考虑使用用户数据结构，来存放你所需要的游戏信息，例如材料、效果的链接、声音的链接。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FixtureUserData</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> materialIndex;    ...&#125;FixtureUserData myData = <span class="hljs-keyword">new</span> FixtureUserData;myData-&gt;materialIndex = <span class="hljs-number">2</span>;b2FixtureDef fixtureDef;fixtureDef.userData = myData;  <span class="hljs-comment">///</span>b2Fixture* fixture = body-&gt;CreateFixture(&amp;fixtureDef);...<span class="hljs-keyword">delete</span> fixture-&gt;GetUserData();fixture-&gt;SetUserData(<span class="hljs-literal">NULL</span>);body-&gt;DestroyFixture(fixture);</code></pre><h3 id="4-2-未被指明的摧毁（implicit-destruction）"><a href="#4-2-未被指明的摧毁（implicit-destruction）" class="headerlink" title="4.2  未被指明的摧毁（implicit destruction）"></a>4.2  未被指明的摧毁（implicit destruction）</h3><p>LiquidFun不使用引用计数，所以当你摧毁一个物体的时候它就真的没了。使用一个被摧毁物体的指针产生的结果各种各样，最大的可能性就是你的程序会崩。为了帮助解决这个问题，debug build memory manager fills使用FDFDFDFD来摧毁实体。</p><p>如果你摧毁了一个LiquidFun的实体，那么你就必须负责把所有它的引用也给删除。如果你对一个物体有多次引用，你最好考虑实现一个处理类（handle class）来处理这些指针。</p><p>当你使用LiquidFun你会创造、摧毁许多物体、形状、关节，大部分这些操作都是由LiquidFun自动完成的。如果你摧毁一个物体，那么相关的形状、关节都会被摧毁，这就叫做<strong>隐姓摧毁</strong>。这时任何一个和以上关节/contact连接的物体就会被唤醒，这个过程通常是有利的，但你要注意：</p><blockquote><p>摧毁body时相关的fixture, joint都被自动删除。你必须要把与这些fixture, shape, joint相关的指针都给归零。（否则试图使用/摧毁这些指针将会出事）</p></blockquote><p>LiquidFun为你提供了一个监视器类叫做b2DestructionListener，你可以实现后用在你的world对象上，这时world对象就会在由joint被隐性摧毁时通知你。</p><p>注意到joint/fixture被显性摧毁的时候也不会有通知，你也需要作相应的后续清理。如果可以的话，你也可以调用你自己的b2DestructionListener类中的清理代码。</p><p>隐性摧毁通常是便捷的，但你一定要注意。尤其是，关节通常在一段与相关物体管理无关的代码中被创造，例如，testbed创造了一个mousejoint用于与鼠标操作互动。</p><p>LiquidFun提供了一个callback机制，来在隐形摧毁的时候通知你，这在之后有描述。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDestructionListener</span> :</span> <span class="hljs-keyword">public</span> b2DestructionListener&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SayGoodbye</span><span class="hljs-params">(b2Joint* joint)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-comment">//remove all references to joint</span>    &#125;&#125;</code></pre><p>你可以之后用world对象登记你的destruction listener，这应该在world的初始化中做：</p><p><code>myWorld-&gt;SetListener(myDestructionListener);</code></p><h3 id="4-3-像素以及坐标系"><a href="#4-3-像素以及坐标系" class="headerlink" title="4.3  像素以及坐标系"></a>4.3  像素以及坐标系</h3><p>再次回顾：LiquidFun使用MKS单位和弧度制。由于游戏是使用像素展示的，你可能会觉得用米有点麻烦。在Testbed中，作者将所有的游戏工作都在米中进行，只是使用OpenGL的视口变换（viewport transformation）将世界转换到屏幕大小。</p><pre><code class="hljs C++"><span class="hljs-keyword">float</span> lowerX = <span class="hljs-number">-25.0f</span>, upperX = <span class="hljs-number">25.0f</span>, lowerY = <span class="hljs-number">-5.0f</span>, upperY = <span class="hljs-number">25.0f</span>;gluOrtho2D(lowerX, upperX, lowerY, upperY);</code></pre><p>如果你的游戏非得在像素世界中运行，那么你可以在从LiquidFun获得/传输数据的时候转换单位。这将提高物理模拟的稳定性。</p><p>你应该找到一个合适的换算标准，这最好根据你的主角的大小决定。例如，你的角色是75像素高，那么你就可以使用50像素/米。</p><pre><code class="hljs C++">xMeters = <span class="hljs-number">0.02f</span> * xPixels;xPixels = <span class="hljs-number">50.0f</span> * xMeters;</code></pre><p>最好呢，是在游戏代码中就使用MKS，只是在渲染的时候再转换成像素。这会简化你的游戏逻辑，并且减少错误，因为渲染的部分可以被孤立在一小部分代码里面完成。</p><p>如果你使用转换单位的方式，你最好全局地改变它，确保不出错。你也可以通过调整提高稳定性。</p><h2 id="5-Debug-Drawing"><a href="#5-Debug-Drawing" class="headerlink" title="5.  Debug Drawing"></a>5.  Debug Drawing</h2><p>你可以实现b2DebugDraw这个类以得到物理世界的详细描绘。可用的实体有以下这些：</p><p>（1）形状轮廓；</p><p>（2）关节连接；</p><p>（3）AABBs；</p><p>（4）质心；</p><p>这是推荐的画物理实体的方法，而不是直接获取数据。理由是：这些重要的数据通常都存储在内部，且对改变易感。</p><p>testbed画了一些物理实体，使用的是debug draw这个功能还有contact listener。这展示了怎么使用debug drawing，以及怎么画接触点。</p><h2 id="6-Limitations"><a href="#6-Limitations" class="headerlink" title="6.  Limitations"></a>6.  Limitations</h2><p>LiquidFun使用了许多近似，来有效地模拟刚体物理。这会导致一些局限：</p><p>（1）将重的物体放在轻的物体上并不稳定，稳定性在比例超过10：1时会下降。</p><p>（2）对于用关节连接的chains of bodies，如果轻的物体在支撑重的物体，也会不稳定。例如，一个吊锤挂在一个chain的轻物体上就不是很稳定，超过10：1时就会这样。</p><p>（3）形状和形状碰撞之间通常有个0.5cm的差别。</p><p>（4）连续碰撞不能处理关节，所以高速运动的物体上关节可能会延展；</p><p>（5）LiquidFun使用symplectic Euler integration scheme（辛欧拉时间积分公式？）</p><p>（6）LiquidFun使用一个迭代solver来提高实时性能。你将没法得到非常精确的刚体碰撞/像素，提高迭代次数可以提高精度。</p>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
      <category>LiquidFun</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
      <tag>LiquidFun</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Record: 红磡1994 摇滚中国乐势力</title>
    <link href="/2020/07/09/Record-%E7%BA%A2%E7%A3%A11994-%E6%91%87%E6%BB%9A%E4%B8%AD%E5%9B%BD%E4%B9%90%E5%8A%BF%E5%8A%9B/"/>
    <url>/2020/07/09/Record-%E7%BA%A2%E7%A3%A11994-%E6%91%87%E6%BB%9A%E4%B8%AD%E5%9B%BD%E4%B9%90%E5%8A%BF%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<p>在朋友和滚圈知名人士的推荐下看了《摇滚中国乐势力》，一场于1994年在香港红磡体育馆举办的中国摇滚乐里程碑式的演出。</p><p>太绝了，太绝了。现在是7.9晚上，我看完了唐朝出场之前的部分，但我脑子里的感想已经满到要泼出来。趁着心脏还未完全停止悸动，赶紧把我看到的想到的都写下来。</p><blockquote><p>发现自己看的好像是89分钟的不完整版，哪天把没听到的部分补上。</p><p>之后补一下这三个人的背景经历。</p></blockquote><h2 id="窦唯"><a href="#窦唯" class="headerlink" title="窦唯"></a>窦唯</h2><p><strong>演出歌曲</strong>： （1）高级动物    （2）哦乖    （3）悲伤的梦    （4）明天更漫长（<em>未看到</em>） （5）黑色梦中</p><p><strong>演出成员</strong>： </p><p>主唱：窦唯        吉他手：周凤岭        贝斯手：胡晓海        键盘手：白方林        鼓手：王澜        打击乐手：刘效松</p><p>窦唯年轻时候也太！帅！了！<strong>我宣布我从今天起成为窦仙儿的颜粉</strong>。</p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5C%E7%AA%A6%E5%94%AF" srcset="/img/loading.gif" alt="1994年的窦唯"></p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5C%E7%AA%A6%E5%94%AF%E5%9C%A8%E4%BD%95%E5%8B%87%E7%9A%84%E9%92%9F%E9%BC%93%E6%A5%BC%E9%87%8C%E5%90%B9%E7%AC%9B%E5%AD%90.gif" srcset="/img/loading.gif" alt="窦唯在钟鼓楼里吹笛子"></p><p>窦唯的这几首里我只听过哦乖（忘词片段实在是太经典太可爱了）。窦唯的唱功很不错，舞台表现有点放不开<del>（可能是因为穿着帅气的小西装）</del>。他的风格似乎介于张楚和何勇之间，音乐编排上相对来说是现代的（但旋律里有中国上世纪流行等的影子，还有他标志性的雷鬼色彩），词的内容也更加理想化和抽象（并不是形式上的抽象，而是内容上的抽象）。相对于何勇，他更沉郁、内敛、深思，是很具有中国传统文人特点的一位摇滚人。</p><h2 id="张楚"><a href="#张楚" class="headerlink" title="张楚"></a>张楚</h2><p><strong>演出曲目</strong>：（1）上苍保佑吃饱了饭的人民  （2）和大伙去乘凉（<em>未听到</em>） （3）孤独的人是可耻的  </p><p>​                   （4）赵小姐（<em>未听到</em>）  （5）厕所和床    （6）蚂蚁</p><p><strong>乐队成员</strong>：</p><p>主唱：张楚        吉他手：曹均        低音吉他手：罗岩        键盘手：窦鹏        鼓手：刘效松        小提琴手：黄立杰</p><p>个人感觉张楚的风格并非纯粹的摇滚，器乐上有很明显的上世纪的民谣/流行味儿，撤掉鼓组可能摇滚味儿就不浓了。他的歌当中器乐没有特别出彩的地方（总体和谐），重心其实是在人声（但张楚的唱功和演绎实在是一般，有一点可惜）。张楚的词写得可谓一绝，带着土地、农民和工人、流浪汉的气息，是贫穷的，是真实而平凡的，语言和内蕴都非常有感染力。</p><h2 id="何勇"><a href="#何勇" class="headerlink" title="何勇"></a>何勇</h2><p><strong>演出曲目</strong>：（1）姑娘漂亮    （2）头上的包（<em>未听</em>）（3）垃圾场    （4）冬眠（<em>未听</em>） （5）钟鼓楼    （6）非洲</p><p><strong>乐队成员</strong>：</p><p>主唱/吉他手：何勇    三弦琴手：何玉生（何勇父亲）     吉他手：邓讴歌    贝斯手：欧洋    鼓手：余伟民</p><p>键盘手：梁和平    打击乐手：刘效松</p><p>看到目前为止，何勇的表演可谓是本场演出的高潮。但在此之前，我从未听过他的作品，抑或是名字。</p><p>何勇歌曲中的器乐、编曲已经非常现代（或者说，有明显的西方摇滚的感觉）了。他会在同一个作品中对一段旋律通过不同的乐器组合、不同的效果、音符的改动进行演绎，歌曲因此流畅且富于变化和层次。他的风格也不止是摇滚，在垃圾场里有爵士感觉的和弦，在钟鼓楼里有三弦等民族乐器的加入，非洲更是妥妥的热带风。好有才！他的歌词也大多采用朗诵方式<del>（或许他就是reader型摇滚人的始祖？）</del>。</p><p>何勇和讴歌的表演真的很 绝。各种奇奇怪怪的演奏姿势，往头上泼水，跳起来然后以帅气的姿势落地——这不就是万千摇滚少女梦中的场景吗（bushi）！何勇讲话也比窦唯和张楚清楚多了，肯定是贼好一主持人。太燥了。</p>]]></content>
    
    
    <categories>
      
      <category>Music</category>
      
      <category>Live</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Music</tag>
      
      <tag>Comment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Comment: Notes on the ALBUMs</title>
    <link href="/2020/07/09/Comment-Notes-on-the-ALBUMs/"/>
    <url>/2020/07/09/Comment-Notes-on-the-ALBUMs/</url>
    
    <content type="html"><![CDATA[<p>这篇blog用于记录我对于最近听的各种专辑的小感想，可能是记录乐队背景信息，可能是评论下artist的身材，也可能只是一句话的好恶。随便写点，主要目的仅在于形式上留点记录。</p><h2 id="Morphine"><a href="#Morphine" class="headerlink" title="Morphine"></a>Morphine</h2><p>乐队背景：</p><blockquote><p>1989年，Morphine乐队成立于美国马萨诸塞州剑桥市，发起人是<strong>歌手兼贝司手</strong>（所谓的贝司只有两根弦，有时是一根贝司弦加两根吉他弦）Mark Sandman 和中低音萨克斯手Dana Colley，后来又找来了鼓手Jerome Deupree，鼓手后更换为Billy Conway。<strong>乐队没有吉他手。</strong></p></blockquote><p>乐队把自己的风格称为“<strong>Low Rock</strong>”（简约、音阶低沉），与传统的“<strong>Power Trio</strong>”不同。</p><blockquote><p>Power Trio(in British English):</p><p>摇滚乐中的一种形式，强调贝斯、鼓、吉他的器乐演奏，没有节奏吉他、键盘，同时削减人声的重要性。</p><p>主音吉他（lead guitar）：主要负责solo（单音旋律），音质明亮、持久，常使用高输出的拾音器以及各类效果器、压缩器。</p><p>节奏吉他（rhythm guitar）: 负责节奏和和声，多弹奏中低音，通常采用配置双线圈拾音器的吉他，音色饱满，弦较粗较硬。</p></blockquote><h3 id="Like-Swimming-1997"><a href="#Like-Swimming-1997" class="headerlink" title="Like Swimming(1997)"></a>Like Swimming(1997)</h3><p>没有吉他的乐队，贝斯和萨克斯原地起飞。vocal是次要的、类似于合成器音色一样的存在，但Sandman的演绎非常带感。</p><p>嬉皮，电子，迷幻，爵士。Like Swimming是他们比较平和的一张专，质感像果味电子烟或者LSD。并不是很摇滚的一张概念专辑。</p><h2 id="刘柏辛Lexie"><a href="#刘柏辛Lexie" class="headerlink" title="刘柏辛Lexie"></a>刘柏辛Lexie</h2><h3 id="无限意识Meta-Ego-2019"><a href="#无限意识Meta-Ego-2019" class="headerlink" title="无限意识Meta Ego(2019)"></a>无限意识Meta Ego(2019)</h3><p>不知道说啥。制作听着很舒服，词一般，曲一般。就是都差点意思。</p><p>整张专的理念大概是围绕“存在”、“世界”、“神秘”，制作方式几乎都相同，迷幻的beat，中英文交叉的flow里旋律很多，再加上几层带电的人声当和声飘在后面。</p><h2 id="JABBERLOOP"><a href="#JABBERLOOP" class="headerlink" title="JABBERLOOP"></a>JABBERLOOP</h2><p>乐队背景：</p><blockquote><p>日本京都的club jazz乐队，5人组成（萨克斯，小号，键盘，bass/guitar，鼓）。</p><p>专辑《Ooparts》获得了日本爵士乐排行榜第一。</p><p>来台湾演出且和蛋堡合作过，参与了《最终幻想》的主题曲录制。</p></blockquote><h3 id="台湾特选辑"><a href="#台湾特选辑" class="headerlink" title="台湾特选辑"></a>台湾特选辑</h3><p>每一首都很棒！日式爵士味很浓。<br>但平行来看相似度太高，全专听完有点亏。</p><h3 id="OOPARTS"><a href="#OOPARTS" class="headerlink" title="OOPARTS"></a>OOPARTS</h3><p>很棒！这张专就不是很重复，有些歌像传统爵士演奏是由不同声部的solo连接而成，有些使用了很明亮的打击乐器/电子合成器，有些就偏日漫风，<del>开门第一首贼像新宝岛</del>，甚至最后还有一首DJ搓碟曲（虽然我不是很喜欢）。</p><p>感觉日系爵士里Blues/Soul的元素要少一些……</p><h2 id="Doja-Cat"><a href="#Doja-Cat" class="headerlink" title="Doja Cat"></a>Doja Cat</h2><p>之前高三疯狂听emo的时候曾经被推过No Police和So High，但不是特别感兴趣。这次再听是因为Say So被我在b站上关注的up主拍了相关视频。</p><h3 id="Hot-Pink-2019"><a href="#Hot-Pink-2019" class="headerlink" title="Hot Pink(2019)"></a>Hot Pink(2019)</h3><p>Hot Pink是我这几天听得最多的专辑，大概是因为Doja实在太辣了。这张专几乎全部是sex talk，但Doja能写出12首sex talk且不重复，也挺厉害的。</p><p>这张专的beat都挺好听的，且Doja的flow写得真的很棒，节奏变化、韵脚都非常流畅且有意思。最吸引我的是Doja的声线，既可以唱娃娃音的vocal，也可以把音色拉到粗哑唱rap，对于不同词语的音色处理很绝。</p><p>再补一段小感想：作为在中文文化里接受价值熏陶（且接受良好教育）的韭菜，我确实会不自觉地将中文中的色情、粗口等成分与低俗作一定的关联，我对于中文的纯dirty talk歌曲的接受度明显不如我对英文的同主题歌曲的接受度高。这可能是因为英语文化中相关元素的耻度本来就较低，也可能是因为我没有在英语的语言环境下对不同概念（及其对应的英语词汇）形成价值判断。这间接说明我们对于事物的判断完全可能因为使用的语言发生变化（因此换个语言环境换个人格是完全合理的事情）。</p><h2 id="The-Reddings"><a href="#The-Reddings" class="headerlink" title="The Reddings"></a>The Reddings</h2><p>美国80年代至今的funk乐队。我还挺想了解下乐队背景的，但网上没有……得把科学上网提上进程。</p><h3 id="The-Awakening（1980）"><a href="#The-Awakening（1980）" class="headerlink" title="The Awakening（1980）"></a>The Awakening（1980）</h3><p>我觉得是非常棒的一张funk专辑！非常标准的funk曲中间穿插了几首舒缓的真诚小情歌。可能因为专辑歌曲数不是很多，我觉得全专总体重复度不高，每首编曲各有特色、突出了不同的声部。</p><h2 id="沼泽"><a href="#沼泽" class="headerlink" title="沼泽"></a>沼泽</h2><p>广州独立后摇乐队，古琴与摇滚相融合。百度百科已经讲得很全面了（怕是百科词条最全面的独立乐团之一），这里就简单地摘录一下乐手介绍。</p><blockquote><p><strong>海亮Hoyliang</strong>：古琴、吉他、人声。主要词曲创作。</p><p><strong>海逊Seasean：</strong>鼓、钟片琴、打击合成器。专辑混音制作，美术设计。海亮弟。</p><p><strong>细辉Littledream：</strong>吉他、小键盘。乐队器材管理。</p><p><strong>阿来Roy：</strong>贝司、口风琴、箫。与海亮同为创队元老。</p></blockquote><h3 id="1911（2011）、沧浪星（2010）、争鸣（2018）"><a href="#1911（2011）、沧浪星（2010）、争鸣（2018）" class="headerlink" title="1911（2011）、沧浪星（2010）、争鸣（2018）"></a>1911（2011）、沧浪星（2010）、争鸣（2018）</h3><p>是在读文档的时候听的…所以总体来说听得不是很认真，也没有仔细看专辑介绍啥的，但仅仅是粗略地听，也可以听出这是一支非常非常成熟的后摇乐队了。</p><p>乐队的器乐水平非常高（除了有几段小提琴的部分尾音有点仓促），对各种乐器音色的调整和把玩真的非常牛，有太多值得学习的地方。</p><p>国内好多后摇乐队编曲清一色相似至极，几乎和弦走势和合成器都没啥太大的差别，从头到尾怎么丧怎么来。但沼泽乐队这三张专辑的曲子首先内部都有明显的（细腻的）情感变化，专辑内部曲与曲之间有内容和情绪的递进或演变，专辑与专辑之间通过乐器选择、音色、编曲的非常多样的调整也都非常好地呈现出了各自的主题。</p><p>太成熟了，太成熟了，技术和心思方面我觉得在我听过的国内后摇乐队里已经太牛了。（做作业听也挺合适的）</p><h2 id="景德镇文艺复兴"><a href="#景德镇文艺复兴" class="headerlink" title="景德镇文艺复兴"></a>景德镇文艺复兴</h2><p>民谣摇滚+章节式叙事+自创神话+实验戏剧，江西景德镇独立乐队。</p><p><strong>九三</strong>： 主唱+吉他。其他乐队成员信息暂缺。</p><h3 id="《云难》系列"><a href="#《云难》系列" class="headerlink" title="《云难》系列"></a>《云难》系列</h3><p>说实话，要对《云难》系列做出评论，我得犹豫半天。一方面，它原创的叙事主题非常吸引我，整张专辑的组织、词的写作都是非常有生命力的，让人对其呈现有着很高的期待；但另一方面，整张专在音乐上的表现力（在我看来）并没有与其词、概念中的力量匹配。</p><p>从头到尾，女声人声（大概是九三的声音）完全戳中我的尬点，技术和演绎似乎都不足，男声人声相对还好；终章之前，器乐的音色是饱满的，但人声的录音条件/混音质量都并未与其平衡匹配；除了雀群撞雨一曲外，我能感受到情感、主题的变化和过渡，但编曲和器乐似乎力道不足。</p><p>终章部分开始后，我有了明显的改观。人声与器乐的融合改善了很多，编曲也让人觉得比较饱满和成熟了（但女声持续爆破我的尬点）。我认为终章部分呈现出的表现力就比较能驾驭这样的神话主题了。</p><p>咋说呢，期待以后的作品吧！</p><h2 id="9m88"><a href="#9m88" class="headerlink" title="9m88"></a>9m88</h2><p>不是很想查背景…暂空。</p><h3 id="平庸之上-Beyond-Mediocrity-2019"><a href="#平庸之上-Beyond-Mediocrity-2019" class="headerlink" title="平庸之上 Beyond Mediocrity(2019)"></a>平庸之上 Beyond Mediocrity(2019)</h3><p>我是听了《最高品质静悄悄》后，作为jazz pop死忠粉过来欣赏这个专辑的（而且9m88的扮相也很吸引我）。但是词实在是…（只有《最高品质静悄悄》、《九头身日奈》、《厨余恋人》这几首觉得还好）。当然，不得不说她把流行和爵士融合得真的很好，我也非常喜欢这种爵士曲调（想学会作这样好听的曲），编曲也非常合适。</p><h2 id="瘦人"><a href="#瘦人" class="headerlink" title="瘦人"></a>瘦人</h2><p>有事，乐队背景暂空。简介里把这个乐队和唐朝、黑豹等并列。</p><h3 id="第七天（2008）"><a href="#第七天（2008）" class="headerlink" title="第七天（2008）"></a>第七天（2008）</h3><p>网易云里瘦人仅存的一张专辑。说实话，瘦人这个词是写得真滴不行。</p><p>当然，感觉曲也就一般吧…制作很成熟，但没什么特别新或是特别吸引我的地方。</p><p>比较好笑的是，我听到后面在想：“这不就是带点摇滚味儿的羽泉吗？”然后看专辑介绍的时候看到：制作人 陈羽凡。Fine。</p>]]></content>
    
    
    <categories>
      
      <category>Music</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Music</tag>
      
      <tag>Comment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LiquidFun文档简记</title>
    <link href="/2020/07/08/LiquidFun%E6%96%87%E6%A1%A3%E7%AE%80%E8%AE%B0/"/>
    <url>/2020/07/08/LiquidFun%E6%96%87%E6%A1%A3%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="0-Pre-Everything"><a href="#0-Pre-Everything" class="headerlink" title="0. Pre-Everything"></a>0. Pre-Everything</h2><h3 id="0-0-Reference"><a href="#0-0-Reference" class="headerlink" title="0.0 Reference"></a>0.0 Reference</h3><p><a href="http://www.ladeng6666.com/blog/?cat=8" target="_blank" rel="noopener">Blog：拉小登，上面有Box2D部分概念和应用</a></p><p><a href="http://code.google.com/p/box2d/downloads/list" target="_blank" rel="noopener">Erin Catto’s GDC Tutorials</a></p><p><em>Collision Detection in Interactive 3D Environments,</em> Gino van den Bergen, 2004<br><em>Real-Time Collision Detection,</em> Christer Ericson, 2005</p><h2 id="1-Collision模块。"><a href="#1-Collision模块。" class="headerlink" title="1. Collision模块。"></a>1. Collision模块。</h2><h3 id="1-0-Shape"><a href="#1-0-Shape" class="headerlink" title="1.0 Shape"></a>1.0 Shape</h3><p>用于碰撞检测，在b2Fixture创建时会由b2World自动创建。</p><ul><li>第一种：通过fixture与body绑定，随body进行rigid moves。</li><li>第二种：通过顶点坐标的形式存在于world中，只能通过手动设置坐标进行移动。</li></ul><p>（1）分类：</p><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> Type &#123;   e_circle = <span class="hljs-number">0</span>, e_edge = <span class="hljs-number">1</span>,   e_polygon = <span class="hljs-number">2</span>, e_chain = <span class="hljs-number">3</span>,   e_typeCount = <span class="hljs-number">4</span> &#125;</code></pre><p>（2）子类：b2ChainShape, b2CircleShape, …Edge…, …Polygon…。</p><p>（3）数据成员：m_type, m_radius。</p><p>（4）public成员函数：</p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cmember_f.png" srcset="/img/loading.gif" alt="image-20200709114719125"></p><h3 id="1-1-Circle"><a href="#1-1-Circle" class="headerlink" title="1.1 Circle"></a>1.1 Circle</h3><pre><code class="hljs c++">b2CircleShape <span class="hljs-built_in">circle</span>;  <span class="hljs-comment">//实心</span><span class="hljs-built_in">circle</span>.m_p.Set(<span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>); <span class="hljs-comment">//圆心位置</span><span class="hljs-built_in">circle</span>.m_radius = <span class="hljs-number">0.5f</span>; <span class="hljs-comment">//半径必须大于零</span></code></pre><h3 id="1-2-Polygon"><a href="#1-2-Polygon" class="headerlink" title="1.2 Polygon"></a>1.2 Polygon</h3><p>Def: 实心凸（连接内部两点的线段不与边交叉）多边形，&gt;=3边。</p><p>通过CCW（逆时针winding）填充：</p><blockquote><p>多边形填充有两种模式：alternate和winding。</p><p><strong>alternate</strong>: </p><p>显示器的每个扫描行都是从左到右扫描，系统只填充每个扫描行遇到的多边形的奇数边和偶数边之间的部分，不填充偶数边到奇数边之间的部分。</p><p><strong>winding</strong>: </p><p>用一笔画一个多边形，分clockwise或counterclockwise。</p><p>画一条直线M，对于与它相交的线段：从直线M的左边到右边为clockwise，count+1；从直线M的右边到左边为counterclockwise，count-1。<br>判断一个区域E是否要被填充：从该区域画一线段M到整个多边型区域外，按照上面的方法对<strong>与该线相交的多边形的边</strong>进行count的计数，如果count非零则区域E要被填充，否则不填充。  </p></blockquote><p>从shape继承了radius，用于在多边形周围创造skin，防止tunneling。</p><p>这会导致形状之间有小gap，可以将visual表示做得大一点。</p><p><strong>成员都是public的</strong>， 初始化可传入一个vertex数组：</p><pre><code class="hljs C++"><span class="hljs-comment">///至多b2_maxPolygonVertices个顶点</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">b2PolygonShape</span> :</span> <span class="hljs-keyword">public</span> b2Shape&#123;<span class="hljs-keyword">public</span>:b2PolygonShape();    <span class="hljs-comment">/// Implement b2Shape.</span><span class="hljs-function">b2Shape* <span class="hljs-title">Clone</span><span class="hljs-params">(b2BlockAllocator* allocator)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">/// @see b2Shape::GetChildCount</span><span class="hljs-function">int32 <span class="hljs-title">GetChildCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">/// 用顶点数组创造多边形。</span><span class="hljs-comment">/// 边数count属于[3, b2_maxPolygonVertices].</span><span class="hljs-comment">/// 即时传入的点能构成多边形，点也可能被重排。</span><span class="hljs-comment">/// 共线的点被处理但不被移除。</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2* points, int32 count)</span></span>;<span class="hljs-comment">/// 以原点为中心，平行于坐标轴。</span><span class="hljs-comment">/// hx the half-width，hy the half-height.</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetAsBox</span><span class="hljs-params">(float32 hx, float32 hy)</span></span>;<span class="hljs-comment">/// hx the half-width，hy the half-height.</span><span class="hljs-comment">/// center：中心坐标</span><span class="hljs-comment">/// angle：旋转角度</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetAsBox</span><span class="hljs-params">(float32 hx, float32 hy, <span class="hljs-keyword">const</span> b2Vec2&amp; center, float32 angle)</span></span>;<span class="hljs-comment">/// @see b2Shape::TestPoint</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">TestPoint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Transform&amp; transform, <span class="hljs-keyword">const</span> b2Vec2&amp; p)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">// @see b2Shape::ComputeDistance</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ComputeDistance</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Transform&amp; xf, <span class="hljs-keyword">const</span> b2Vec2&amp; p, float32* distance, b2Vec2* normal, int32 childIndex)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">/// Implement b2Shape.</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">RayCast</span><span class="hljs-params">(b2RayCastOutput* output, <span class="hljs-keyword">const</span> b2RayCastInput&amp; input,</span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> b2Transform&amp; transform, int32 childIndex)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">/// @see b2Shape::ComputeAABB</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ComputeAABB</span><span class="hljs-params">(b2AABB* aabb, <span class="hljs-keyword">const</span> b2Transform&amp; transform, int32 childIndex)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">/// @see b2Shape::ComputeMass</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ComputeMass</span><span class="hljs-params">(b2MassData* massData, float32 density)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">/// Get the vertex count.</span><span class="hljs-function">int32 <span class="hljs-title">GetVertexCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_count; &#125;<span class="hljs-comment">/// Get a vertex by index.</span><span class="hljs-function"><span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-title">GetVertex</span><span class="hljs-params">(int32 index)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">/// 验证凸性，耗时很长。</span><span class="hljs-comment">/// @returns true if valid</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Validate</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;b2Vec2 m_centroid; <span class="hljs-comment">//初始为0</span>b2Vec2 m_vertices[b2_maxPolygonVertices]; b2Vec2 m_normals[b2_maxPolygonVertices];int32 m_count; <span class="hljs-comment">//b2_polygonRadius</span>    <span class="hljs-comment">//m_type = e_polygon;</span><span class="hljs-comment">//m_radius = b2_polygonRadius;</span>&#125;;</code></pre><h3 id="1-3-Edge"><a href="#1-3-Edge" class="headerlink" title="1.3 Edge"></a>1.3 Edge</h3><p>线段，用于做静态的环境。能与circle,polygon碰撞，但不能与线段碰撞。</p><p>（这是由于碰撞系统要求两个物体至少一个有体积，线段无体积。）</p><pre><code class="hljs armasm"><span class="hljs-keyword">b2Vec2 </span><span class="hljs-built_in">v1</span>(<span class="hljs-number">0</span>.<span class="hljs-number">0</span>f, <span class="hljs-number">0</span>.<span class="hljs-number">0</span>f), <span class="hljs-built_in">v2</span>(<span class="hljs-number">1</span>.<span class="hljs-number">0</span>f, <span class="hljs-number">0</span>.<span class="hljs-number">0</span>f)<span class="hljs-comment">;</span><span class="hljs-keyword">b2EdgeShape </span>edge<span class="hljs-comment">;</span><span class="hljs-symbol">edge.Set</span>(<span class="hljs-built_in">v1</span>, <span class="hljs-built_in">v2</span>)<span class="hljs-comment">;  //初始化</span></code></pre><p>通常游戏世界会涉及多条线段连接而成的线。当物体在其上滑动时，可能会与线段顶点发声ghost collision，造成internal collision normal。</p><p>于是有如下机制：使用命令</p><pre><code class="hljs C++">b2Vec2 v0<span class="hljs-number">-3</span>(x0<span class="hljs-number">-3</span>,y0<span class="hljs-number">-3</span>);b2EdgeShape edge;edge.Set(v1, v2);   edge.m_hasVertex0 = <span class="hljs-literal">true</span>;   edge.m_hasVertex3 = <span class="hljs-literal">true</span>;   edge.m_vertex0 = v0;   edge.m_vertex3 = v3;</code></pre><p>存入临近的ghost vertice，但这有点麻烦。</p><p>![image-20200708114649294](C:\Users\ybr19\Documents\100%_MOREHAB\Files\BLOGGER\source\img\blog\ghost collision.png)</p><p>于是又有如下机制：将边缝合为chain shapes。这可以防止ghost collision，并提供<strong>双边碰撞（two-sided collision, 我猜测指的是在两端的碰撞）。</strong></p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5C2-sided.png" srcset="/img/loading.gif" alt="Chain shape"></p><pre><code class="hljs C++"><span class="hljs-comment">// This a chain shape with isolated vertices</span>  b2Vec2 vs[<span class="hljs-number">4</span>]; <span class="hljs-comment">//Set them</span>  b2ChainShape chain;  chain.CreateChain(vs, <span class="hljs-number">4</span>);</code></pre><p>对于滚动的游戏世界，可以使用ghost vertices将chain连接在一起。</p><pre><code class="hljs C++"><span class="hljs-comment">//Install ghost vertices</span>chain.SetPrevVertex(b2Vec2(<span class="hljs-number">3.0f</span>, <span class="hljs-number">1.0f</span>));chain.SetNextVertex(b2Vec2(<span class="hljs-number">-2.0f</span>, <span class="hljs-number">0.0f</span>));</code></pre><p>还可以创造<strong>loop</strong>：</p><pre><code class="hljs C++"><span class="hljs-comment">// first and last vertices are connected</span>b2ChainShape chain;chain.CreateLoop(vs, <span class="hljs-number">4</span>);</code></pre><p>代码<strong>不支持chain shape之间出现交叉</strong>，且vertices之间过近也可能导致问题，故最好保证边长于b2_linearSlop = 5mm。</p><blockquote><p>/// A small length used as a collision and constraint tolerance. Usually it is<br>/// chosen to be numerically significant, but visually insignificant.<br>#define b2_linearSlop            0.005f</p></blockquote><p>在chain中的边都被视作child shape，可以通过指标访问。当chain shape与body连接时，每个边在broad-phase碰撞树中都会得到自己的bounding box。</p><pre><code class="hljs C++"><span class="hljs-comment">// Visit each child edge.</span><span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; chain.GetChildCount(); ++i)&#123;   b2EdgeShape edge;   chain.GetChildEdge(&amp;edge, i);   …&#125;</code></pre><h3 id="1-5-Transform"><a href="#1-5-Transform" class="headerlink" title="1.5 Transform"></a>1.5 Transform</h3><p>transform类用于表示刚体的位置，在Math.h中定义。</p><p>数据成员：</p><pre><code class="hljs 1c">b2Vec2 p; <span class="hljs-comment">//translation</span>b2Rot q; <span class="hljs-comment">//rotation</span><span class="hljs-comment">//Rot类含两个数据成员：旋转角的s和c。</span></code></pre><h3 id="1-4-几何查询"><a href="#1-4-几何查询" class="headerlink" title="1.4  几何查询"></a>1.4  几何查询</h3><h4 id="1-4-1-查询点与形状的重合"><a href="#1-4-1-查询点与形状的重合" class="headerlink" title="1.4.1  查询点与形状的重合"></a>1.4.1  查询点与形状的重合</h4><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> hit = shape-&gt;<span class="hljs-constructor">TestPoint(<span class="hljs-params">transform</span>, <span class="hljs-params">point</span>)</span>;</code></pre><p>edge和chain（包括loop）总会返回false。</p><h4 id="1-4-2-进行ray-cast"><a href="#1-4-2-进行ray-cast" class="headerlink" title="1.4.2  进行ray cast"></a>1.4.2  进行ray cast</h4><blockquote><p>ray cast（光线投射）：</p><p>用于3D数据场的可视化，是体绘制中的一种处理方式：</p><p>向三维数据场投射出光线，然后沿着光线方向积分，数值化方法为由前往后或由后向前合成。</p><p>（不是很懂）</p></blockquote><p>在这里指用一束光线打到shape上，得到第一个交点和对应的向量。若光线从形状内部触发，则标记为未击中。</p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cray_cast.png" srcset="/img/loading.gif" alt="image-20200709140659310"></p><h4 id="1-4-3-两个图形的重合"><a href="#1-4-3-两个图形的重合" class="headerlink" title="1.4.3 两个图形的重合"></a>1.4.3 两个图形的重合</h4><pre><code class="hljs reasonml"><span class="hljs-built_in">bool</span> b2<span class="hljs-constructor">TestOverlap(<span class="hljs-params">const</span> <span class="hljs-params">b2Shape</span> <span class="hljs-operator">*</span><span class="hljs-params">sA</span>, <span class="hljs-params">int32</span> <span class="hljs-params">indexA</span>, <span class="hljs-params">const</span> <span class="hljs-params">b2Shape</span> <span class="hljs-operator">*</span><span class="hljs-params">sB</span>, <span class="hljs-params">int32</span> <span class="hljs-params">indexB</span>, <span class="hljs-params">const</span> <span class="hljs-params">b2Transform</span> &amp;<span class="hljs-params">xfa</span>, <span class="hljs-params">const</span> <span class="hljs-params">b2Transform</span> &amp;<span class="hljs-params">xfb</span>)</span>;<span class="hljs-comment">//index指对于chain shapes的child index。</span></code></pre><h4 id="1-4-4-Contact-Manifold-接触流形"><a href="#1-4-4-Contact-Manifold-接触流形" class="headerlink" title="1.4.4 Contact Manifold(接触流形)"></a>1.4.4 Contact Manifold(接触流形)</h4><p>LiquidFun有用于计算重合shape的接触点的函数。</p><blockquote><p>normal vector: 法向量。</p></blockquote><p>圆对圆/圆对多边形：一个点+一个法向量。</p><p>多边形对多边形：两个点+一个法向量，被统一在一个流形结构里。</p><blockquote><p>b2Manifold类包含1*法向量 + &lt;=2个接触点，均以local坐标系保存。每个点都存下了法向和切向（摩擦）的力。</p><p>b2Manifold是用于内部使用的类。用户最好使用b2WorldManifold来生成normal和points在world中的坐标，需要提供b2Manifold, shape transform 和 radius。</p><pre><code class="hljs c++">b2WorldManifold worldManifold;worldManifold.Initialize(&amp;manifold, transformA, shapeA.m_radius, transformB, shapeB.m_radius);<span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; manifold.pointCount; ++i)&#123;   b2Vec2 <span class="hljs-built_in">point</span> = worldManifold.points[i];   …&#125;</code></pre></blockquote><p>在模拟中manifold会发生变化，点可能增加或减少，可以通过b2GetPointStates检测。</p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cpointstate.png" srcset="/img/loading.gif" alt="image-20200709153724244"></p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cgetstate.png" srcset="/img/loading.gif" alt="image-20200709153811976"></p><h4 id="1-4-5-距离"><a href="#1-4-5-距离" class="headerlink" title="1.4.5 距离"></a>1.4.5 距离</h4><p>b2Distance函数用于计算两个形状之间的距离，该函数需要将shape转化为shape proxy，还会进行一定的缓存以准备重复调用。</p><pre><code class="hljs C++"><span class="hljs-comment">/// Compute the closest points between two shapes. Supports any combination of:</span><span class="hljs-comment">/// b2CircleShape, b2PolygonShape, b2EdgeShape. The simplex cache is input/output.</span><span class="hljs-comment">/// On the first call set b2SimplexCache.count to zero.</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">b2Distance</span><span class="hljs-params">(b2DistanceOutput* output,</span></span><span class="hljs-function"><span class="hljs-params">b2SimplexCache* cache, </span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> b2DistanceInput* input)</span></span>;</code></pre><p>其中，input的具体信息如下：</p><pre><code class="hljs C++"><span class="hljs-comment">/// Input for b2Distance.</span><span class="hljs-comment">/// You have to option to use the shape radii</span><span class="hljs-comment">/// in the computation. </span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">b2DistanceInput</span></span><span class="hljs-class">&#123;</span>b2DistanceProxy proxyA;b2DistanceProxy proxyB;b2Transform transformA;b2Transform transformB;<span class="hljs-keyword">bool</span> useRadii;&#125;;</code></pre><p>output的具体信息如下：</p><pre><code class="hljs C++"><span class="hljs-comment">/// Output for b2Distance.</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">b2DistanceOutput</span></span><span class="hljs-class">&#123;</span>b2Vec2 pointA;<span class="hljs-comment">///&lt; closest point on shapeA</span>b2Vec2 pointB;<span class="hljs-comment">///&lt; closest point on shapeB</span>float32 distance;int32 iterations;<span class="hljs-comment">///&lt; number of GJK iterations used</span>&#125;;</code></pre><p>SimplexCache的信息如下（不是很明白具体要传啥）：</p><pre><code class="hljs C++"><span class="hljs-comment">/// Used to warm start b2Distance.</span><span class="hljs-comment">/// Set count to zero on first call.</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">b2SimplexCache</span></span><span class="hljs-class">&#123;</span>float32 metric;<span class="hljs-comment">///&lt; length or area</span>uint16 count;uint8 indexA[<span class="hljs-number">3</span>];<span class="hljs-comment">///&lt; vertices on shape A</span>uint8 indexB[<span class="hljs-number">3</span>];<span class="hljs-comment">///&lt; vertices on shape B</span>&#125;;</code></pre><h4 id="1-4-6-Time-of-Impact"><a href="#1-4-6-Time-of-Impact" class="headerlink" title="1.4.6 Time of Impact"></a>1.4.6 Time of Impact</h4><p>用于决定两个moving shapes的碰撞时间，防止tunneling。</p><p>该函数会考虑旋转和平移，但如果旋转角度过大，则函数可能遗漏碰撞。但函数仍然会报告不重合的时间，且会考虑所有的平移碰撞。</p><p><strong>后面还有一大段讨论这个函数的限制等，没太明白，暂且跳过。</strong></p><h3 id="1-5-动态树"><a href="#1-5-动态树" class="headerlink" title="1.5 动态树"></a>1.5 动态树</h3><p>用于有效地管理大量shapes（但实际上它并不掌握shape的信息，而是在AABB上操作）。</p><p>该树就是AABB的层级树，每个内部节点有两个子节点，叶子是单用户的AABB。该树会使用旋转保持平衡，即便输入是退化的。</p><p>树的结构使得它能有效地执行ray cast和region query。一般我们不会直接使用该树。</p><p>同样，使用动态树进行pair management，可以对碰撞进行broad-phase检测。broad-phase一般也不会直接使用。</p><h2 id="2-Dynamics模块"><a href="#2-Dynamics模块" class="headerlink" title="2. Dynamics模块"></a>2. Dynamics模块</h2><p>包含fixture, rigid body, contact, joint, world, listener等多个类，之间依赖复杂。</p><h3 id="2-1-Bodies"><a href="#2-1-Bodies" class="headerlink" title="2.1 Bodies"></a>2.1 Bodies</h3><ul><li><p>Bodies有位置和速度；</p></li><li><p>可以在其上施加力-foce、力矩-torque、冲量-impulse；</p></li><li><p>可以是static, kinematic, dynamic。</p></li></ul><blockquote><p>Dynamic: 具有全套属性（有限质量、阻力），受重力和作用力的影响，可以和其他每个刚体碰撞，性能成本高、最具互动性。</p><p>Kinematic: 仅在明确的用户控制下移动（手动移动/速度），只能与Dynamic碰撞，不受重力和作用力的影响，成本低。碰撞下同样不动（无限质量：mass = inverse mass = 0）。</p><p>Static: 不动（具有无限质量）（除非用户手动移动），只能与Dynamic碰撞。</p></blockquote><ul><li><strong>Bodies carry fixtures.</strong> 在LiquidFun中一定是刚体（一个Body上的两个fixture不会发生相对运动，不会碰撞）。</li><li>body从fixture处获得质量属性（可以override）。</li><li>一般会对创建的body保存其指针，以便于查询和析构。</li></ul><h4 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h4><p>通过 b2BodyDef（可循环使用） 定义一个body。</p><p>body有两个点比较重要：</p><ul><li>原点：fixture和joint都是以原点为参照附着的。</li><li>质心：很多内部计算都要使用质心。</li></ul><blockquote><p>frame of reference: 信仰和准则，参照系。</p></blockquote><p>Shapes are added to a body after construction.</p><pre><code class="hljs C++">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">b2BodyDef</span></span><span class="hljs-class">&#123;</span><span class="hljs-comment">///enum b2BodyType &#123;</span><span class="hljs-comment">///b2_staticBody = 0, b2_kinematicBody, b2_dynamicBody, b2_bulletBody,&#125;;</span>    <span class="hljs-comment">/// 最好在创造时就确定，因为之后改变type花费巨大</span><span class="hljs-comment">/// Note: if a dynamic body would have zero mass, the mass is set to one.</span>b2BodyType type;<span class="hljs-comment">/// The world position of body's 原点. </span>    <span class="hljs-comment">///不要把body放在world的原点然后再移动！这会导致时间成本提高</span>b2Vec2 <span class="hljs-built_in">position</span>;<span class="hljs-comment">/// The world angle of the body in radians.</span>float32 angle;<span class="hljs-comment">/// The 线速度 of the body's origin in world co-ordinates.</span>b2Vec2 linearVelocity;<span class="hljs-comment">/// The 角速度 of the body.</span>float32 angularVelocity;</code></pre><p><strong>Damping – 阻尼</strong></p><ul><li>Damping与friction不同，friction仅在有接触时出现</li><li>damping系数应当&gt;0=no damping &amp;&amp; &lt;infinity=full damping</li><li>通常damping系数 0-0.1</li><li>linear damping会让body看着像飘起来<pre><code class="hljs C++"><span class="hljs-comment">///线性damping是用于降低线速度，阻尼系数可以&gt;1,但系数较大时效果对time step较为敏感</span>float32 linearDamping;<span class="hljs-comment">/// 角度damping是用于降低角速度，阻尼系数可以&gt;1,但系数较大时效果对time step较为敏感</span>float32 angularDamping;</code></pre></li></ul><p><strong>Sleep</strong>: </p><p>将body送入sleep状态意味着停止模拟它，降低成本。</p><p>当：</p><ul><li>一个醒来的body和睡着的body碰撞时</li><li>body上附着的joint/contact被消灭时</li><li>人工唤醒时</li></ul><p>睡着的body会醒来。</p><pre><code class="hljs angelscript"><span class="hljs-comment">/// 允许睡觉吗？</span><span class="hljs-built_in">bool</span> allowSleep;<span class="hljs-comment">/// 最初睡着/醒着？</span><span class="hljs-built_in">bool</span> awake;</code></pre><p><strong>Fixed Rotation</strong>：</p><p>对于人物角色，你可能希望通过设置使其不能旋转。</p><p>若将fixedRotation设为true，则转动惯量和其逆都将被设为0。</p><pre><code class="hljs angelscript"><span class="hljs-comment">/// 能转喵？</span><span class="hljs-built_in">bool</span> fixedRotation;</code></pre><p><strong>Bullets</strong></p><p>游戏中常常需要生成一系列以一定帧率播放的图片，这也就是所谓的离散模拟。这种模拟中，刚体可能在一个time step里进行了大量移动，这可能会导致tunneling。</p><p>LiquidFun使用CCD来防止tunneling，也即：</p><ul><li>将物体从旧位置移动至新位置，寻找过程中的碰撞；</li><li>计算碰撞的TOI；</li><li>将物体移动到第一次TOI，然后剩余时间悬停；</li></ul><p>一般来说在dynamic bodies之间不会使用CCD（降低成本），但你可能需要这样的操作（子弹穿过dynamic的砖）。</p><p>在LiquidFun中，你可以将高速运动的物体设置为bullets，这样他们就会与static, dynamic的物体都运行CCD。</p><p>注：static/kinematic bodies不会发生tunneling。</p><pre><code class="hljs angelscript"><span class="hljs-comment">/// 高速且dynamic且要防止tunneling吗？</span><span class="hljs-comment">/// 少更改（很耗时）。</span><span class="hljs-built_in">bool</span> bullet;</code></pre><p><strong>Activation</strong></p><p>创造一个物体，但它不参与碰撞/运动。</p><p>与sleeping类似，但不会被碰撞唤醒，它的fixture不会参与broad-phase检测。</p><p>不参与碰撞、ray cast等。</p><p>joint可以附着在未被激活的物体上，这些joint不会参与模拟。</p><p>激活一个joint没有变形的物体要小心（？）。</p><pre><code class="hljs angelscript"><span class="hljs-comment">/// 激活了吗？</span><span class="hljs-built_in">bool</span> active;</code></pre><p><strong>用户数据</strong></p><p>一个空指针，用于链接用户自己的特殊设置。</p><p>应当对所有用户数据使用<strong>同样的一类对象</strong>。</p><pre><code class="hljs sql">/// <span class="hljs-keyword">Use</span> this <span class="hljs-keyword">to</span> <span class="hljs-keyword">store</span> application specific <span class="hljs-keyword">body</span> data.<span class="hljs-built_in">void</span>* userData;</code></pre><p><strong>Gravity Scale</strong></p><p>用于单独调整某个物体受到的重力。增加重力可能影响稳定性。</p><pre><code class="hljs angelscript">    <span class="hljs-comment">/// Scale the gravity applied to this body.</span>    <span class="hljs-built_in">float</span>32 gravityScale;&#125;;</code></pre><h4 id="2-1-2-Body-Factory"><a href="#2-1-2-Body-Factory" class="headerlink" title="2.1.2 Body Factory"></a>2.1.2 Body Factory</h4><p>我们使用world类提供的body factory生成和析构一个物体。</p><pre><code class="hljs c++">b2Body* dynamicBody = myWorld-&gt;CreateBody(&amp;bodyDef);<span class="hljs-comment">/// DO SOMETHING</span>myWorld-&gt;DestroyBody(dynamicBody);dynamicBody = <span class="hljs-literal">NULL</span>;</code></pre><h4 id="2-1-3-一些其他的注意事项"><a href="#2-1-3-一些其他的注意事项" class="headerlink" title="2.1.3 一些其他的注意事项"></a>2.1.3 一些其他的注意事项</h4><p>（1）手动移动static bodies：</p><ul><li><p>要注意不要压扁两个/多个static bodies之间的dynamic bodies。</p></li><li><p>Friction不能正常工作；</p></li><li><p>将多个shape绑定到一个静态物体上要比创造多个静态物体，每个绑定一个shape要快。</p></li><li><p>静态物体的质量和其逆都是0。</p></li></ul><p>（2）删除Bodies:</p><ul><li>LiquidFun allows you to avoid destroying bodies by deleting your b2World object, which does all the cleanup work for you. However, you should be mindful to nullify body pointers that you keep in your game engine. (？)</li><li>删除Body时其上附着的fixture和joint也会被自动删除。</li></ul><h4 id="2-1-4-使用bodies"><a href="#2-1-4-使用bodies" class="headerlink" title="2.1.4 使用bodies"></a>2.1.4 使用bodies</h4><p>（一）<strong>质量数据</strong></p><p>物体都具有：</p><ul><li>质量（标量）</li><li>质心（2维向量）</li><li>转动惯量（标量）</li></ul><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5C%E8%B4%A8%E9%87%8F%E6%95%B0%E6%8D%AE.png" srcset="/img/loading.gif" alt="image-20200710112021317"></p><p>静态物体的质量=转动惯量=0；当一个物体被设置为不能转动时，转动惯量也为0。</p><p>一般来说，物体的质量性质在其上添加fixture时自动生成，当然也可以在运行时使用以下命令改变。</p><p><code>void SetMassData(const b2MassData* data)；</code></p><p>如此暴力改变后，你可以通过如下命令将其恢复为由fixtures决定的自然质量：</p><p><code>void ResetMassData();</code></p><p>可以通过一系列<code>GetXxxx() const</code>的函数获得质量数据。</p><p>（二）<strong>状态数据</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetType</span><span class="hljs-params">(b2BodyType type)</span></span>;<span class="hljs-function">b2BodyType <span class="hljs-title">GetType</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetBullet</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> flag)</span></span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsBullet</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetSleepingAllowed</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> flag)</span></span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsSleepingAllowed</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetAwake</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> flag)</span></span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsAwake</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetActive</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> flag)</span></span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsActive</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetFixedRotation</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> flag)</span></span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsFixedRotation</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;</code></pre><p>（三）<strong>位置和速度</strong></p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">SetTransform</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-built_in">position</span>, float32 angle)</span></span>;<span class="hljs-function"><span class="hljs-keyword">const</span> b2Transform&amp; <span class="hljs-title">GetTransform</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function"><span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-title">GetPosition</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function">float32 <span class="hljs-title">GetAngle</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;</code></pre><pre><code class="hljs C++"><span class="hljs-comment">//质心位置</span><span class="hljs-function"><span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-title">GetWorldCenter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">//in world coordinates</span><span class="hljs-function"><span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-title">GetLocalCenter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">//in local coordinates</span></code></pre><p>获取到的线速度是针对于质心的。</p><h3 id="2-2-Fixtures"><a href="#2-2-Fixtures" class="headerlink" title="2.2 Fixtures"></a>2.2 Fixtures</h3><p>形状是可以独立于物体存在的。b2Fixture类就专门负责将形状连接到物体上。</p><p>一个物体可以有0/多个fixtures，有多个fixtures的物体被称为复合物体。</p><p>fixtures包含以下组件：</p><ul><li>1*shape</li><li>broad-phase检测的代理</li><li>密度，friction（摩擦），restitution（恢复系数）</li><li>collision filtering flags（？）</li><li>指向parent body的指针</li><li>用户数据</li><li>sensor flag</li></ul><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cfixture.png" srcset="/img/loading.gif" alt="image-20200710130809558"></p><h4 id="2-2-1-创建fixture"><a href="#2-2-1-创建fixture" class="headerlink" title="2.2.1  创建fixture"></a>2.2.1  创建fixture</h4><p>使用如下命令创建fixture：</p><p><code>b2Fixture* myFixture = myBody-&gt;CreateFixture(&amp;fixtureDef);</code></p><p>不需要保存fixture的指针，因为parent body被析构时会将其上附着的fixture顺带删除。</p><p>可以通过parent body删除其上的fixture（由此可以为能打碎的物体建模）：</p><p><code>myBody-&gt;DestroyFixture(myFixture)；</code></p><h4 id="2-2-2-密度"><a href="#2-2-2-密度" class="headerlink" title="2.2.2  密度"></a>2.2.2  密度</h4><p>fixture的密度是用于计算parent body的质量数据的。<strong>密度可以为0/正数。</strong></p><p><strong>最好对所有的fixtures都使用相似的密度，能提高效率。</strong></p><p>改变密度时，body的质量<strong>并不会自动变化，必须调用下列命令</strong>：</p><p><code>body-&gt;ResetMassData();</code></p><h4 id="2-2-3-摩擦"><a href="#2-2-3-摩擦" class="headerlink" title="2.2.3  摩擦"></a>2.2.3  摩擦</h4><ul><li><p>LiquidFun支持静摩擦和动摩擦，但两者系数相同。</p></li><li><p>LiquidFun使用库仑摩擦力（即摩擦力与法向力成正比）。</p></li><li><p>摩擦系数通常介于0-1之间，但可以是任何非负值。</p></li><li><p>两个物体摩擦时，采用的摩擦系数为：sqrtf( a-&gt;friction * b-&gt;friction )</p></li><li><p>上述默认的混合摩擦系数算法可以通过<code>b2Contact::SetFriction</code>改变，这是在<code>b2ContactListener callback</code>里完成的。</p></li></ul><h4 id="2-2-4-恢复系数"><a href="#2-2-4-恢复系数" class="headerlink" title="2.2.4  恢复系数"></a>2.2.4  恢复系数</h4><ul><li>用于让物体弹起来！</li><li>通常设置在0-1之间：0-不弹，1-刚好弹回到原位；</li><li>采用<code>b2Max( a-&gt;restitution, b-&gt;restitution )</code>进行混合（这样弹力球就可以在完全不弹的桌面上弹来弹去了）</li><li>可以使用<code>b2Contact::SetRestitution</code>改变，是在…里完成的。</li><li>当一个shape有多个contact时，回弹是近似模拟的。</li><li>碰撞速度很小时，LiquidFun会使用非弹性碰撞防止jitter。</li></ul><h4 id="2-2-5-Filtering"><a href="#2-2-5-Filtering" class="headerlink" title="2.2.5  Filtering"></a>2.2.5  Filtering</h4><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cfilter.png" srcset="/img/loading.gif" alt="image-20200710131000291"></p><ul><li>Filtering用于阻止特定fixture之间发生碰撞；</li><li>LiquidFun支持16个碰撞类（<strong>categories</strong>），对每个fixture你可以规定它属于哪个类，可以与哪些类碰撞。这是通过<strong>位屏蔽</strong>操作的</li></ul><blockquote><p>&amp;1 不变； &amp;0 变0。    |1 变1； |0 不变；</p><p>置位：变为1        复位：变为0</p><p><strong>位屏蔽</strong>：</p><p>屏蔽字中与要检查的位对应的位全部为1，而被屏蔽的位全部为0。</p><p>为了检查一个字节中的某些位，可以让这个字节和屏蔽字(bit mask)进行按位与操作(C的按位与运算符为＆)。</p><p>为了置位所需的位，可以让数据和屏蔽字进行按位或操作(C的按位或运算符为|)。</p><p>为了清除所需的位，可以让数据和对屏蔽字按位取反所得的值进行按位与操作。</p></blockquote><p>碰撞出现的法则如下：</p><pre><code class="hljs C++"><span class="hljs-comment">//如果A被B屏蔽后还有其他位 且 B被A屏蔽后还有其他位</span><span class="hljs-keyword">if</span> ((catA &amp; maskB) != <span class="hljs-number">0</span> &amp;&amp; (catB &amp; maskA) != <span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">// fixtures can collide</span>&#125;</code></pre><ul><li><p>LiquidFun还支持碰撞组（<strong>group</strong>）：正数index的同组物品总会碰撞，复数index的同组物品总不会碰撞。不同组之间也是通过category和mask bits来判断是否碰撞的（换而言之，group比category优先级更高）。</p></li><li><p>还有一些其他的filtering会出现：</p><ul><li>静态/kinematic物体上的fixture只能与dynamic物体碰撞；</li><li>同一物体上的fixture不碰撞；</li><li>你可以启用/禁用通过joint连接的物体之上fixture的碰撞。</li></ul></li><li><p>若要在fixture创造后改变collision filtering , 你可以通过<code>b2Fixture::GetFilterData</code>和<code>b2Fixture::SetFilterData</code>来获取和设置b2Filter的结构。这直到下一个time step之前都不会增/减contacts。</p></li></ul><h4 id="2-2-6-Sensors"><a href="#2-2-6-Sensors" class="headerlink" title="2.2.6  Sensors"></a>2.2.6  Sensors</h4><p>什么时候两个fixtures重叠但不发生碰撞呢？这是由sensors决定的。</p><p>sensors是一种专门用于检测碰撞、但不触发碰撞反应的fixture。</p><p>你可以把任一个fixture设置为sensor，可以是static/kinematic/dynamic。</p><p>记住，一个body可以有多个fixture，这可以任何solid fixture和sensor的混合。</p><p>sensor仅当至少一个body是动态的时候才会形成contact。</p><p>sensor不会生成接触点。</p><p>可以通过以下两种方式得知sensor的状态：</p><p><code>b2Contact::IsTouching</code></p><p><code>b2ContactListener::BeginContact and EndContact</code></p><h3 id="2-3-Joints"><a href="#2-3-Joints" class="headerlink" title="2.3. Joints"></a>2.3. Joints</h3><p>Joints是用来约束bodies在世界中的状态/约束bodies之间的关系的，在游戏世界中比较典型的有Ragdolls(布娃娃)、teeter(跷跷板)、pulley(滑轮)。Joints可以以很多方式连接，形成有趣的动画。</p><p>有些Joints提供limits，使得运动受限。</p><p>有些Joints提供motors，可以控制joint运动的速度，直到施加的力/力矩超过预先设置的限度；可以控制位置（通过调整速度使其运动）；可以模拟joint friction：将joint的速度设为0，提供一个较小、但能起决定作用的力/力矩，则motor会试图阻止joint运动，直到负载过重。</p><h4 id="2-3-1-Joint的定义"><a href="#2-3-1-Joint的定义" class="headerlink" title="2.3.1  Joint的定义"></a>2.3.1  Joint的定义</h4><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cjointdef.png" srcset="/img/loading.gif" alt="image-20200710154221125"></p><ul><li>Joint是通过b2JointDef这个类<strong>及其衍生</strong>（见上）定义的；</li><li>joint连接了两个不同的物体，其中一个可以是静态的。在static, kinematic物体之间的joint是合法的，但没有效果且会占用运行时间；</li><li>你可以为任一类关节指明用户数据，也可以提供flag允许相连的物体之间碰撞（默认情况下阻止）。</li><li>大多jointdef都需要提供几何数据。通常joint是由anchor point（锚点：在相连物体中固定的点）的局部坐标定义的（因此，即使现在的物体变化违背了joint的限制，也同样可以定义/指明joint，这在游戏reload的时候是常见的）。</li><li>有些jointdef还需要知道两个物体之间的默认相对夹角。</li><li>大多数joint都有使用当前物体变化定义joint的初始化函数（因为提供几何数据非常麻烦），但这些函数只应被用于制作原型。</li></ul><h4 id="2-3-2-Joint-Factory"><a href="#2-3-2-Joint-Factory" class="headerlink" title="2.3.2  Joint Factory"></a>2.3.2  Joint Factory</h4><p>使用world类中提供的factory来生产关节：</p><pre><code class="hljs C++"><span class="hljs-comment">//Example: RevoluteJoint</span>b2RevoluteJointDef jointDef;jointDef.bodyA/B = myBodyA/B;jointDef.anchorPoint = myBodyA-&gt;GetCenterPosition();b2RevoluteJoint* joint = (b2RevoluteJoint*)myWorld-&gt;CreateJoint(&amp;jointDef);<span class="hljs-comment">//DO SOMETHING</span>myWorld-&gt;DestroyJoint(joint);joint = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//防止太nasty的崩溃</span></code></pre><p><strong>重要：但凡关节连接的一个物体被摧毁，joint也会被摧毁！</strong></p><h4 id="2-3-3-使用Joints"><a href="#2-3-3-使用Joints" class="headerlink" title="2.3.3. 使用Joints"></a>2.3.3. 使用Joints</h4><p>许多模拟创造了关节后，在摧毁前就不会再调用它们。当然，在关节中有许多有用的数据可以帮你让模拟变得更加生动。</p><p>首先，你可以获取物体、锚点、用户数据：</p><pre><code class="hljs C++"><span class="hljs-function">b2Body* <span class="hljs-title">GetBodyA</span><span class="hljs-params">()</span></span>;<span class="hljs-function">b2Body* <span class="hljs-title">GetBodyB</span><span class="hljs-params">()</span></span>;<span class="hljs-function">b2Vec2 <span class="hljs-title">GetAnchorA</span><span class="hljs-params">()</span></span>;<span class="hljs-function">b2Vec2 <span class="hljs-title">GetAnchorB</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">GetUserData</span><span class="hljs-params">()</span></span>;</code></pre><p>所有关节都有reaction力/力矩，也即在锚点处被施加向body 2的力（见Distance Joint中的图）。可以使用反应力破坏关节，或触发其它游戏事件。</p><p>但这两个函数挺慢的，不要随便调用：</p><pre><code class="hljs C++"><span class="hljs-function">b2Vec2 <span class="hljs-title">GetReactionForce</span><span class="hljs-params">()</span></span>;<span class="hljs-function">float32 <span class="hljs-title">GetReactionTorque</span><span class="hljs-params">()</span></span>;</code></pre><p>接下来介绍各种奇形怪状的joint。</p><h5 id="2-3-3-1-Distance-Joint"><a href="#2-3-3-1-Distance-Joint" class="headerlink" title="2.3.3.1  Distance Joint"></a>2.3.3.1  Distance Joint</h5><p>最简单的joint，保持两个物体上各一点之间的距离恒定（应该在两个物体已经就位的情况下定义，指定两个锚点的世界坐标）。</p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Creaction.png" srcset="/img/loading.gif" alt="image-20200710160614198"></p><pre><code class="hljs C++">b2DistanceJointDef jointDef;jointDef.Initialize(BodyA, BodyB, worldAnchorA, worldAnchorB);jointDef.collideConnected = <span class="hljs-literal">true</span>;</code></pre><p>Distance Joint也可以被做成柔性连接，就像弹簧阻尼那样。方法是调整定义中的两个常量：frequency和damping ratio。</p><p>frequency就像吉他弦的振动频率一样，以赫兹为单位，一般来说它是time step的频率的一半。（与Nyquist frequency有关，不查了/kkl）。</p><p>damping ratio是无量纲的，通常介于0-1之间，但可以更大。在此例中，damping是关键的（所有震动都应该消失）。</p><h5 id="2-3-3-2-Revolute-Joint-旋转关节"><a href="#2-3-3-2-Revolute-Joint-旋转关节" class="headerlink" title="2.3.3.2. Revolute Joint(旋转关节)"></a>2.3.3.2. Revolute Joint(旋转关节)</h5><p>旋转关节强迫两个物体共享一个锚点，通常被叫做hinge point（铰点）。旋转关节只有一个自由度：两个物体之间的相对旋转角度，也即joint angle。<strong>物体B绕锚点逆时针绕时角度为正，用弧度计算，初始化时角度默认为0。</strong></p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Crevolute.png" srcset="/img/loading.gif" alt="image-20200710162449344"></p><p>关节的初始化函数假设两个物体已经就位，如下例：</p><pre><code class="hljs C++">b2RevoluteJointDef jointDef;jointDef.Initialize(myBodyA, myBodyB, myBodyA-&gt;GetWorldCenter());</code></pre><p>你可以通过limit和motor来控制关节。</p><p>limit可以使得旋转角度落在一定区间内。一般来说，这个区间应当包括0，否则在模拟开始时关节将暴走。</p><p>motor可以允许你指定joint的角速度（角度对事件求导），可以为正可以为负。motor可以有无穷的力，但这不是我们所希望的，想想这个问题：</p><blockquote><p>如果无穷的力遇上了不能动的物体怎么办？（超棒的矛和超棒的盾）</p></blockquote><p>所以最好给motor提供一个力矩的上限。motor会保持以设定速度运行，除非维持这一状态所需的力矩超出了所设定的最大值，此时关节可能变慢/倒过来转。</p><p>你可以使用motor来模拟joint friction。把joint的速度设为0，把力矩上线设的小但别太小。负载超过这个值时关节就会开始运动。（改的例子见Joints这一节）。</p><p>通过一系列Get和Set函数获取/改变（每个time step都可以改）关节的角度、速度、力矩。</p><p>joint motor有非常有趣的特性，你可以每个time step都改变joint的速度，从而让它像钟摆一样动：</p><p><code>myJoint-&gt;SetMotorSpeed(cosf(0.5f * time));</code></p><p>也可以使用joint motor来追踪想要的角度：</p><pre><code class="hljs C++">float32 angleError = myJoint-&gt;GetJointAngle() - angleTarget;float32 gain = <span class="hljs-number">0.1f</span>;myJoint-&gt;SetMotorSpeed(-gain * angleError);<span class="hljs-comment">//gain别设太大</span></code></pre><h5 id="2-3-3-3-Prismatic-Joint-平移关节"><a href="#2-3-3-3-Prismatic-Joint-平移关节" class="headerlink" title="2.3.3.3 Prismatic Joint(平移关节)"></a>2.3.3.3 Prismatic Joint(平移关节)</h5><p>平移关节允许两个物体沿着某个轴发生相对滑动，不允许发生相对转动。因此它也只有一个自由度。</p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cprismatic.png" srcset="/img/loading.gif" alt="image-20200710165307318"></p><p>平移关节的定义和旋转关节很相似，只需要把角度换成平移、力矩换成力即可。由此可以得到平移关节带limit, motor的一个定义：</p><pre><code class="hljs C++">b2PrismaticJointDef jointDef;<span class="hljs-function">b2Vec2 <span class="hljs-title">worldAxis</span><span class="hljs-params">(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>)</span></span>;jointDef.Initialize(BodyA, BodyB, BodyA-&gt;GetWorldCenter(), worldAxis);jointDef.lower/upperTranslation = <span class="hljs-number">-5.0f</span>/<span class="hljs-number">2.5f</span>;jointDef.enableLimit = <span class="hljs-literal">true</span>;jointDef.maxMotorForce = <span class="hljs-number">1.0f</span>;jointDef.motorSpeed = <span class="hljs-number">0.0f</span>;jointDef.enableMotor = <span class="hljs-literal">true</span>;</code></pre><p>旋转关节有一个未被指明的轴朝向屏幕外。平移关节则需要指明一个在屏幕内的轴，轴在两个物体间被固定，且跟随他们运动。</p><p>默认初始化时，平移为0，所以平移range应当包含0。</p><p>一样，有一系列Get和Set。</p><h5 id="2-3-3-4-Pulley-Joint-滑轮关节"><a href="#2-3-3-4-Pulley-Joint-滑轮关节" class="headerlink" title="2.3.3.4 Pulley Joint(滑轮关节)"></a>2.3.3.4 Pulley Joint(滑轮关节)</h5><p>滑轮关节可以创造一个理想化的滑轮，将两个物体与地面连接/互相连接。一个物体上升时另一个下降，滑轮绳的长度在一开始就配置好了。</p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cpulley.png" srcset="/img/loading.gif" alt="image-20200710173334581"></p><p><code>length1 + length2 = constant</code></p><p>也可以通过加一个比率来模拟滑轮组（<strong>高中物理，出现力</strong>），这会导致一边的绳比另一边延展的快，约束力在一遍比另一边小，可以用来创造<strong>杠杆</strong>。</p><p><code>length1 + ratio * length2 = constant</code></p><p>例：ratio = 2时，length1的变化速度是length2的两倍，绳1的拉力是绳2的1/2。</p><p>如果一边绳子拉没了，滑轮可能会出问题。最好防止一下。</p><p>它的定义如下：</p><pre><code class="hljs C++">b2Vec2 anchor1/<span class="hljs-number">2</span> = myBody1/<span class="hljs-number">2</span>-&gt;GetWorldCentor();b2Vec2 groundAnchor1/<span class="hljs-number">2</span>(x1/x2, y1/y2);float32 ratio = <span class="hljs-number">1.0f</span>;b2PulleyJointDef jointDef;jointDef.Initialize(myBody1, myBody2, groundAnchor1, groundAnchor2, anchor1, anchor2, ratio);</code></pre><p>可以用<code>GetLengthA/B() const</code>获取当前的长度。</p><h5 id="2-3-3-5-Gear-Joint（齿轮关节）"><a href="#2-3-3-5-Gear-Joint（齿轮关节）" class="headerlink" title="2.3.3.5 Gear Joint（齿轮关节）"></a>2.3.3.5 Gear Joint（齿轮关节）</h5><p>机械游戏当然需要齿轮啦！在LiquidFun里你可以使用复合形状来制作齿轮齿的模型，这有点慢且有点麻烦。你在排齿轮齿的时候也得小心，才能使得齿轮平滑地转动。</p><p>用齿轮关节制作齿轮就比较简单了。</p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cgear.png" srcset="/img/loading.gif" alt="image-20200710174517774"></p><p>齿轮关节只能连接旋转 and/or 平移关节。</p><p>你可以定义一个齿轮ratio，可以是负数。还要注意：当一个是旋转一个是平移关节的时候，需要提供一个角度到长度（或者反过来）的单位转化。</p><p><code>coordinate1 + ratio * coordinate2 == constant</code></p><p>下面是一锅厘子：（bodyA/B是两个关节提供的任一个物体，不相同即可）：</p><pre><code class="hljs C++">b2GearJointDef jointDef;jointDef.bodyA/B = myBodyA/B;jointDef.joint1/<span class="hljs-number">2</span> = myRevolute/PrismaticJoint;jointDef.ratio = <span class="hljs-number">2.0f</span> * b2_pi / myLength;</code></pre><p>注意到齿轮是依赖于之前那两个关节的，因此：</p><p><strong>总是先删除齿轮，再删除其依赖的关节/物体。否则出事。</strong></p><h5 id="2-3-3-6-Mouse-Joint-鼠标关节"><a href="#2-3-3-6-Mouse-Joint-鼠标关节" class="headerlink" title="2.3.3.6  Mouse Joint(鼠标关节)"></a>2.3.3.6  Mouse Joint(鼠标关节)</h5><p>鼠标关节在testbed中被用于鼠标操控物体，它试图驱动物体上一点向光标的当前位置移动，并未对旋转做出限制。</p><p>mouse joint的定义中有一个目标点、力的上限、频率、阻尼ratio。</p><p>目标点最初与物体的锚点重合。</p><p>最大力是用于防止动态物体碰撞时产生触发过于激烈的反应，设置成多大都没关系。</p><p>频率、阻尼ratio是用于创造弹簧/阻尼的效果的，与distance joint中的情况一样。</p><p>用户常常希望将鼠标关节改造后用在游戏里，做到精准的位置放置和立刻的反应，但鼠标关节在这方面性能并不好。<strong>你可能需要考虑使用kinematic bodies</strong>。</p><h5 id="2-3-3-7-Wheel-Joint-轮子关节"><a href="#2-3-3-7-Wheel-Joint-轮子关节" class="headerlink" title="2.3.3.7  Wheel Joint(轮子关节)"></a>2.3.3.7  Wheel Joint(轮子关节)</h5><p>轮子关节使得bodyB上的一点与bodyA上的一条线联系起来，并且提供了一个悬挂弹簧绳。</p><p><img src="C:%5CUsers%5Cybr19%5CDocuments%5C100%_MOREHAB%5CFiles%5CBLOGGER%5Csource%5Cimg%5Cblog%5Cwheel.png" srcset="/img/loading.gif" alt="image-20200711110933763"></p><h5 id="2-3-3-8-Weld-Joint（焊接关节）"><a href="#2-3-3-8-Weld-Joint（焊接关节）" class="headerlink" title="2.3.3.8  Weld Joint（焊接关节）"></a>2.3.3.8  Weld Joint（焊接关节）</h5><p>weld joint限制了两个物体之间的所有相对运动。可以看testbed里面的Cantilever.h（悬臂）了解相关信息。</p><p>你也许会想用weld joint来定义能打破的结构，但在LiquidFun的实现下关节比较柔软，所以通过weld joints连接的chain of bodies可能会屈伸（flex）。</p><p>事实上，创造能打破的物体时，不如从一个物体开始，往上附着多个fixtures。在物体破坏时，你可以把fixture摧毁然后在另一个物体上重建这个fixture。具体可以看testbed里面的breakable example。</p><h5 id="2-3-3-9-Rope-Joint（绳子关节）"><a href="#2-3-3-9-Rope-Joint（绳子关节）" class="headerlink" title="2.3.3.9  Rope Joint（绳子关节）"></a>2.3.3.9  Rope Joint（绳子关节）</h5><p>Rope Joint限制了两个点之间的最大距离，这可以有效地防止chain of bodies在过高的负载下延伸，详见b2RopeJoint.h + RopeJoint.h。</p><h5 id="2-3-3-10-Friction-Joint（摩擦关节）"><a href="#2-3-3-10-Friction-Joint（摩擦关节）" class="headerlink" title="2.3.3.10  Friction Joint（摩擦关节）"></a>2.3.3.10  Friction Joint（摩擦关节）</h5><p>Friction Joint是用于自顶向下的摩擦的，提供了2维的平移摩擦和角摩擦，详见b2FrictionJoint.h + ApplyForce.h。</p><h3 id="2-4-Contacts"><a href="#2-4-Contacts" class="headerlink" title="2.4  Contacts"></a>2.4  Contacts</h3><p>Contacts是用于管理两个fixtures之间的碰撞的。如果fixture有子对象（例如chain shape），则对每个相关的孩子都会存在一个contact。</p><p>contact有多种种类，都是b2Contact类的衍生类，用于管理不同种类fixtures之间的contact，比如有应付多边形-多边形碰撞的，也有应付圆-圆碰撞的。</p><p>先来看几个术语。</p><h4 id="2-4-1-Terminology"><a href="#2-4-1-Terminology" class="headerlink" title="2.4.1. Terminology"></a>2.4.1. Terminology</h4><p><strong>Contact Point</strong>: 两个shapes接触的点。LiquidFun通过几个点来模拟contact。</p><p><strong>Contact Normal</strong>：一个单位向量，常规情况下从fixtureA指向fixtureB。</p><p><strong>Contact Separation</strong>：这是penetration的反面。当形状重合时separation是negative的，有可能未来版本会出现带positive separation的接触点，所以出现接触点的时候最好检查下符号。（<strong>啥？</strong>）</p><p><strong>Contact Manifold</strong>：<del>（流形，出现力）</del>在两个凸多边形之间接触时可能会有两个接触点，它们共用同一个法向量，所以被组合在一个流形（=一个近似接触区域）里。</p><p><strong>Normal Impulse</strong>：normal force（我猜是法向力）是在接触点处防止形状互相穿透的力。为了便利，LiquidFun使用冲量。<code>法向冲量 = 法向力 * time_step</code>。</p><p><strong>Tangent Impulse</strong>：切向力在接触点产生的（与摩擦有关）冲量。</p><p><strong>Contact Ids</strong>：</p><p>LiquidFun试图循环使用一个time step产生的接触力结果，作为下一个time step的初始猜测值。LiquidFun使用contact id在time step之间匹配接触点。这些id包含了几何特征的指标，以区分各个接触点。</p><p>contact在两个fixture的AABB重合的时候创建。有些时候collision filtering会阻止contact的创造。AABB停止重合的时候contact会被摧毁。</p><p>所以你可能会注意到，有些时候两个fixture不接触的时候contact也会被创造。这就是“鸡生蛋”的问题。如果contact对象不创建，我们就无法通过contact来分析碰撞，从而真正知道contact对象到底是不是需要被创建的。如果形状没接触，我们可以立刻把contact删掉，但也可以干脆等到AABB不重合了。LiquidFun决定采用后一种方式，效率更高。</p><h4 id="2-4-2-Contact类"><a href="#2-4-2-Contact类" class="headerlink" title="2.4.2  Contact类"></a>2.4.2  Contact类</h4><p>之前已经说过，contact类是由LiquidFun创造和消灭的，Contact对象并不由用户创造。当然，你可以获取其中信息并与其互动。</p><p>你可以访问raw contact manifold：</p><pre><code class="hljs C++"><span class="hljs-function">b2Manifold* <span class="hljs-title">GetManifold</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">const</span> b2Manifold* <span class="hljs-title">GetManifold</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;</code></pre><p>理论上你可以修改manifold，但不资瓷，除非需要进阶用法。</p><p>还有一个helper function来访问b2WorldManifold：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetWorldManifold</span><span class="hljs-params">(b2WorldManifold* worldManifold)</span> <span class="hljs-keyword">const</span></span>;</code></pre><p>它使用了物体的当前位置来计算接触点的世界坐标。</p><p>Sensors（不碰撞的fixture）不会创造manifold，所以你可以这样使用：（对于non-sensor也可以啦）</p><pre><code class="hljs C++"><span class="hljs-keyword">bool</span> touching = sensorContact-&gt;IsTouching();</code></pre><p>可以从contact那里获知fixture，进一步获知body的信息：</p><pre><code class="hljs C++">b2Fixture* fixtureA = myContact-&gt;GetFixtureA();b2Body* bodyA = fixture-&gt;GetBody();MyActor* actorA = (MyActor*)bodyA-&gt;GetUserData();</code></pre><p>你也可以禁用contact，这只在b2ContactListener::PreSolve里面有用，见下文。</p><h4 id="2-4-3-获取Contact"><a href="#2-4-3-获取Contact" class="headerlink" title="2.4.3  获取Contact"></a>2.4.3  获取Contact</h4><p>可以用几种方式获取contact。</p><p>（1）可以通过world/body的结构直接访问；</p><ul><li><p>可以遍历world里面所有的contact：</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (b2Contact* c = myWorld-&gt;GetContactList(); c; c = c-&gt;GetNext())&#123;    <span class="hljs-comment">// process</span>&#125;</code></pre></li><li><p>可以遍历一个body上产生的所有contact，他们都通过边连接存在一个图里：</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (b2ContactEdge* ce = myBody-&gt;GetContactList(); ce; ce = ce-&gt;next)&#123;    b2Contact* c = ce-&gt;contact;    <span class="hljs-comment">//process</span>&#125;</code></pre></li></ul><p>（2）可以实现一个contact监视器类：见下文</p><blockquote><p>注：使用world/body遍历可能会漏掉一些在time step中间短暂出现的contact，使用监视器能得到最为准确的结果。</p></blockquote><h4 id="2-4-4-Contact监视器"><a href="#2-4-4-Contact监视器" class="headerlink" title="2.4.4  Contact监视器"></a>2.4.4  Contact监视器</h4><p>监视器支持几种不同的事件：开始，结束，pre-solve, post-solve。</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyContactListener</span> :</span> <span class="hljs-keyword">public</span> b2ContactListener&#123; <span class="hljs-keyword">public</span>:   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BeginContact</span><span class="hljs-params">(b2Contact* contact)</span> </span>&#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EndContact</span><span class="hljs-params">(b2Contact* contact)</span> </span>&#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreSolve</span><span class="hljs-params">(b2Contact* contact, <span class="hljs-keyword">const</span> b2Manifold* oldManifold)</span> </span>&#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostSolve</span><span class="hljs-params">(b2Contact* contact, <span class="hljs-keyword">const</span> b2Manifold* oldManifold)</span> </span>&#123;&#125;&#125;;</code></pre><blockquote><p>注：不要保留送到b2ContactListener的指针的引用。你应该使用深拷贝将接触点的数据拷贝到你自己的buffer里，例子见下文。</p></blockquote><p>在运行的时候，可以创造listener的一个对象，并且使用b2World::SetContactListener函数登记。确保在world对象的生命期内监视器都是可以访问的。</p><p>（1）<strong>开始</strong>：当两个fixture重合的时候调用，sensor和non-sensor都会调用。这类事件只会在time step内部出现。</p><p>（2）<strong>结束</strong>：当两个fixture停止重合的时候调用，sensor和non-sensor都会。如果一个body被摧毁的时候也会调用，所以可能在time step之外出现此类事件。</p><p>（3）<strong>Pre-Solve</strong>：在碰撞检测结束之后、碰撞解决之前调用。这给了用户根据当前配置禁用contact的机会。例如：你可以使用这个callback实现一个一边封闭的平台（如：只出不进），并且调用b2Contact::SetEnabled(false)。每次在处理碰撞的时候contact都会被重新启用，所以每个time-step都要禁用contact。由于碰撞检测是连续的，pre-solve事件可能会在每个time step每个contact被触发多次。</p><pre><code class="hljs C++"><span class="hljs-comment">//一段不太明白的代码</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreSolve</span><span class="hljs-params">(b2Contact* contact, <span class="hljs-keyword">const</span> b2Manifold* oldManifold)</span></span><span class="hljs-function"></span>&#123;    b2WorldManifold worldManifold;    contact-&gt;GetWorldManifold(&amp;worldManifold);        <span class="hljs-comment">//如果平台过于平了</span>    <span class="hljs-keyword">if</span> (worldManifold.normal.y &lt; <span class="hljs-number">-0.5f</span>)    &#123;        <span class="hljs-comment">//就禁止接触？</span>        contact-&gt;SetEnabled(<span class="hljs-literal">false</span>);    &#125;&#125;</code></pre><p>pre-solve事件也可以用来决定point state还有碰撞的来袭速度：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreSolve</span><span class="hljs-params">(b2Contact* contact, <span class="hljs-keyword">const</span> b2Manifold* oldManifold)</span></span><span class="hljs-function"></span>&#123;    b2WorldManifold worldManifold;    contact-&gt;GetWorldManifold(&amp;worldManifold);    b2PointState state1[<span class="hljs-number">2</span>], state2[<span class="hljs-number">2</span>];    b2GetPointStates(state1, state2, oldManifold, contact-&gt;GetManifold);    <span class="hljs-keyword">if</span> (state2[<span class="hljs-number">0</span>] == b2_addState)    &#123;        <span class="hljs-keyword">const</span> b2Body* bodyA/B = contact-&gt;GetFixtureA/B()-&gt;GetBody();        b2Vec2 <span class="hljs-built_in">point</span> = worldManifold.points[<span class="hljs-number">0</span>];        b2Vec2 vA/B = bodyA/B-&gt;GetLinearVelocityFromWorldPoint(<span class="hljs-built_in">point</span>);        float32 approachVelocity = b2Dot(vB - vA, worldManifold.normal);        <span class="hljs-keyword">if</span> (approachVelocity &gt; <span class="hljs-number">1.0f</span>)        &#123;            MyPlayCollisionSound();        &#125;    &#125;&#125;</code></pre><p>（4）<strong>Post-Solve</strong>：</p><p>​    post-solve事件中可以收集碰撞的冲量数据。</p><p>​    你可能很想在游戏中基于contact的callback函数改变物理世界情况。例如，你可能想使得某个碰撞触发角色或刚体的受损。但LiquidFun不允许你在callback函数里更改物理世界的情况，因为你摧毁的物体可能正在被LiquidFun处理，这可能导致孤儿指针。</p><p>​    建议的处理方法是：把所有的接触数据存下来，然后在time step之后再<strong>立刻</strong>处理。这时候你可以更改物理世界，但仍然要小心不要让接触数据缓冲区里出现孤儿指针。testbed里提供了不产生孤儿指针的安全的contact point处理的例子。</p><p>​    下面这段代码展示了处理contact buffer的时候应当怎样处理orphaned bodies。这是一段摘要。所有的接触点都在b2ContactPoint数组m_points里存储。</p><pre><code class="hljs C++"><span class="hljs-comment">//接下来通过接触点数据删除一些物体</span><span class="hljs-comment">//一定要缓存删除的物体的数据，因为可能会在多个接触点中存在，不保存会删除空指针</span><span class="hljs-keyword">const</span> int32 k_maxNuke = <span class="hljs-number">6</span>;b2Body* nuke[k_maxNuke];int32 nukeCount = <span class="hljs-number">0</span>;<span class="hljs-comment">//遍历contact缓冲，将接触物体比自己重的的物体删除</span><span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; m_pointCount; ++i)&#123;    ContactPoint* <span class="hljs-built_in">point</span> = m_points + i;    b2Body* bodyA/B = <span class="hljs-built_in">point</span>-&gt;fixtureA/B-&gt;GetBody();    float32 massA/B = bodyA/B-&gt;GetMass();    <span class="hljs-keyword">if</span> (massA &gt; <span class="hljs-number">0.0f</span> &amp;&amp; massB &gt; <span class="hljs-number">0.0f</span>)    &#123;        <span class="hljs-keyword">if</span> (massB &gt; massA)        &#123;            nuke[nukeCount++] = bodyA;        &#125;        <span class="hljs-keyword">else</span>        &#123;            nuke[nukeCount++] = bodyB;        &#125;        <span class="hljs-keyword">if</span> (nukeCount == k_maxNuke)        &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-comment">//排序，去重</span>    <span class="hljs-built_in">std</span>::sort(nuke, nuke + nukeCount);    int32 i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; nukeCount)    &#123;        b2Body* b = nuke[i++];        <span class="hljs-keyword">while</span> (i &lt; nukeCount &amp;&amp; nuke[i] == b)        &#123;            ++i;        &#125;        m_world-&gt;DestroyBody(b);    &#125;&#125;</code></pre><h4 id="2-4-5-Contact-Filtering"><a href="#2-4-5-Contact-Filtering" class="headerlink" title="2.4.5  Contact Filtering"></a>2.4.5  Contact Filtering</h4><p>这是用来阻止部分物体之间的互动的。（例如，创造一个门，只有特定的角色能穿过）</p><p>LiquidFun允许你通过实现b2ContactFilter类来自定义contact filtering。这个类要求你实现一个ShouldCollide函数，接收两个b2Shape指针，返回是否该碰撞。</p><p>默认实现使用了之前定义过的b2FilterData。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">b2ContactFilter::ShouldCollide</span><span class="hljs-params">(b2Fixture* fixtureA, b2Fixture* fixtureB)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">const</span> b2Filter&amp; filterA/B = fixtureA/B-&gt;GetFilterData();    <span class="hljs-keyword">if</span> (filterA.groupIndex == filterB.groupIndex &amp;&amp; filterA.groupIndex != <span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">return</span> filterA.groupIndex &gt; <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">bool</span> collide = (filterA.maskbits &amp; filterB.categoryBits) != <span class="hljs-number">0</span> &amp;&amp; (filterA.categoryBits &amp; filterB.maskbits) != <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> collide;&#125;</code></pre><p>你可以在运行的时候创造一个你自己的contact filter，然后使用b2World::SetContactFilter来注册。请确保在world生命期内它始终可以访问。</p><p><code>world-&gt;SetContactFilter(&amp;filter);</code></p><h3 id="2-5-World类"><a href="#2-5-World类" class="headerlink" title="2.5  World类"></a>2.5  World类</h3><p>b2World类包含了物体、关节，负责了模拟的所有部分，允许非共时的请求（AABB/ray cast/etc.）。你绝大部分的互动都是与b2World对象进行的。</p><h4 id="2-5-1-创造-消灭一个世界"><a href="#2-5-1-创造-消灭一个世界" class="headerlink" title="2.5.1  创造/消灭一个世界"></a>2.5.1  创造/消灭一个世界</h4><pre><code class="hljs C++"><span class="hljs-comment">//doSleep = 物体能睡觉吗？</span>b2World* myWorld = <span class="hljs-keyword">new</span> b2World(gravity, doSleep);<span class="hljs-comment">// do something</span><span class="hljs-keyword">delete</span> myWorld;</code></pre><h4 id="2-5-2-使用世界"><a href="#2-5-2-使用世界" class="headerlink" title="2.5.2  使用世界"></a>2.5.2  使用世界</h4><p>世界类包含了创造、摧毁物体、关节的工厂。</p><h4 id="2-5-3-模拟"><a href="#2-5-3-模拟" class="headerlink" title="2.5.3  模拟"></a>2.5.3  模拟</h4><p>指定time step，指定速度、位置的迭代数目。</p><pre><code class="hljs C++">float32 timeStep = <span class="hljs-number">1.0f</span> / <span class="hljs-number">60.f</span>;int32 velocityIterations = <span class="hljs-number">10</span>;int32 positionIterations = <span class="hljs-number">8</span>;myWorld-&gt;Step(timeStep, velocityIterations, positionIterations);</code></pre><p>在每个time step之后你都可以检查你的物体、关节，获取信息。一般你都会从物体处获得位置信息，以渲染他们。你可以在你的游戏循环的任意位置启动一个time step，但要注意做事情的顺序。</p><p>例如，你应该time step之前创造物体，这样才能获取他们的碰撞数据。</p><p>最好使用固定的time step。time step越大，在低帧率的场景里游戏的性能表现就越好。但一般来说，time step不应当超过1/30秒。1/60秒的time step可以使得模拟质量较高。</p><p>迭代次数控制了constraint solver将遍历contact和joint多少次。迭代越好，模拟效果肯定更好。但不要将time step变大以增加迭代次数，60Hz + 10次迭代要比 30Hz + 20次迭代效果好得多。</p><p>在stepping之后，应该把施加在物体上的力清零。这是通过b2World::ClearForces这个命令完成的。这可以让你在几个sub-step内都使用相同的力场。</p><h4 id="2-5-4-探索世界吧！"><a href="#2-5-4-探索世界吧！" class="headerlink" title="2.5.4  探索世界吧！"></a>2.5.4  探索世界吧！</h4><p>世界是由物体、接触、关节组成的。你可以从world这里获取它们的列表并遍历。例如：</p><pre><code class="hljs C++"><span class="hljs-comment">//叫醒所有物体</span><span class="hljs-keyword">for</span> (b2Body* b = myWorld-&gt;GetBodyList(); b; b = b-&gt;GetNext())&#123;    b-&gt;SetAwake(<span class="hljs-literal">true</span>);&#125;</code></pre><h4 id="2-5-5-AABB查询"><a href="#2-5-5-AABB查询" class="headerlink" title="2.5.5.  AABB查询"></a>2.5.5.  AABB查询</h4><p>有些时候你想要查询一个区域内的所有图形。b2World类提供了一个log(N)的使用broad-phase数据结构的函数。你可以提供一个世界坐标下的AABB，并且实现b2QueryCallback。世界会对于每个与你提供的AABB重合的AABB的fixture调用你提供的类。返回true的时候查询继续，返回false的时候查询中止。</p><p>例如：如下代码找到所有可能分割了你提供的AABB的fixture，然后把它们相关的物体都唤醒：</p><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueryCallback</span> :</span> <span class="hljs-keyword">public</span> b2QueryCallback&#123;  <span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ReportFixture</span><span class="hljs-params">(b2Fixture* fixture)</span></span><span class="hljs-function">    </span>&#123;        b2Body* body = fixture-&gt;GetBody();        body-&gt;SetAwake(<span class="hljs-literal">true</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;...MyQueryCallback callback;b2AABB aabb;aabb.lowerBound.Set(<span class="hljs-number">-1.f</span>, <span class="hljs-number">-1.f</span>);aabb.upperBound.Set(<span class="hljs-number">1.f</span>, <span class="hljs-number">1.f</span>);myWorld-&gt;Query(&amp;callback, aabb);</code></pre><p>不要随意猜测、假设callback的顺序。</p><h4 id="2-5-6-Ray-Cast"><a href="#2-5-6-Ray-Cast" class="headerlink" title="2.5.6  Ray Cast"></a>2.5.6  Ray Cast</h4><p>你可以用ray cast进行视线检查、开枪等操作。通过实现一个callback类 + 提供开始和结束点，就可以进行一次ray cast操作。</p><p>world类会对每个被光线束击中的fixture调用你所提供的类。你的callback函数能调用的数据是：fixture，分割点，单位法向量，分割下来的沿光线束距离（小数）。不要随意猜测、假设callback的顺序。</p><p>你将返回一个小数，来控制ray cast是否继续。返回0意味着ray cast中止，返回1意味着ray cast将假装没有击中的fixture，返回之前传入的小数意味着光线将被截断在当前的分割点。这样，你就可以ray cast一个图形/所有图形/最接近的图形（通过调整返回的分数）。</p><p>甚至还可以返回-1，使得光线忽略这一个fixture，假装被击中的这个fixture不存在。</p><p>例子如下：</p><pre><code class="hljs C++"><span class="hljs-comment">//获取最近的形状</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRayCastCallback</span> :</span> <span class="hljs-keyword">public</span> b2RayCastCallback&#123;  <span class="hljs-keyword">public</span>:    MyRayCastCallback()    &#123;        m_fixture = <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-function">float32 <span class="hljs-title">ReportFixture</span><span class="hljs-params">(b2Fixture* fixture, <span class="hljs-keyword">const</span> b2Vec&amp; <span class="hljs-built_in">point</span>, <span class="hljs-keyword">const</span> b2Vec2&amp; normal, float32 fraction)</span></span><span class="hljs-function">    </span>&#123;        m_fixture = fixture;        m_point = <span class="hljs-built_in">point</span>;        m_normal = normal;        m_fraction = fraction;        <span class="hljs-keyword">return</span> fraction;    &#125;    b2Fixture* m_fixture;    b2Vec2 m_point;    b2Vec2 m_normal;    float32 m_fraction;&#125;MyRayCastCallback callback;<span class="hljs-function">b2Vec2 <span class="hljs-title">point1</span><span class="hljs-params">(<span class="hljs-number">-1.0f</span>, <span class="hljs-number">0.0f</span>)</span></span>;<span class="hljs-function">b2Vec2 <span class="hljs-title">point2</span><span class="hljs-params">(<span class="hljs-number">3.0f</span>, <span class="hljs-number">1.0f</span>)</span></span>;myWorld-&gt;RayCast(&amp;callback, point1, point2);</code></pre><p>由于近似的原因，ray cast可能会在你的静态环境中从多边形之间的小缝隙之间穿过去。如果这不行，请把你的多边形适当调大。</p><h4 id="2-5-7-力和冲量"><a href="#2-5-7-力和冲量" class="headerlink" title="2.5.7  力和冲量"></a>2.5.7  力和冲量</h4><p>你可以在物体上应用力、力矩、冲量。当你应用力/冲量的时候，要提供负载应用的地点的世界坐标。这通常会导致一个质心上的力矩。</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ApplyForce</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; force, <span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-built_in">point</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ApplyTorque</span><span class="hljs-params">(float32 torque)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ApplyLinearImpulse</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; impulse, <span class="hljs-keyword">const</span> b2Vec2&amp; <span class="hljs-built_in">point</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ApplyAngularImpulse</span><span class="hljs-params">(float32 impulse)</span></span>;</code></pre><p>应用力/力矩/冲量都会唤醒物体，有些时候你不想这样（例如，提供一个恒定力，但希望物体睡着提供效率）。这个时候可以这样做：</p><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (myBody-&gt;IsAwake() == <span class="hljs-literal">true</span>)&#123;    myBody-&gt;ApplyForce(myForce, myPoint);&#125;</code></pre><p>你可以给粒子/粒子组提供力/冲量，但你并不能在任一个点提供。事实上，力/冲量将被应用在每个粒子的中心上。</p><p><code>myParticleGroup-&gt;ApplyLinearImpulse(impulse);</code></p><h4 id="2-5-8-坐标转换"><a href="#2-5-8-坐标转换" class="headerlink" title="2.5.8  坐标转换"></a>2.5.8  坐标转换</h4><p>body类为你提供了点、向量在局部、世界坐标之间的转换。不明白这两个概念的话（？<strong>是我</strong>）请读*”Essential Mathematics for Games and Interactive Applications* by Jim Van Verth &amp; Lars Bishop。这些函数在内联下很快：</p><pre><code class="hljs C++"><span class="hljs-function">b2Vec2 <span class="hljs-title">GetWorldPoint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; localPoint)</span></span>;<span class="hljs-function">b2Vec2 <span class="hljs-title">GetWorldVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; localVector)</span></span>;<span class="hljs-function">b2Vec2 <span class="hljs-title">GetLocalPoint</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; worldPoint)</span></span>;<span class="hljs-function">b2Vec2 <span class="hljs-title">GetLocalVector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> b2Vec2&amp; worldVector)</span></span>;</code></pre><h4 id="2-5-9-列表"><a href="#2-5-9-列表" class="headerlink" title="2.5.9  列表"></a>2.5.9  列表</h4><p>你可以遍历一个body上的fixture。这主要是在你需要访问fixture的用户数据的时候管用：</p><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (b2Fixture* f = body-&gt;GetFixtureList(); f; f = f-&gt;GetNext())&#123;    MyFixtureData* data = (MyFixtureData*)f-&gt;GetUserData();    <span class="hljs-comment">//DO SOMETHING</span>&#125;</code></pre><p>遍历一个物体的关节list的方式也类似。</p><p>body也提供了一个相关contact的列表。但要小心，因为列表里不一定包含了所有在上一个time step存在过的contact。</p>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
      <category>LiquidFun</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
      <tag>LiquidFun</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diary: 2020/07</title>
    <link href="/2020/07/03/Diary-2020-7/"/>
    <url>/2020/07/03/Diary-2020-7/</url>
    
    <content type="html"><![CDATA[<blockquote><center>七 月 不 远</center><br /><center>作者：海子</center><br /><center>——给青海湖，请熄灭我的爱情</center><br /><center>七月不远</center><center>性别的诞生不远</center><center>爱情不远——马鼻子下</center><br /><center>湖泊含盐</center><center>因此青海不远</center><center>湖畔一捆捆蜂箱</center><center>使我显得凄凄迷人</center><center>青草开满鲜花</center><br /><center>青海湖上</center><center>我的狐独如天堂的马匹</center><center>（因此，天堂的马匹不远）<center>我就是那个情种：诗中吟唱的野花</center><center>天堂的马肚子里唯一含毒的野花</center><center>（青海湖，请熄灭我的爱情！）</center><br /><center>野花青梗不远，医箱内古老姓氏不远</center><center>（其他的浪子，治好了疾病</center><center> 已回原籍，我这就想去见你们）</center> <br /><center>因此爬山涉水死亡不远</center><center>骨骼挂遍我身体</center><center>如同蓝色水上的树枝</center> <br /><center>啊，青海湖，暮色苍茫的水面</center><center>一切如在眼前！</center><br /><center> 只有五月生命的鸟群早已飞去</center><center>只有饮我宝石的头一只鸟早已飞去</center><center>只剩下青海湖，这宝石的尸体</center><center>暮色苍茫的水面</center></blockquote><h2 id="2020-7-3"><a href="#2020-7-3" class="headerlink" title="2020.7.3"></a>2020.7.3</h2><p>假期已经过去 <strong>半 个 月</strong>，成绩出了，音梦计划的结果也终于下来了。</p><p>我这半个月完全就是废人生活……懒得听新歌，懒得看新书，懒得做音乐，懒得思考。躺在床上看完全没有意义的各种无聊媒体商品，时间过得比做白日梦还快。然后就一点一点放松神经，脑细胞演化为空心肥皂泡，掉进可耻的资本主义消费陷阱里。</p><p>我完全赞同假期拿来摸各种鱼，但还是想摸漂亮一点别致一点的鱼。因为塑料金鱼摸起来就像马桶冲水把手，哗啦啦地用无聊取代恶臭，让人摸到五感退化四支僵劲不能动，没劲儿。要摸鱼，就要摸食人鱼、翻车鱼、蓝色金鱼和戴着海盗眼罩的小丑鱼。摸遍所有鳞片倒立、色彩诡异的鱼，才知道什么是真正的好鱼。</p><p>况且还有大作业和OOP考试和小学期三座大山等待着我。放眼未来，三分感伤，七分凄凉。</p><blockquote><p>胡适之啊胡适之！你怎么能如此堕落！先前订下的学习计划你都忘了吗？子曰：“吾日三省吾身。”不能再这样下去了！</p></blockquote><p>唉。总之，从今天起：</p><p>听新歌、看新书、编曲，与世界热切地交流吧！</p><p>向洋流、海鲜市场进发，去寻找好摸的鱼儿吧！</p><p>写作业、学OOP，也在所谓正途上认真地行进。</p><p>在夏天就应当做夏天的事，不是吗？</p><p><strong>绷紧神经，做有水平的咸鱼</strong>。</p><h2 id="2020-7-4"><a href="#2020-7-4" class="headerlink" title="2020.7.4"></a>2020.7.4</h2><p>今天更新了头图、社交号、categories、icon等等一系列设置。</p><p>依然没有开始写大作业，sigh。明天一定。</p><p>看到了一个腾讯与一堆音乐学院与清华合作的音乐比赛，决定参加，得把正式录音提上日程了。</p><p>玩会儿OPUS，看会儿书，睡了。</p><h2 id="2020-7-8"><a href="#2020-7-8" class="headerlink" title="2020.7.8"></a>2020.7.8</h2><p>好久没更新博客内容了……今天就记一些很杂的感想。</p><p>昨天更新了微博的配置，然后又刷手机看无聊视频（我真真是无聊之王）到很晚。<strong>所以今天开始立志早睡</strong>。买了小闹钟，预备23：00手机、iPad关机，坚决执行早睡早起的条令。</p><p>明天开始固定去自习室，大作业再不做我真就要糊了。</p><p>申请了网易音乐人，通过了验证但还没上传作品，正在纠结是先传个Demo还是等录好音了再传。</p><p>真的很感谢听摇滚、看诗、看书的这位大哥，每天都以身作则，激励我去听经典作品、去读诗、去了解和思考，否则我这种懒狗估计也就是每天打打游戏就过了。</p><p>今天上素描课的时候很困，三分之一的时间在听素描老师和来的朋友闲扯，讲新一代艺术工作者的发展前景、深入分析（或辩护）自己某天与某个人发生的一场争吵。我非常羡慕他们拥有的高谈阔论的能力。此种能力的缺乏往往会让我觉得讨论艺术、生活、价值、道德这类宏观话题远远超出了我的智力范畴，从而无法进行类似的深入交谈。同样，我也很敬佩他们对于尴尬情绪的巧妙处理。</p><p>最近看景物、人脸变成了一件有趣的事，可以分析素描结构、看光影的移动、颜色的明暗深浅。我自觉对于视觉美感有了更明晰的认识。</p><p>明天开始，把听歌看书作为一件重要的日程，往博客里不定期传一些对专辑的观后感。</p><h2 id="2020-7-9"><a href="#2020-7-9" class="headerlink" title="2020.7.9"></a>2020.7.9</h2><p>（事实上是7.10补记的，耶。）</p><p>算是小有成果的一天。早上起得比较晚，带咖啡出去遛弯，遇上略有侵犯性的小雨，然后就收拾收拾去了自习室。</p><p>一整天都在看LiquidFun的文档，写了又臭又长的翻译式笔记。中途不想学的时候听了几张专辑，并且开启了“听后感”这一栏目。</p><p>晚上回到家，捧着一大碗蜂蜜柚子酸奶看1994红磡（奇怪的组合），久违地戴上了头戴式耳机，舒服至极。看完了唐朝出场前的部分，泄洪式地在博客上吐了好多感想。睡得稍微有点晚。</p><p>今天不知为何，与家人说话的兴致不高。</p><h2 id="2020-7-10-11"><a href="#2020-7-10-11" class="headerlink" title="2020.7.10/11"></a>2020.7.10/11</h2><p>两天都在自习室，生活平淡，就一起记了。</p><p>发觉每天发一篇日记独占一篇blog有一点傻，所以决定每个月写一篇，换月的时候把旧的那篇加密（日记还是限时开放好了）。</p><p>争取这个周末解决LiquidFun文档的阅读和游戏的初步设计，玩Sally Face，听沼泽和景德镇，把1994红磡看完。在读上个假期读了一半的史铁生先生的杂文，感到自己写dramatic日记的时候有一些这种文风的特点（想到哪写到哪，排比，大词，浅显的譬喻，煽动性）。</p><p>自习室的洛神花茶好酸——（啧）！洛神花茶不应该是甜甜的嘛！</p><p>音乐证书！打算冲冲冲，有这个项目的话假期就不预备自己学乐理了（树莓没了至少有个这，华大让我好欣慰）。</p><h2 id="2020-7-12"><a href="#2020-7-12" class="headerlink" title="2020.7.12"></a>2020.7.12</h2><p>玩了一整天Sally Face，终于通关啦！预计之后还会打二周目三周目。</p><p>当然，看完文档的计划又延后了。（红磡也没看完，Cubase也还没重装）</p><h2 id="2020-7-13"><a href="#2020-7-13" class="headerlink" title="2020.7.13"></a>2020.7.13</h2><p>连轴转的一天。早上在家看文档，下午上素描，晚上去自习室看文档。（还是没看完…）</p><p>素描课进行了三周，我的耐心和兴趣已经大大地折损了（怪不得我小时候没学成画画…），下个月还要不要继续学呢？不过下午的课画得还不错，仔细研究后把上周画得鬼鬼祟祟的苹果修改得像样了一点。之后两节课都是画一个复杂的羊头，感觉自己画不完(sigh)。</p><p>下午飙车回家的时候看到路上出了车祸，摩托车主貌似还受了伤，之后骑车去自习室的时候骑得就很慢很规矩。</p><p>晚上试图用自习室的玫瑰花泡水喝，结果泡出来是一股枣皮味儿（。）</p><h2 id="2020-7-16-21"><a href="#2020-7-16-21" class="headerlink" title="2020.7.16-21"></a>2020.7.16-21</h2><p>太久没写了。这几天其实发生了很多事，但频繁出门，懒得坐下来认真地写点什么。</p><p>周四（7.16）去和好兄弟出门玩儿了。在这之前担心了很久（社恐本能习性），但一切顺利。我在社交中的尴尬阈值提高了挺多，值得庆贺。</p><p>周五周六和妈妈一起去大理玩了。第一次编了辫子，吃到了很好吃的菜，洱海边环湖路的风景也超棒！</p><p>周天到周二在画最后一张素描，画了一组比较复杂的静物。终于画完啦（觉得自己画得还不错，虽然老师觉得我构图/黑白关系都不太好 &amp; 虽然我的线条很乱）。下周开始学水粉，课变成一周两次（否则大作业真的做不完了）。</p><p>好像是周一用一个晚上通关了Red Strings Club，和酒保行动画风相似，但讲的是一个更加完整的故事。我觉得总体设计很不错，游戏性很棒（总游戏时间比较短）。游戏过程中在音乐、故事推进的带动下非常投入，但现在回想起来印象消退太快、后劲不强，主要的记忆点在于故事设计（但其实也是有点cliche的大反派AI）。音乐棒！</p><p>中途自闭了半天，亢奋了半天。In a moody state right now。</p><p>P.S.：昨天晚上终于下定决心懒得再次录音，直接用demo提交了MCF比赛 &amp; 网易音乐人（已经通过啦）（想想我2min制作的封面就觉得好笑）。</p><p>P.P.S：昨天晚上强行加入了华大在高中的招生团，决定去见识一下大家打算怎么蒙骗可爱的考生们。有一位一直以来散发weird pride让我感到有点不适的美女一直一副掌权人的样子劝我不要去，大概算是昨天晚上最好笑的事情，也更坚定了我去看热闹的决心。</p><p>P.P.P.S：大作业一个dll找不到的问题已经困扰了我3天了。今天不解决誓不为人。</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diary: 以雪标记的日子</title>
    <link href="/2020/07/02/Diary-%E4%BB%A5%E9%9B%AA%E6%A0%87%E8%AE%B0%E7%9A%84%E6%97%A5%E5%AD%90/"/>
    <url>/2020/07/02/Diary-%E4%BB%A5%E9%9B%AA%E6%A0%87%E8%AE%B0%E7%9A%84%E6%97%A5%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这篇日记写于去年冬天，大抵是北京初雪或第二场雪后。</p></blockquote><p>北京的雪果然是不一样的。</p><p>在这样一场声势浩大的雪面前，所有的譬喻都会失去颜色。</p><p>我在雪的第二天出发，听见自行车轮压扁雪的声响，看见树枝上泛起的白浪，看见所有的一切被这个冬天温柔地抚摸、又诗意地埋葬。风吹过的时候一些雪又从树枝上掉落下来，然后昨天的印记就一点点融化进大地里。在这时，下雪不再是存在而是某种遗忘。</p><p>我不亦乐乎地占有着新雪，我把足迹遍布那些还没有被踩实的雪窝。</p><p>窗外的树很大。透过窗子看一点点掉落下来的雪，像是在看一个重复播放的屏保动画。唯一担心的，是树上的雪不能像电脑里面那样永生永存；一点一点，一点一点，这场雪就温柔地离开了。</p><p>下雪的确是不平凡的事件。我们好像都是靠这些细碎的罕见之事在标记着每一个相似的日子；有时候我们还给它赋予仪式，在一段时间内品尝由这些庆典带来的期望和回味。</p><blockquote><p>此处应该有我去年冬天拍摄的雪景，但好像要搞图床啥的乱七八糟，之后再说。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反思我想不通的几点</title>
    <link href="/2020/07/01/%E5%8F%8D%E6%80%9D-%E8%AE%B0%E5%BD%95%E6%88%91%E6%83%B3%E4%B8%8D%E9%80%9A%E7%9A%84%E5%87%A0%E7%82%B9/"/>
    <url>/2020/07/01/%E5%8F%8D%E6%80%9D-%E8%AE%B0%E5%BD%95%E6%88%91%E6%83%B3%E4%B8%8D%E9%80%9A%E7%9A%84%E5%87%A0%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>刘遥这破事断断续续闹了大半夜，我和野合的铁粉朋友一直交流着，真切地经历了这件事的发酵、争论和潦草的收尾（当然，刘遥这个疯批还在继续他的性骚扰“行为艺术”，不知还会不会惹出其他后续）。</p><p>我对于野外合作社并没有像我的朋友那么深的执着，但我的确觉得他们是一支非常、非常、非常、非常好的乐队。王海洋的词曲和表现力，刘遥的吉他，让野合对于音乐主题的各种构想都流通起来：生命力、文学性、自由幻想，呼应着各自奔放。</p><p>如果我没有因为写不下去游戏测评郁闷到打算听会儿摇滚，而是早睡后第二天醒来看到朋友发来的此事各种后续，我也许就只会替野外合作社、替朋友感到无关痛痒的难过和惋惜（从了解刘遥之后，这样的事态发展太过于意料之中了）。但我因为睡不着，看着这件事情一步步演化，看到网友们都说要野合给个交代，看到海洋说找不到人，看到野合说找不到人，看到野合说开除，看到海洋说非要这样么，看到刘遥这个没有心的开了新号继续口头杀人放火，看到第二天早上起来各大音乐博主转载开除声明，看到海洋删博。很难过，真的，很压抑。像看到Freddie滥交、耍大牌、放弃队友，或是看到陈荒赵谬吵架、脆组在facebook发政治言论，就是很压抑。</p><p>这件事情逐步升级，前来围观顺便骂刘遥的人也越来越多，我的态度也就越来越情绪化。</p><p>所以，呼——深呼吸。仔细捋一捋，把其中尽可能多的角度从源头开始厘清。我尽量理性。</p><h3 id="关于性骚扰和炼铜"><a href="#关于性骚扰和炼铜" class="headerlink" title="关于性骚扰和炼铜"></a>关于性骚扰和炼铜</h3><hr><p>尽管刘遥从他发表言论以来就一直是个疯批，这件事的发酵则是由他近一个月来的诡异“养女”言论和其他怪话——更直接地，昨天对未成年演员叶驰敏的性骚扰——引起的。</p><p>（这么一想，刘遥有点像药水。我真的非常好奇这两个人在现实生活中是怎样的。有人说刘遥所指的“养女”是他感情很好的22岁女朋友，有人说刘遥在现实生活中幽默，有人说他沉默。我倒并不相信他会现实生活中遵纪守法，微博只是行为艺术而已。）</p><blockquote><p>关于最基本的论证基础</p><p>首先，我将采用最朴素的道德原则，即：实行权利的前提是不侵害他人的权利。我将认为合理法律的制定是源于这样的原则。但同时，我将保留一定的质疑：社会有权无条件、无偿地要求所有人为公共道德阉割自己吗？</p><p>其次，我也无意使用专业术语论证这件事的法律性质。我的话语仅代表自己粗浅的理性。</p></blockquote><p>好。</p><p><strong>第一点，关于性骚扰。</strong>性骚扰的罪过在于让被骚扰者感到不适。刘遥的言论应该已经完全到达了普遍公众的“不适”标准，因此确实是恶心的性骚扰，这点他活该。</p><p><strong>第二天，关于炼铜。</strong>刘遥的出圈言论是性骚扰+炼铜两大罪过，所以无论如何他被万人唾骂是罪有应得，乐队开除他也是最合理的选择。但我现在撇开刘遥这个个案不谈，仅谈一谈炼铜本身。</p><p>首先，炼铜之罪在于幼女由于身心的不健全，在法律上并不具有性自由（是这样吧？），因此为避免以“爱”为名的诱奸、强奸等违法行为，法律对幼女实行了以限制自由为手段的强制保护。这是非常合理的法律，但在其中有“一刀切”的成分（这存在于许多法律之中，并不意味着法律不恰当），也就意味着有一部分人群的权利受到了抑制。</p><p>假设有一个不能通过与正常年龄人群发生关系获得性快感的恋童癖，他明白他的性癖付诸行为将意味着某个孩子成为受害者，因此他克制、克制。他出于对公共道德的遵循，完全剥夺了自己的性自由。在我的眼里，这是很悲剧也很英雄的事，值得社会为他颁发一块奖章，给他提供定期的生活补助，定时去看望并给他带一束花。</p><p>但在当今时代大概“恋童癖”三个字就是赤裸裸的罪行，如果真出现了这样的人也会受到万人唾骂，与今天刘遥的结局也不会太不同罢。我于是想起来《肌肤》里那个恋童癖父亲，为了不侵犯自己的孩子便远走他乡，再也没有回过家。我觉得很难过。同样的辩护在我的心中对于天生有鲨人、施虐冲动但克制未实施的精神病也成立。</p><p>我在为极少数人心里的恶魔辩护。这有意义么？</p><p><strong>不对，等一下。</strong></p><p>我突然意识到这一情形与某个困扰过我的场景的类似性。</p><p><strong>愚蠢、残疾、丑陋，许多在当今世界会成为不容置疑的缺陷的品质，不也很大程度是天生的么？</strong></p><p>我们从出生之日起都背负着与卡西莫多类似的枷锁，对这样的原罪我们或多或少都无可奈何。我们无辜地降临于世，外貌、智商、家庭、偏好就已经为我们此后的人生之路画下一道道藩篱。只能背负而已。无论是恋童癖，或是不擅长读书，或是出生于恶劣的原生家庭，所有的参数冰冷而无罪，附着到某个个体身上才变成善恶奖惩。</p><p>我们能做的最好的选择就是彼此同情、彼此支撑，但背不住十字架的人还是得下地狱。</p><p>好吧，我释然了一点。</p><h3 id="关于艺术与人品与立场-与网民"><a href="#关于艺术与人品与立场-与网民" class="headerlink" title="关于艺术与人品与立场 与网民"></a>关于艺术与人品与立场 与网民</h3><hr><p>刘遥有病该骂，毋庸置疑。</p><p>但乐队其他成员是无辜的，作品是无辜的。这件事发后，我的第一反应居然是把野合的歌全部下载。</p><p>好悲哀。……。艺术本就不只是为真善美的颂歌，更与立场无关，不是吗。</p><p>我突然想起，在相关微博下看到一条评论，是阴阳怪气说希望刘遥能够进局后继续创造人民群众喜闻乐见的音乐。虽然原po主是在反讽，但我倒觉得，如果哪天他真做了什么需要进局的事儿，这种结局也不错。</p><p>我完全支持大家骂刘遥。我只希望作品不要下架，乐队也不要因此解散。有乐迷因为这件事选择不再听野合也没有关系，别妨碍我继续听就行了。每个人都有价值判断，别按头。</p><p>我感到很难过的一点是，这件事后，野合的评论区就变成了吵架战场。粉丝和前来骂刘遥的网民打成一团，说的话和音乐本身再也无关。</p><p>另外难过的一点是，搜狐新闻发了报道后，大家纷纷在下面评论“根本没听过这种没名气的乐队”。滚圈独树一帜的好乐队连同其作品，因为乐手的行为被贬到一文不值，成为一部分人义愤填膺的靶子，一部分人幸灾乐祸的对象。好多人是在狂欢啊。</p><p>野合的结局不该是这样。海洋该有多愁啊。</p><p>还有，顺便再评论另一件事儿罢。我实名讨厌阴阳怪气的骂人。如果你要骂人傻批或者不道德，那你就骂他傻批或者不道德，阴阳怪气骂人属实让人想吐。</p><p>所以我现在开骂：骂人时随便就咒人死甚至牵扯家人的都是傻批。刘遥傻批。</p><blockquote><p>后半段写于7.2，朋友从刘遥微博小号发的动态怀疑他想不开要自杀。如果他真的死了，无疑是将这场行为艺术风波在任何意义下推向了顶点，这也是我同意他有可能这么做的原因。</p><p>但无论如何，他很有才，他到目前为止所做的傻批事完全不至死，所以我还是希望他能好好活着。</p><p>希望海洋能和他好好谈一谈，希望他们不要闹翻，希望野合以后继续做音乐。我希望着。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Comment</category>
      
      <category>News</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Comment</tag>
      
      <tag>News</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏测评：OPUS 灵魂之桥</title>
    <link href="/2020/06/30/%E6%B8%B8%E6%88%8F%E6%B5%8B%E8%AF%84%EF%BC%9AOPUS-%E7%81%B5%E9%AD%82%E4%B9%8B%E6%A1%A5/"/>
    <url>/2020/06/30/%E6%B8%B8%E6%88%8F%E6%B5%8B%E8%AF%84%EF%BC%9AOPUS-%E7%81%B5%E9%AD%82%E4%B9%8B%E6%A1%A5/</url>
    
    <content type="html"><![CDATA[<p>想了很久，写什么都怪怪的。</p><p>就这样简短地作结吧：</p><ul><li><p>画面很好，是我很喜欢的风格，中间涉及人物对话的动画有点草率；</p></li><li><p>游戏设计也很用心，整个世界历史非常完整；</p></li><li><p>玩法也比较适合我这种无水平选手；</p></li><li><p>音乐没有特别出彩，但很契合剧情；</p></li></ul><p>故事非常、非常、非常棒。最后1h的呈现，让我由衷地想：<strong>如果能做出这样的游戏，就算是997我也愿意</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Comment</category>
      
      <category>Games</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Comment</tag>
      
      <tag>Games</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diary: 2020.3.6-4.22</title>
    <link href="/2020/06/30/Diary-2020-3-6-4-22/"/>
    <url>/2020/06/30/Diary-2020-3-6-4-22/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Locked words wait for your command to be unlocked:</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="2107cee15ceabcac4d39b76524f39640a6b6d33c8e914a643580abb9fc8ab6e6">f0881f13f18f60e3b2fc7fd4e26d5e119ea8bfaed4e1f11bc1dff2540e1b00bb242bae9921bca7aa638dc60aa4701a059fb1d5bff04a27ebcf8fb3b29e7e9331b9abf6cb693bf619a0b62c53980d002d610d0116bbf2970361f9e1c91c6d8158a7c431fe0a80e68250539dbafc3bdaa7fee36e91e2e30bea1d7c95ef2f4ba4dfa89f7ddf59bec7df0765e35507d599958dbb3c6dd8d7bef194a118f4c979cdabe5504bf93852771ccbc4840a05aafffb1db67d65d551bae54669e5822baf93e851ea350f10a51521a8a01db3fdbc850e6629f6b761a64f2c55b4e13a3a36252ce616bc57e0fefa4086fd86a76029e0e22030284e02b8f1978b1feb8bcccb7a79f3a1cd209ea502f6fb30f71c0c179c3332928927b4ba92bd099c19a4cb2704d1cc246759808a848ca62c32734a25a6808a9547183fcb5898b8a8f5a452ccbca7dd9cc609ac0332603b0a68a5a3a1343986f6618ba2b86744f7158c849211b3ae3c462897cdf21e145eae87f7e5b11f3ced2919ede61e3e42dfffa06e60cc38e496d7aeab6e7c44bba929cb55a1cbf7c84b683b956b93f2fa4629d601c45e0a424a3e82fb0c4a50b14b782e7ce1e001598b49c3a31e1262397df575e7f45ac64d374c217a7ad0ba291f550482be9c214c1cb047addd7e4c65b733d20a5eefab84f70baa8f331c98a4b31e863908fa3a1c47f9e990866b8909dabcf53c39c0b03578ccfe02c503a6937fd44d592854c176d23fd22c0ac9e9a0e66318e074d2753c7e66a49e6ff5d1d4ed9f21252096725226f272098d30e46e1da8e77b45f10f8f27e0c29039810d9a55c9ced349065ddd5b23b17ac81c5154913dc2ccb3b2c46d2bf4d2b242e2fb21d8ce8938861fd14cf8c02fc8733157db5704ad7e4e41c9549897172d2448da340cc4b21cb8f2ec70871f48aa29f94ca39a1031446c003a9dd705e1cec230b79a3c06872ce0217b5173e0c0f194deda50d10c197f1bd47a3c2129050c1b3f7ec69aa0025e5312325526f51a25627bd597b4fbad16198841e19455aea7b1e94fdca7d0396613db88dd95cd902aa1753b31441fe446f09c020c1adc54eb6ed53d44244a71cf1740c36dd190dba5382e39b77a927bb3a907598f3a1af10b6d6f36a1cb801f01f386f4bff5c9706f9cec1184bb6a2865684d44d8f08d247bb57a5c78d10c997088a59e4742db211c7027386bf452a3cf19f2481b3bf387d6b241c8772a653ebee203214e40c0345605c2fc916b6aa6df09a448e1b3488cb6c6fab17ec6ab0e76c3cf50e368d12f14af75cf945c726714677d7eddc51a90965951a23a2c8cd728a98ccdfd172b0c91cb4dc79437b390b2ef4500f70da620d8c6efb072653990973efb559e96b59d69546ab5ba36d0c2ff76a5ece24263ffc19ca59bf544f5402ac942f9eca7d54ecb1f32677c7f40324842e6d9c4206aacd8bab6e77ae149f52d640fef014964330d8bad9d1ecf61554276b062f8e0c456a38ffc2df7fcc61c2516be9f590ee6a59410284ed61cc1706d6c50e41c7e7fb8e82ce9492e29b5513306c6dc68cfc5833c296367e838c53a42097e56f0a95e2e1761199ec183f918a074de4b33c4d31b6ed9cf7d78be9494b791ef385b94bc41a4cf8da219337b12a4b3ddb38012597a5458e6ae52a22593d3af6c5ce0084c5ff776c28aabd204bbf173e486ab244fb20aa8b11ad19aa1e5327ae0cc3b2de6258e67760e72b52388c7aec95d50d8190123aa4f65e1d4fe1506e663b89279f2829d0677bc525345eb2e30934d6847def62e7cd763d5d61eb21d1d90e4c82017c5dcda783ec2fc3f1b2cf73e7ef4024bd01a03811d38e29c073016610ce19891b2ad4e0b2378337a87f9a8e0c841c07df0899799a118fea4b9324901b08658ac14c4ec87cc4890dac07270cee522fbd5367383107e37e66b7ddd526e986987112f252b2c9d6391b7ffc5b7cd538f94a75b324f4ca419a34e801165287f8ec97b0835cb49b641a84e22666da07e7e12da55809185dce004a3696e4f78878b9accdab77cf1116c9ea5c584fc712c5db7f420fb407d705f06ee0e74a862ae813f9379810265a8d8d1aaf009fe7b8866dbf1d74e39d1c54857fa705ecc453d33bc41a5a474c1b37f95fd8a359de42a241ee5524a96da10ddca85497bf5378aadab77db5dba84e24c8e57117eb89087f9c54c5c40360a3641c6ee5e42a27785380a902c829e30431c0504d176b58653f6d01abeec31c2be235d5a3263a0bf87a2237cf49dcb44b1017671b70b88540a823ea6431878dcb37cdb4e7f5f8024cc050f4385ddb03424eb97d9685460f63e891d41c9dddd3c9c73c2b50f0f9a3c9f40a4356d8657ef8fdbf43a13f12a8e139ebc7886ecc2678217c4786cb7449781ccecbe9160f856cf281ac2021942e1fd7e657f063c46b817eabd45b90d18a5553b5df3d0ac7af301c4341acfe5aaf7e114a4348c8e93717c54a9ade9dc06f7443c7b5700b01227e5578d08c938e5cc70eb8d8a55b252e6a3e1e9e8935e7bae6af74a2523b4a319fa29260fc051ceb9f70135a1daaba12204dcdf0cd7b7be076a01d64550c6c174537b8a85d0e8506b2ce1fed924c19c404f4c6e12f17ac1a3b0ab8663846e288955b45181455c3603c62162bc3ce5d4d0b983aa653974ca88bfadb47ed95a26ce9e8b0b408e82bd37f63472facd2cb9a35dd8482166ec506e72ffb43719aa2e833268435009ff204daacaf3a89bb88e4217319bb7526a0a9b3105e38b863698c15684ce157f9499d06bae75330b7d3a73e5ddf59220c09899b597861a8b5e2c1c96053d04564b09ad026b82108be8b7e814317048975dc5a14668aebbd9caf7c6c4cd5cb1c7eb4bf333eb303338a2d0161281412000b2ecce16d304bc08eba31df5fe4ed5689a4e055b20d0cfa34996a055304dfb2e1583bd63d5f7199f456d4dce9a250836dfcd569ee0c13cd990ea886eeb965b37a198c25b62d986483a29d808857b04ebd84e9a5175e6ee3eb3588fb6735d94c3b6bd4a78f5db208f9bed47ffbced162406a9fde1677dfc73549a2fab2996fa4773330c25938193ace45e2abc2a91c7fe8eb6fd0de045fedf5e34dff79133aad72e330e5f6892da232d7639ac1dcbf39ae3cf6d7e4a94c922e7d395aefa88be79471aff6d41c4369d53af6c5d8296d0449b5cbb7dc312c2b0ff8f5aa314f65f0a3b160e59fbbe8fd90cdf8f56043d67ba8c36a8fcccd1042e7fded6ef13b529162ca65b200e631bfb06a02b193d04dff5d2446b642614fd5ed9f83588de97367ea47d73594aa02ec0c116b7eb402a15a85b7701785965ca5bdce471cd0dc7eddeba2b0439c3b1531909c4515018818ec454da615adacdba92a3772d1e2426fd106596a8ad6dfbae944bd98ed1e8878d46d0f7878e067f24d5ae54eb32c35ba263656de008fad364072bd92640e61f8eeb50aeb0ebe280910eda8db74fe1a3cd101e75685fd1b33823529d6cb7bc5cd3c2a35b8212a4f48a7a934d9bc3ced72d02ab77cce3dbb625300387b953368a697256f57b7841a25f5217f0a91286b162b0395d582790f0fbd80827787824fc4ef858023c1501da06217b85e8d90050862d97ed40db23e0439f19ea445bd4571daf00aec6fb1f94f667bae4f5505b065293ce6969a1f6211b461a00bdef6dd581cac4368324225a5a8f795686e9c716aef7fe421cd0a7ef971b0db01f69b9a49c53dcbf88ec3c2054da4ddf33cb0ae840db28e99a6b7162306e99382be45a60971924ee0a9016f7766f81fd454fb589c996aee7fe25e207fc08904ea6e92318dc450e48378c18bdfe481538e4335c557019c4fde582a0544266a7afbbd941dc6f1b3d1003f0644d7074364dce8b99f6b71c69cf6d9e28e88230b0f45cd620e561fc0ea19c2906af771bb395fdfe6bc55da7a6dc096d53beff80ae85090fc990fb2d8b299406686dc14ce338cd5dcbbaeb7d18f0a61ad434922ea4ed1d983519299d2ebb38c83d479285a6c67ecc6c93f47b798b84aadeed0feb1204b0c9d8fc05ec4295c009757fb55f5a6e8566745a3c4f54c586c6c2031e432ed582646c27e096a0ead18a0c3a9fc77805363379eb22f0689c63abeb3ff3b9280b21130cfe918df780ccef34553c3e49268e615e870c3a7f40e9ba8d80703c652167d1c114cb97adfa416d028cb59887d88fc00db8456b3d259446b0cd953e85f57ae04c5b26e17f3e0ebab0fd5ae3555f5909cf239efb4216dcff583b387234efa1bee4d1673043c9e295a2c449fcef3db3d503a1123f12ad2696c19e861a6798fe2319cb4bb99726ebbd6b91da08f19528407b3d73da5fecbafbe6a395576a37f03d8ec5397e4f42ee539a48175b1b64dd3a674f17122f1c05da0a0d7df05c6a7a9bfd96fe3107f68420b8bbb07a4aec57d378c44c7344d7665d10b56dfb48ea95e74f1954a87979faf58789889a7159a891c3d92443cfaa1d1682045732be5b3676fd66d98a59ff925f2e09416fa79af9d70124094b12e410969765d9c0301ac97ee6468a3067f3a63d454fab285f857ebe762148771b51edc7e84990f21ac64f685b7449fa68e09f15e9d6ff6bb956b4bc818868990cb639781959d058e069c6fd39cbaf5644e62db0c6ddba8e4bf5234f695fccbd09fc27c3f5ca5d8f28817ec8f8a52a73a8878a56571cc53e33a770dbb6917232ece16578efdb1415c08b977d5b563a322ef2da3042f65e5c825df4c6ff325ba74d34e26ce85acf43c5350b5787aae47981604b1355b86c490ddd44fd2a5a7d59d544512fb2c227d449d0bc615c60304d9005716b76020f1b2cc637833ed6f5fb2483aea1617c628dea1b91656eff0c0ae755758e2c3fb99db366bcae99c37ec0cddd8aa7bb2f23c2027310537fc31b6411f6e721dbbac8f606a05b6e764d74ac291f818414284b314898374028b875aa51e4615f143d6984c1370293e4c5ec9e813904d3a8c7024e266bb7022c8b6f3231be707f308039b9a2ff3a333119312fa5b3b1799ff6c5e2d21c863849b39448f655279f921d52b43f0fa82cc7e00daa4136cca43873aeaea6c4385adfc07e47e9a51c27abf1da0d2e3b648c28a91b2e70144f239e2bd8f45c9768f8b1a3e8110ebf8822932875d86703c13c41fa601f1b42648963a20f0e33f805daf1ba0af02dc7527f3168da1ca2917e861f5dd70ac2750066b624d35d956e1478be991b73153d881bbe1599dcd2e3c49e18c5915ed2520b114c4700563daf080e3b2b101f8be68ddf01a69b4b805e039c90ab8a792b0d7e45cdd1458721c6cda2cbb215ddf5d218275cf70c3a9fabef00a3c96b5ce78e5df7a3f8a69d9a869dcd2206c54068ea591b4ac811901a03a209e544ad06fa72f7dd94e1e78f0d2c17e7df4a540ce8d97161c5ce9d4837a6def242b8889b2f33c7d9d443a81cb88e70ab3b5a0725f0e046e4f58bfebda45d6fdbf9d5dafa90e0f9dd0e21211789089295f1afa4a83d2227b9289d5aa5801194f447de536227980a83b054e02449345bb98967bd21a61bf13d27d081ec06d0d92cdd967611eb41c74c17962fcdfeec5066e3c90a4b0fdbe29e5e4bacd726392363826d7475b71db5bf73f3099be061e167c260c9dbdd7a0fd78ef96e9ba81829cbbfbf669f92619f60d9810526ceb530468cdd4efd70e763e274074e1ec7c7a3e441960a88480957243f93d5a0e4a394c11d99a571ff929e56be5ef27d777929650ab823f6b5e73b3a07f5e194ddf85dbe66f14d072570168fd37cbb79e1dc4c2b13b2a39e2f871b22d34e8e08568fe34d8ef7a3f87e84348a55dbc276c7150e4f7b7d11defd6a0c3c63050b7571b2e7d3854d46d0276c4fce62b2207cbfa5283fec0844654fd53fcafe6f78151fd339ac5ba72b8f0e44eae0b125f19b241e6e518e690e7c800c8c1ecf0ef4929209314104eb8a7ecc5113b78a477e67902eb4b257e7ff3e2b49839fdb4a8290329fdc869e304317f05251cd240f3e7c113408941d3a22b59afa67d5311d41c37dbface09b0ebf9509d88b7bbad0a235dff5dbe10ead77e22e9611fb88fd79d5e8e8b979639bae0b88d994f42fe394ffe05726af23167bc77384c0cbc163d912852de3ab909f502e99988bee3744f2c46eda8253cb55d587e1cc5c8f97304e7d06ed02824cd9b6d2811e0f6c54bbf04c3af74ae8893bf48f4d3f413e7937060db1134fe3cdc4935100c2b2e750be33a7eaa1eb7473ba5cda0d4cf102b8c1c951f2b838769caed33408dfc8f0ea26153ff68879b7e26b7d42588a9e3d8203295ca5713e6bd7dcdea11ab538284b3f1b56c4d265a65ef08a12660ac2086be5fbd6f52cf1626e2cc31ab35e2debf4454a909c665b0aa350ed9c33537ab6e094ca8f8c883bdd01193b38eb8758f5ba5fba68c0e178e088ec07f020883c6e0e740a2c12938e9a9b031561470c840fc53879b527b1a0af0da35d4cb7bac32da76b7af30b94f57afc7b5163daa3f08da3c1fbc5290fd0a27244c629b0346733bf68650be6d657eaa4a7d3d39f7a7978ef5a6c3a7e9885d979d75f9fb265467691fa8dc1bf58fdc0cdb0f6c8513c45db3e5ba8add7cd14d3d56a5326ac951305a46f8ad7204e2c985e4dc41b941e7e5926a888445113af679a6ee1588d0e498ea6c1ddb7f56fedfc12e38f531956dfd74cd574ba4a7d7c684b7c54c358af22741e0d6a28b7f80fc34801d21327216196b695aff4ad3d24582c5424623a7d0f6a4aa61228fe02ce3ed0158d421f1d5932a638c95e2293639fb96f9d3be4668767ac6bf69f0df17f88abcd6b8e446cc2adc10b76fae366aa4146d50b91ec3c36432c76192db20996976f8ee7379a1e7bc4b35967f0831893e5fd51ac3ea7d04eb604ccab80b5a0d16ff954a297ee2fc696701d55b0e0744661eadd868192f5cfb8ed4b0938f941283823deaafdcc1bcf106b603f176045bf637f1012905d29f2a512ef89b5c39d4527a3d7851b34824898c543746ee5ece9f219652f96dd1b348d448386e1c75d77e6f4521fe3e7e41f1dfad352d8735a8963e4f33dd114906b22e8900d9f740980ddb2a9c4c2372a9e6a27a8385efbd48611787160a2e9cc9e48e3839cabdd2626751d56d518e09a41c77e26325af1bff2418c96a94993e324499217bcc8e20c45214247f51ad61dfdda3d7cf2098bd97102fc269f52369a183820dc009cb0db96dc6ec069993d51ceb115b2ce43a700d6a4b606a239bfbab35a2b50b3f99217a15dcf3ca905d3340dc4c140e5118b0b3102fa395b0fd5876452b27a09dced1446404c2167f7516757872048dcbb31544f80eea0cba3a866bee459496919ec65731a96eeb35c3faf666de49e5066ce9134a8ceffce189839c944a221823509d853e02d4d61d10b9647536a5c5dd042fde524bf34b78d0749fd29eb58a81c0dd6b310b9587c684e106479078977aec84825f442f19a9b40879e878095afeab2a2d615f1da0b71f8fa18781190321aed211786d727d407fcfaa24e7bb50763afa6823d46cdc03a45c8a01f337168ec89da2c0a88530136c2d987ae18fccdd6657ac1ab7522800e185000ab64f8fb901456954d09511ca5953fa794e2124205053c293f998709bcbb0519a9654fefd9f64bc10d45e67a180b8241f077585d9614ac81de21b27ebc9b711cef4bd7273a118b9c7833de6e45672aca915e892112c47c3b6e31f30afba6bf505762cdd2a543fc8b35fdeb2dd7cb7220a4ca2b9fa7e9a28c7ed796b8c263441ead8fdc72b23918ed9ac230b741738c2d5d8ebd611712f4dc2c25bb97bcbba8fd7f2ed6e86b719c99be69b147719571137cbdb5eee18ab96830eb85d3b0e8a6ae356090435e860973d8cd8e029922d44bfc415dc9e452410a65a501366e078b81fe442d15929b82b132e3473a424c46f8d5b5588429541ab3632a91eb87d9940bb3dd9014e386636c0372a5aa3da45964cad7b1797acd7ff09538e0dd4c8d5c105d7b71036290568793c469b554ba37bf807eebca0d9c2ccb7303260c682f3ff0221a4304e86691d74de6ef5229d0cbe2aab9180d45e7b19302636a7d5ddc41bc23a85c7876d90f383ee300e2e5d09c4db184736e76274ea34688259f28bfd05eaed620a245e82e94efb27793fe3e19039c5a742387657afc1149c8677ed77a3eb19678e68bc1c3c866393b28cda23e2b9890c10a22ed456c1b809358749bb57f5bffde5dd8c169455543c136d475818f44f12433cbc1c62586a3386814473ba32e85c50cf7a08e1b0f7d2d545fc7f19b7b8694939568535394066050c7926bcf95dce3b811273c1c30668a22c108967e09dd318b15f240bb3cb0bc191885efd02512e7cd4bd7eabb1e940eb8d7912dda934347796f1c97e008868de207b4e96bc02aeb0291eca51a287967c6dfbc172510da2515e8c864c9cbebee76cf53c828a2810a5c85ee806c7bf22978e665e26115a72d8b3f819e7d99a67e2478dbd23b9f47b386275b228749bbe2b045a663a4fa34f02c53f07dab9830694f27cbea50cb651cffee6c5493b2ed078673890473a3ecce1321334197f242d09e6e088e21b71e5968cb106c5df5631671d152df56bb1c0838c7b3516b844a968a8e3711383b5acba4d8235b9148b6ae256b607adc1b5aec690412cf08a6465cdfd67fbbd2b63434f305562d41c0a2db15426132c74d002c23623791e37b4f6dc19dbaefbb70f8bff161a497bc094c3305abec6eab8c15f6a67c19fc9bd551c853142f8033cfc26be2d3fb0505d40744e0262abf2df1c2175cdcbd75b51707c075ee539e8800578d4d2f7806a896601ff1562b06145c7bdfe1c012b128fe3b64fc623a444cbf878d59586ad033e1af077d72c637e32ef7d8e987c0a13b99338281da8d087ec60c068a18d4f61ff37e2aafd2629e4177a56529dca65e584210f2ea2d17a9557aa56bb9fb5bf8a330f9f0f67ee00d87aa77d3402d5a72b1b0f6fddd5a38ea11b67c0f906dcd964785d3bb35e4f200ebcd3fef86564d53474c2f7bab79efb9dc28425010a62f21f52e154c73369764f452046ad0964fd67c72c13338cf8a819a155795b2a4f4f886c65f97957fb6622f2247de5d30d6bb8b94277f8128dd63892f9bc77fb47c05b215270d5518c339bf2096a529281d17983445a8a0fb49ed263e7a97eb1a2eb0de3ec6418261c2daffc23070168264ea8c83fd308d17862dcbf63e0f56db5e64d1b709e96c6fe0b9beb4c21b715b509ed372b5edc8942c6351d18a7cb5a4acd933c09c033a9f23c72d67f42b688a54c87979c0d744ffadc5ea709cfd514dfd30ecd40055deec0a518603f2b240eaa3b0e770dbc6cdda24b16501456b6fc44065464996f7d22622fb6d03055f5e1e465161f1687e4d535abe7d0c56f2b4b3367defa0254ef162e73b711a029eb00b38c1cdc4fdb941668b3442cfd371a880f07e8d105a244ba8bd2a2d64f0a670d045b3363a6e81771d356d6a2e00afa60cd5117590841274ffe5800061c85ea044f689908bcdfc02ac7c96f3d78510b4df1c72852372b57b2c63bfe4fdc069d7a7a57ff5d0010dd7fcf35422c8db7075c22d905a759c264c06bdea3606f5d92416fc2c6e704292ecf812ec6778265cec03b021039b33b2cd90835a1ae1a6f028194b6108a8c30583ee857b23c15b6acc816e4e103696310ec284c32a7652f6874fad8563bc4202161f9e300d8312ff54840f07cb3ea05fb58c5e43f6d01dd7219e9805d39cf3a7289ae2d15b2c1bc9bba0ecf262d0686011523ef217bccdf7891da865b7c00c9f26e118404851883bc70330e9fa4ee424d8189f0e24d2ef9bd119f35053b37657835497229542f3c9389292af78143b0f9e7baa190101613b8fb83a3e45dad5ef0a989b3db6ecba0afa3776078f7ddb2d629896f34364903acb901de74b2c6b54c3388449cdbf04f0aaa8e5584fb50440355c838c2833064a313252b5509fdc697fe1e2c6ded1cf9fe7f65f36004e083f78991131e27b1f3f726cb90b57c2a7c2e5048e9ef9f0cf64bd7ac721e100bbcb6fee791f38ffc419a617dcd5ee050890954b8e86253279c59abd6a5ca646ca7de8a239fbf522b64c0a0bc4b7c5c1afce8cb103aa78657d6d93ac13aa98cbaf0def2b4f3191cf56d900ef9eea1a0f7008f9c9e2e2059738c225ab9c223bc83cddc58001a44ca17cacf774c4b4e8a4b3c1eb16d28b43b0d22042f41f9b46a790e69fd7a553f63daa9c87e681588bb5cc4e94d1f82009e05f6ce07eb7e2eb02e38c698989e83cb5c7d2e8baa5316cd21874a2d348b8028f585668a67906aaf7e6713c56287d4e711e0cc3f8fc63dfc3d5e4422ffb9b4addd53c2938e4c890cc319a2b45d401a737e24baecc657e6da3f08b5c242e780fb7b08126d16c1cd6f9455561af4ba01245517b566d3ec42a0c987c9d6ed392ee3274e1346a86753f9ce19367df9e61a6b9da5628acafda0f52d6f9a98824a52fe19933d4a13b217f66f58a4225de56a8bd3481a77877379c9dd2e12b7fee0e6c2f2c486500cdb90b8c55adb822569c2bf6a58261b03c5a89441e00a109582e770613ca84bbfdfeb3060c4dfd8fcfd59b9fcf4336b6b98381a99db4d0f91cc27ba1dd123a3cdb04a919bcf00169a4a8098f668d3c896762342434cca070867ff66dfafa7c4d6e812b13cf60850f69c9b598a4681706de2b43dacfbf113fd128d9a4235d89f74b0655badb03b6b5e03b22091453b65995f0f06ecfbc354683bac7def288ec264fdb5062fd4ab50f5d83a01a19f04da748bf69b68c8be98e1552a535ecea1f869bebf79e6b5013f032f13638bc29a2d8143ac79bc58ab7eb2245fc7b9e0acd9c444567ea4a7934384f99f50e86aed179e53c0c20ddfe333ccf99e49be7a34fa37cfbb5b5672b87edc62bfaf734ef4f1ac73e9ef6a243777bfeed71163626ed99a01cbd3e46476be204c4c2967652cf9a0b63e65d3d0101c1a96836cf3d6de22f378bbcafdc11a5cf9b8aadca308cfbdd435d68316b17795ebea51c5b9f086e29f4f2f0ba7bcab1f93db81f9e4467e386f0b2b87104a7bc7b6112caac1ee511ebfd210573e6039bbfc934cd16d39de99298381edd84575d939f5dfb28e1285c1ed03107acff23ce28ac4d3fb83ba84cd6e469cc49ca60b1275388aa7345447c7575b03cc3b36ba7de51a0aca3f55237c58582c6536969e4aaa46f014fcf6d290f850879e9cecd6eb57b5cabb03cfe68760a2a87018120170861bbe38e35ac74d822e96914bf47726fb3e26102df682b554c51b769bf7c49fa06d4ff366a3bd9fcdfab5835efcba0d95718a3f3137f8626e4f0ab44450f4b36fce4f5c12d1304baa4d76f16ef8151ee77399f2a1c777c63500041d1aea861490313c337b0f1cdb9ab24dfcfb56d769419459f768a4dbd2467c67ebab9b64eea908429cebfad508f5b774d7dcd11a353abb87832538b5a0a065c6ddcd5cf99e9654598908047af11546223c94e1751662b836a483e205b3cfd312e3c624eda14c2342f1e2d80d8bee7de071f0871a9bb491fffaa7411cb7bcf41760d388a68e2b674597d3426f29eb7d7ce6932590f578ced2e25929d177e3aa9a351ac899388734be1224a87c3604e8a130928ca794c2d74c439a6d62c67d88ab5ac960db71f033362791378907e1905e5f8ab613a7c34a2cb446ed6c89f646b7f5fc2f9666bb1661a8f81281b45284021cbce2e2652a47e422eb0902099c583761bf2b1cc8e9a425981277498d85229c2f46a8fb24504b8b3d5a9d76e1609782156806dd49b45293c11c629fc102f2fb64b4de464c5453aa6420d0681514f4f6f28f2a9342f7392311114330f6c198e9b39aeb68dc2de743ec53fb17be4e6cd8ba0c373b76333fefd3ef86d2ad4f87f02a4949dd6cab1975d71cba4434d211fb2f49de65d7aa70746967e757d22e86405e92c1fbef94e7f202abb1fdca365a0d420483de69d3e80fae5512b7b1490aac13099e302ba273318252270743285a091f5f6555ad8b4f7356df86696511f715540743aa153b399e1b3d0f0232168addfd4924091be023aed9125ed30b8a998157a376d78dc4244134fb04ae04d2235a8a95a9157895c61a320709ee6aa178f2b21ea0b49250af98fe81ef4e82511345f86c4c2d30f8f374388d0cfb54db60a10f5866a9be79e5abf8aeaee78ac2af08b59f5e6fb9000ff3a6b9f0ffdf6408cdfca948ce8edf71d5a5bd665a42d2f52489c158870acb6a5d05a51e721a7cc2c01d2d861338358d388e296e69823ffa3ee8094a99cbd7952b3cc41dd2e39ba4caddd71857c9fe034acd65d6698a4e4f522fcd2aa8bbceb1efdc13a407304f27f07c4802f2ac2f161ba02eee20b7a545a7e65ac1b887e5f29188a9e19105baefe150a774476430f7291aa277d3eb8f03bd124ed2bf58a8159a6a4b9c0ba0e77b49f0b300997b3e0a2dcf082b3e7d4beec3ef624e8cf001245e022b13c6b4f5f5d411e965c0cada4519957ff69d58db8d15b16e9e0277ad40056d69a7735e8c81dd75c802d465328feafc003a3779f07c5135521cecc0c8003ea154da3de7b50f9bf149b080a526637176f19034b27fefef27f5cc729f26c9de15869f9fc1dad8a984537f2ecc08d1f9b424229ceffdaca87140d354a5c344d86a5df51a85c15252b25a070aeaf6c5e998c9a37081457d41c7d71b726245cc51099de56cd3c67cc4e9ff1b9b0d5a01e6524ec8c047be28e970e891a95f69989f6b286fea3d03dd866c4457bbc89d56f14a8fc90c47f7771f7462e1cf273f67e40493bcc7521c00eb5d35bc9aad4c0deddc673f0ad4073796cfdc84b971e807808c168f1a0bd4e3e21c6950aa207c659987ae7c572ddcdda258183dc0faa799874edec870d450bfedeb5a6ac21e92c6da2dcb76aa83fc7b4c3193c8b5eda8c0b6e212f31d3a56547fc03d22577dcfb60870aac676620598e03be6599b93781cadc5e20f5f77c1781cf504e3ae8cc51af02262b7657a9450796d45a9755a93c99b50108decb4205d8df1e4aff71c170711084c55235208e6fa4e5e9dd364c63b449e2bab11033c626a8d0b11966a3f26012a4fcac0b55533c3b7e51a1bb3bb21abe388b46c76d5e524978bcd0baab7d9eb6d929645b76a31efbbd795d3bd0d25e9c84d2e64da5fa722bde4134269e38f0d97d8bf9e2f49189bc97e296a533a0c0f833bd2e095f253a12f7fe2ea98275cf6dbc422eedce08e0e8f192e36e3d50277df64ded6328c1b92040c38177eb06e77d7334f91059a4d4fcda7ec6fd1738a05d6683ac964ca9329507e8559bc82fac6aefd8d378421d3794df7c155e34656536a7ed49b2aaf83705ea114495a88e608f3e2f7b5206fa3076dd49896ecdff1aafea840dc49a0b36edec88c061d43ea33f4c14e34d429c197abceb66911cc4eba7a0009c55debc3a16b8669df03e601847079e4dba9bfd1b2a93b3e59e2e72b6a9616e7b7e3b0d479146c2460bfae13405fe8947b00535c597fa2672ac706af77afe9936f4fe73d55642053b6e08b91b2127a8ae879dfef09237006e4588adbb46617ea3c0d59b411436ee33b18d498bb4048c0dccbb8854e0987cb80331053162fbdea593aff7f12d7de2ecdb54f6b27082aaa8a7b56a8fef9c4474610c035c98f04cbff241bb8a6db341177def56c42477345d8fab40eb54ca98fdbbcd6ab5a06ba7bb3ae8b88625224696ea9d8e22039f54b34028f8eec0be89cee761e7e7a9f442e1697a5d0ecaede1f8de7559d55517d1ea3f927f309122cd8c7440a309ea55bd47fe5e23832fa4b732273928c1819a7aca3bc6deeccf942c5a4cba03ce03a6192db8d4d6a334050288edf869061c993f46a3826942c2ee1a3204f40753fa90c44e23216283a60f4eae7d769b982f50936c7e40d9b1783228250729983c65dcbecbd28abb9b126db179a1189224b3f9038abf4859d079e586487368d27d26bd2c2b673ad22e79bbe1b84b773203ccc70eb1279ac6f104b0bf92c641d23e4d47756a419eca53d7575740e66b80326496dc5598517875315824e730172f4936fca4eb8350762447d157049544441986adf59d11792718e81d9ee95aea473a87c7821af7d1818ddb4f8483100a285ce504cd19ea72dff95139e81e2db6acbc0a6a54daa594e838210279f6134242b35375958046488fc9ebef643751e8f8c47dfeed6e4ae58477eb9b07c99e1a328ebac337f3d0a0a0a41d1facf3c82a9fb35b38078a9c342850ab24270480b509a60af306ddc67ee3a6e5982f28863776190b904a0ef43a2f0ec8766c5395f62f6dad8b9a6255b2394d5b7f71258591abe535ff6f6cb5c6a6a297a1cfaf6a9c3d52840fc18f7ca5ffa9934ac8319106076cd579114973fd04d65db33af0f135796ebd4919525940631732c974dd5acfdc939181670365968cd7d53501c486c96491e279c04bfd9c8abe7a28f0fea7b03b0ce378ac10801e0b49e9cf5bed670ffd448beac0d2668e2fd5b8e440e0d51dfac9f99da091be567599abc529a975218c0624c817e8e9c57271f4deaf10d2ddf424b097f28f8b002cd4b78957861f29da295784bad5d49834759be27258a077b1e6427e11457ef97af32b7fe4c073c054e6ddf55cd8016ad7f6ece5a92e825ae48e4d69ab41f022e80593b46aba15df2436ac61c3bee54e25429c4e2678172df86aea5f948a16bd752de59588747bb8910e7b0a863f99b38ee417b6688f6b24dcfd79b7658775e708b93e47398b53c05797d2cb947a46e21a61286e227480d9ebb93aa7ad19f790452fc9c87e8e6882bbbe4effd9ec62493a89cbd22ebe9a1b9db339d1a5abdeed7adf6167a7b16a7a7413ed86d2b41cea3d9226789ace2822bed0613c9cb578b759614811ab695b08a2c81dbf82c6914ab4e1a1908d8220f0188f65b1b13eee74c34e802fc7d75ab04419fcda0f0fd4f09a8adc80ef953ab0468ceeb8b2c81d19141225057e37abce48d6044bbc6f130011e835df636f43bf2968a54491a68cbe47ac475fc58432d20e81382bbd1e3d06717bc305491dea913779c41ab475597bc2416a47a17acdc5534a5a8159cc0f26acb7f85206c233c4fdb0d5e31bd26ecc9562758e2c9ae74950d2e62eb3f56069e535eec64b4276c5b0086c5f1cc32fb8555255e8bfaa56b0e70f110c91406bfe43a6fe5826f5330035b086ae7f52f8e00bce1e24f06c41290ed19d9ca56c51785fb74d3ccb68c11222bba9384565be9cd2e4e080747744067285e3fb7dbe70adac21976f361329718c98dc0d5bc2b761475b996b4cdd4af6d70970824e439e536ee798a3d294c5825bc2638dbc41a128e8c93bb7214817df46c61915e0b9515a6d6ee8b833c75c1f0c806114d225847f7c7eaf994f7713ac32b8b8b75a6975b53afe4b7ae5c90ec0df7a777fe6b4f30052c778096902e9c1a8c675d328de4d05a40f822fa11176e7e58f41375a6952ef7749f475e8d4ffa1c25ee79dff2128bd3296b612e9b8661b962be38c38e446846fa5795f3d7fc2e3d1f87e17107c33fb3f4d23faab6fb1a610bf857543ae55dccb46f05766d4afa3f469882a7efa533fdab631e51b708f2c2a4c8cc6cfbe74f51f6e1f7aeb95e1ab173adb3a3c763905c7fc559c82fdf40279b860500cf0f98f680e02a303256201eb9ffbaa0f2a346751c03409282dd4f1ccd5ee9c5e6aa6ccee0bf0e05535c0bd183385cee36f5538e86c9c674754c71fb5f60d27b89c9e01b54d26b910441b7b5f949e1240f83c6027f5d3175924699d4bab2b503e405382698665807be7cf7bc305e87a70c51b5948e34dcc6c8184b54ab87e0acb6c8ab418f0ebca3cfb70920434de8abe6cd87e3c8f150eb9b87a869a17e5e942bf06c80a84ce9cbc6c312acbef3d67846b3842e931ac21352051a82dbb50bc9cda3bb214fe2a2cd448ac57cfff9130218ad01784999a162e08147b9ab03e32ec489f798e4ffd1cf1bbef89fad0f2d5aed3c42d8460adb211ca1fca2df8c10e39485dae0b6c0f3809556c06cc73f61cdf872cca54a9f05363ffc43733b354f86ee5ffd9c29c8e76689ed549aedf45b1b4ab9bd957b2fa9e7bf6fc35844c9fb04d413685e037ab63f592e94d9e04185628c3539288f8b8cf8eb4f7989fa718a71268b5505c5d4cd8683274be28d498f4d2b104506d29f32a1b4abf89f3c07d8f3108b17d29092fde217c5b833c54f3f6d946d188deaa48e7f662c03d1f69517731cf0488558f0f297c56988d79c23933afe341f34327d7fcf27b194aa50be24cb34eaec58775241fb5d35741aeb4043d5d27c98ff66547c4a5df52f0125fdfcf4010614f5b2eb17bc4e88949100571e147d09847fb4ff0ef8d74dbf2a3bd8af4053fc17bcfc93a32649ae647b862434a91eb649d32a5ab268a40bf6c842405a9400b8f30cb6fdffb500746302549fbf7f0f6c5d2e5c35d1c97f1b0cde87d84a10e4fb0a7a4a770b6b1a3c4e05a0218a1a144c3979042a7f23cd7931eb17aacb2ba9461100ae9e54ee17cf638c770bf4f022f4c1f60d887b945575170238d5f76889753bf1e26376621b0c8eb24e48c9c21ae94c5b58493876c05f5cb1e5b1e5813ad1e7bfbd307b0fd6f8c24809611cf77529d03d67ae16e33a81dc14bd95887db34e2f76b39813ef248eaf0b7177dfdadb186aa98341dd443ef933d56ecec002cebee5f4e7d02546d38cee44bff583b957743cc0faff2e38086a198b26e335a708580d987ccf67b4ec24ad8573b1e263cb3b689e9a302cccec61bd921c7f9cf247cc8185e4d27be6982ce096dc3d03707b75c889d557daf58448afdbb19a4215b30b35f32290cbf3041c798d0db017aa055a9b1d99fd70666f175d6f05edcbbc057a8cc10d3d374d1b5cd6b4a4a6a6eae8486742f0dca69db4810a15ae805ac446cff1f37f3e04098abb6ac9efc722b5c4ce33bb98e38f8f1a3914a0b610e2dee111b49149204ae340fa539fe09dd184e9c0a73f22fa46ca0ebf24a2a23d486dd4533c0e05d4541322efaafb3494c30ad0ebc53cd9012f5dabb4c9127abfd1df7eb3abdae4bd544e6f2bba32d9c621b22ed5f2a7d8a6cf734f430a710907d81abe29eafc025e8e7d78e9941a4725fea95289a7000c12e51ceb8f3470d0824201fd09c58c60f92106e24c519018fe20bc84905238e25408a4863e34951a1b394f665845214ca3578920b058967823ec81be50acfbf3bb2acefdb79e74a7c7f6a575ac626b8e745c30e4c3c9a02594a6d6da8226bedc778ad4ab245f364280975fd93a5a5454a2a873d80bd2d1f11651076dc3214671808ade50c0677b53d9f57a061a39cf40f5b09ef54a9c0858bca0e2d1fdcaad58dfba73140d2b1b78b76537bf07402fd9579e88c21cbef956f30ae371600003221a605a010727e5d32e5ac8d3b7ccbcc354cbb7ef61709993037876e2c1f3e7a5e4a617eb66e7e1fb74d458cb71124b93095af89927b1e1389b0e23b3e2e789160d22d6f59faf4310975e6bc512219c97e9542d1ce3bac35f1592a8472f6d68d59def1791af47f3518dd4204f105a15fe8510bfd8e95f1a6d923451599f88e189131e98c651aa48c303786ff72155d14ec128febe72b26749c4c773b7aabf7e66c05d3e3d25bf7929bc9743f0af2330d1d4df0033864dc42039d9aeb512e4af71ed5ece57acc8742db5f1b49fd54770cd53768ab3712234dd267e9f32e630630ef8fe69826d32676c3278057e9dc77a9c89ecfb7989451b220212d26626ba03b684571236c78cda31129f023237f3d6452c1b98ec39fd6106b9ba5e47bfd6cdb37308949a5db3a9177c7a99c190b868bc486be717338512812b08d32c8f767c2c63563c2e61fe4aabdd32a7e5b559e582d98f185790d396888430b49158f1aafa9fa14696afe6baea42f23cf9800b8515573aa64e6e69113dcadff6e050c3b149c006fb26607d58804649fff3c0723bfcb16914214c18a0f7687f1e7cfa35e92679608c370438e935c348f0d4fd3973c0daa9c7c16a81117354006953df730b0d6b9bec9012369cc8f48382c7720d29f1e39ec45645e5cb449bff473894f2bc79efc823a7f7d0a698341831ef07ad31bd9803f385f7be169c93fcedbc97adaba5589b3af594de6e632929d8895a90cfaaa4708344b28d3a92f7242ad468ff0aa998bb6ed2c4f1d94230c88ef37490a3577d1f1a283bde898fa71a58129ba020485e716a4f8fb880219da71c498ac95b0aaa38f4dbb358cec1198d00bae94304cae7f1c31d01283432018385357cf6c293a7643245b5d3cfec696528d3dd9f07cb60b7ae621e65036db3c42f1c21a128d6bbe52238bed0200c64b8045065d7182fc5d77426d5e8a2ae957b3f437aa20ef020021242bc86db435a789a6dbf4102e9de4c6e38ff853f0911c753c099851648b5034af1e269720e5534b469d0ceda557de8c42dfd7159ec9f995d0cce989b26fbe430685a19000ceca1e668d9461727cae91231791a4a7cbe821fcc0303a6aec0119b415363cd5543d3407a9bddf919ce8876febc75738c54742c0366dd944e0abf4f83bfd26b6963133d83bfda7596757e3b041970e66d25aa298d3a7d85f3fe3e054aa44e4590fd506dd2968df4a6959046ca93e961bf4d8005ad78e94cd449a517b060945d7a2df3abc3a77960c129125195f003a524f477d4221f5a63f0b9f26ae16bf94246babdaea839cb9a547be4eb991c8315836ae0007ea31f237bca25ff0cd428154f36246ae36433143fbc76619a4df5dd010850d998275b81f5bee091a9722e5452ac33a8ca256ca6e77141eaa55ed7a6fbafb28221c2f1b4acc12fa287b8491dbbf56c4fc3e6ffa927808d09c4e1d8d02f5450887ed73bad8454e48a9629754ced3ac85260c87cb8b312005d9b7a9d3f647f4c652ef48c568a7a465979c46cb7e2f236ee3f50ba574956fe32ad8f56a4c961b3c59a9b62a9da28d6d3764f7fa4a0d532e293fd1f00d6392f94661d17218094d0dfa295ae6765081b78826452c1c578c05639f038fdd28e44b36af9d10c6c0b607adbddd7d12733b8d7ea82c08cc904478800a42e7af0402de1f2a6341a4943aebf54aa3eaf6adad80b5f218ca6d5e8b955160a106e0354fb300c1c5180e8959f96e23c78f642885f68ffca09e643a142b3bd73a9e83978fc0b66fae2c8194fe2f04c8f4569335ae6ba39a7058f750e72948e3d23ed50dc6055d2372caa134159bcb6a2c028545a8d26c9ce63ee3d83b5ba5e8ad2fed66058428345626a3d83de2c08fa398bc126c992efe9588beef2e82cbf23aa6d3ba91da26be4058c04e187d2f08b3910a3605a50a8ba6cc6e1f1aa0b7ec920111126e975eb64e386e08f41377a87c5ade9b2dd6583654a3d98db105ebbf0ac80e2256692c6f37e7502893200e4ec72dc3b7cf6e6685bf7f54c0390e2a4501278f97532565c625b16661a10f6327785573c3c2810df4ca0da2d27fb85838fa874189022f0b590d71e2a92f8d480758b37326233710d0499b27505f538201d9b2f42af8110adbd13f4ae50c27970bb3f92783b1cb203436446d5b82a38017abaf55b7175ff023e3b58bfa9ec3ddf1a2b5a42a803e09cb65da3abd1559fedb473893fd522ea58af90bf8af33ab60ef3f96ed4b992bb8fd919f492fccc1c6cf042f84f635d5666a7d7ec5260f769019396a71deb973dcab9ce9a0ffeaefac36a781fd52655453171809f82f42e188770a80424403d48087f11dbce96614b9f76c5b24a9b4cca8caf81e3a7e7489ad9dcb0597f27275e3c1c8f0fab9c0ba95f03d02b0b8a89550ad0fdd147d8fe635fddafebdbefeadefebe7994d1477142846359e226cc4928c2bf975e58f318d7000baffd2a23593a15988019d7fabdd27678a4857cd756d783e6816b7c48736fe83d2cd11b496274cba8f580b14a6c92790dab455453da70184ebaf6c99f4c76597b4aab8d407b86bb5e268275cf22ab6804e7c4eaf26546ab8162110183b0957ba571955261a670d2b83fc7b276c926a77405fa55eea3fcc21322a191b0582359ab6b5dd5bff8678439fdba3f2782b36e5ba88340887f90f2b6347af9c295eed048ef3c7ac873de388ef5522f72b17ab63c715bbf84177997da5627ebf735614d493ab01c73e38f0dfd2b1f621afc6dd5e5de03e0c3e45cb5ab46edfec5ead53bec993b73a6f411ac11601cf4ffef46fc3ae55a3f4ba62a61c26d5d6170d6a7509f81483bf48df7f5e5c38e4ddce194647c7e0a004adc8615e161f313f0a7da1bb907473bc772795c149267c80d3df3173661337849aa1c99336e7cb8c29e479366ec8513f2d034208b1d40e972b792629d65da13919e6d1c12e49817e9ca7bb2d15b5571e423d1daca0037c089c15f35059f9075cfab6b16b6e003e114ae39dd91c8864bdd14077eb73b345cc4bd6930cae7a13760751bc41e4a358c1d5c69ef9f7c605d415eb8bf5bafd7195fd6d4d034d7bdb3d75ddef4daddaa82b8f51a4ec127d5872800dcf0c657fec5148ecc922e0279fe355c97bb3c7afa33d2c994c6cbc2893cfbd817ad072aec375f2f0f11b43289f0ebefb231f044d5152ab2e0519c33461ad0e6ad0f5d624ae34b89afbfd1097edbc6a5c45d907561e8e9393c1230658ad5307c7f92d83741fbc80dfcb56e78a4c3a3990898147f815de80abae206435c435466ba30303e86fd75827c9db781547b63298d10440b85e9ebb78e4873b1e2da185444a658e147547bb80bbf852a5e847020508cd5c1c6dfc6d02122e24d564df34121d20ee37310d49340336ca590f9b2887f5d05af666a34bd61c023581b1848113596b56d0405f81c99eddad932046ddb7eacdc92eebf958c439dde9d99a85f41866535ce953448f4ef4a4c0f7c5edbf483c2ac7c177d74680ab8163f06fad9fe7be3a8533ed610ae38eedc38a34c3147aeec94102a145966e5934e52f14a0d6754d41505a647d590cd2dd4711fdf21dfd281819d9097289a77f417359fe89ce97487fbdfc001a3e9006e24f7943d961a0e370f332a054c859b787c20d92d0c67b9e40afc13d2b069d95159d497ca5203bf8d5762a852b293165ca62e2addded1099ff8d5883ef8b6555391887f99b712ed3c5efe45fdbe88c75e593e5144f8410ce7c917ecea101a2c70caf6af75f6cc268bc905af37fc4ff7d3fd29c8b77950c72ab44cbc09a2ba0f100aebc4ae8177bcdc21f491328ade40af70c43e5c5616feb873f1568d2526d3ecc8283a98f9caf0290084dd75fc554f90c3870525fd446c2f160ad6ea6f30b3188231d010627d7fbd7bda32e1cc421c1d19e9dc045f5a0cf7c362052db124ab9f035b263cc63a2caecc81f94cad706db5814ea2510c865b581391ee8a8ad0a80b084c4da29dcf9c6d55b4fe58c257bd8e40c053c87e77ff7981456ad2756d6aba44f1f591cb5ad7a3bba39802cc57504ffb267c2a999daa78e15edae435ba8c2307a3ac4db54183ca52c1968ea6ef7f70d93caa012e6663869031a7964eadc1148272bc13f93ec729af9c65520d663d8e756adf461e50b1a750845835b1b466fcdb07c68ec78ebe99bf440a0ab43a67160a5f88a3770f8490c064c7dee26cc32449b744cf323f015dff9bf75f813788cb6393a28ce6c55f8a4d64e6f3fbde4bb6c73e1931c4911337fbd74fea11f98a651b49c108265a168aa2cc5ee3441312d766faa889e646f10e0d7d96ffef004eac7f848c8df967bc6010b9222c20e895df1996fd62801d9d8586d50a1a525dc6a138b131796ad0a95804db69d33edd4462ed34421646b2cad105e348c70dd853387f45ad8f30da9e50ac170f3a8f2dca28ef54a68c3cc530ca49b93ef50738b8c3d85f201abcf4daed60752f55a01a91fda085dc11e963a40d543f354c403d7903d20aea1bf1cf43a17ad65b419d64715f046405e7695cab4de4bd7d894f74f4ddff9122378f9dc819e09631f607541635021856d4e9a460585e715ea185e29f8b79b1683e8b2dbacb8e95e57634674dd2768a8673d86ab230a3fb861ac8bd1df79bcef0c1f2d12f189f589e7852fe7c0639244f363292924e07f3adb81c1964ebfaee458ea69886caa3a1f051b2a3d2e7e22379e91dc21f45d260db0bf9a7e06efb5cd92b227be9a058a3bfcae303847d54349c05912cc2e91fc2c7d71056250ab3dfad505bbbd3176a2747f45fec44718f7c360af11eed80e8b74a8aac8c3d24847e0b33f485c2f7205c08948e0fae172bed0cb940a839cb9872a5aafde52c464071103a8349194b13aa20cee59bf1d197b372952fd1b63883068544bb5ab6d1018d6e3a70bce8dcf707885016b0a053793ba04caedeba9729761fbafeffc562d1128b846a9d57b7f512a65c47abdcb65dde9881516f4a921246af6b9c0eb1f655126740e889b2a8b1306fb27ee5960207f1d961fde10cf876581527c1e7b25bc65f98872f99ca744f4d1c3acc0715d9af0f94377b34649dc1ae700ab953d81f3fc673b8cd511ce8624618378df7dd4d377413105cfd982c33cb48c92de97216d19fb72d9849eb275c76184e4a6df48b8a88b1da5f343c690e7e82ce60922da48d64806d886ef8b8d19596061108b99f06c54fab8b012e7e062718eab0a12e06b6cd95fb68207a3a5ae871a0fb29859591c17593aed48cb3609ca9bc41c41b161ddca80e1fab9d1413e869e42698d4fbd47173a9b995c695034f90bb1ea14a68f4ab7c0615badfba763cc7582bd48ac4d6c6d68c022a0e9ecede216049e5a628833d2bd7df7fea5d5688c2a40bc747d068782a2acb665c11ed04f8a4dfd7b298443ce2e7cc78ee2ff45f8b7a350431ba6a9a7e0648e940ba4e8f23855577e32da209205c48aa2b7e2e15e8f6a5eaf964438f5e397057d9688a9ca1011b13a5609d83fed33e4396ca79fc9d9098eae998b87a283e80cf5b1e519b6f62032e2e8ecb3c36e4964ef0b72c90a7a9e5024b66b1347ac871ee6d6ffcb3b8a44950ecafef304e73383e6b7cfb5034baef1b77dae57ec26eb59c159176e637f933555e23d6ff5a2a71f1c15ead391b9d3889269b135783e5df1c2ae6e4a369d36b27bcbc5ab3dfa5c5120e4131fa4a6ae5ef99d5358926c77ab80806bd128d56c81bd7db002df198ea7cc11c6c91dedbcfc3aa5e94be1a6239ee159f092f44030619b420332d7740f8cb198d742cd360679562f01a2e1d9c67880917268ac342457df00b998b933c96d1c7539b8169ce98508c597e83f4aad5d3403b6101b574e232f317ef94b4bf91f20c9c55e6fe5b337f6d8c38d1b460e66ae6ad78e6475960a0376cd557c70e1a4227ec720a200b703da6a988d9164fe400a2a22e28c28d2e7d73b5cd041e05d0c7cb3935d7f38f3ab963096eb35439d6a35b66fbfdcec094fc56d77fba74ffd7ecda470b29777ff7149a04c2abd7bdf2491f38e637d71d4241790f2696656f6cd1d5233c65b414ea382912a8b3ff3869465f89d7dfc3cf71059810ffefcf5754a529bfd49f91deb0f099f7d90985d97fd9ba68a131e30632ed22de2f94a744ba7a0bf6b28add41aa84b78b972b2e8ae5d979b65d8a732bd0449bbb344785ad98aff1de5e000885ffd3243c7cd1740a298c2d1276406248000a6fce4891bb810448ea3b17f7323b314b6f111c371aed219602bf468beb627b6eaf79df5cab7567c5959c97bb8e61594aecd30d83c1481c352158fa979c75fd62cb6187628033e7ed38c9770839f38805433e85b07772e5206beb82fe34209c2ff35d3feb1bcc414e9ed7759aa08573c910125c1a09856293bdddfea8f0a4620face019e564160188bc2bbfc868acafaf93a6f441ee8ba60fb1e597d53a4c6033b324c7000a43d5c2001d8afc36ebd3fd3d2ba7042b36de4c7f1f80aa2502b2e28e974305584a3539c7340fc7e348d027d4842078456f5df300ba41631fb55d914e6985cf2544e34251e3d45787577a8e56942f3e08724f1fe3836c80b029a6a921b88e41cd04dcdc1965ebc3d0fced80c112bcbd69b08059d60a8e708dd481fcbb20008d59b2b35d5c450d1f0f265eb87e130a44b7eed11f07251eb4c634dbd0fe8a07e6e7714756c91d0833758b0167f355f08947d45e3f7b405c230fa5a5f1c00cb51f9ce219e8e8f0879487afdc30f68dd455f8ff345ea024516dd62d356198f3871546831d106c7e5135cc8f22448d2fc59e13d9c1f5ab965b12655c6c9446f4a0e9b3c13158cba1a0a394abf374b6e82f96d569597a6d73597d4c91d027b1179bffa489a09f5318410853ab433a1d4491b27a2147c4abfec641252721ed93adde2edf10abbaff503db7bc0468262afd2c6fb09af7b8c6140fe92b73fdb1c300a1c5b21283f12c9fe12bc07db9983a84a704ee64309e4861c3c37602266918676d637d1363cf0d3bb70ad60f62581832dfbc1aa0a87b537aac88a015918ab4794453de15aea76a057c83621dc9c1dae42783694044e718ecb955a73d4ddc41fb57dea3811bf87028a0573abb0e6cf2fa1461bed7007eeb32e11b9c2a1faf6711259bcbe0db4dc6d15e30456a09d50351873573d5bda6dcb9c23a7021325b7a15efade9e1410327ebf9995114d8c8485881a310e4eeb5f483afc4443cc178bfca9301a23ce3032a1bc9cdc13c342e5d9230210edd0b1c404429876cdb0b58e26a4dd7fac14cd8e8bc4efdf65d8c4e49dc7629896f67043b9b2f848b06ec0228f910d1afbb5b9aee08d2aecf3d86d7dab81bcf6e64b7fee97e65763db30107bc5728de66d02788a9a2c269f18e0a0738f76835733483f9c87b2cc018d7829a500976e22aa435778992edb1b6bc9fae531cfcbc7f91b6adacd6be67e9bc854041a89d1e223f152457789c44812a36945aac0f130c087152f4562a7ede5a3122daf9b7294d3e3f8aa19e457c9f0a52dd383dade2e5e4437fc82ab019d696b74418a9a6d7a68475634c80a628edaea7de61d4b62e54ef7476da1640bf926eaad1201</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
